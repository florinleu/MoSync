<html lang="en">
<head>
<title>Untitled</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Untitled">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; }
  span.sansserif { font-family:sans-serif; font-weight:normal; }
--></style>
</head>
<body>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">The Red Hat newlib C Library</h2>

<!-- The menu contents depend on the configuration, so we include them -->
<!-- as a separate file -->
<!-- switch to set SIGNALS on or off, according to whether config picks up -->
<!-- signal subdirectory: -->
<ul class="menu">
<li><a accesskey="1" href="#Introduction">Introduction</a>
<li><a accesskey="2" href="#Stdlib">Stdlib</a>
<li><a accesskey="3" href="#Ctype">Ctype</a>
<li><a accesskey="4" href="#Stdio">Stdio</a>

<li><a accesskey="5" href="#Stdio64">Stdio64</a>

<li><a accesskey="6" href="#Strings">Strings</a>
<li><a accesskey="7" href="#Wchar-strings">Wchar strings</a>

<li><a accesskey="8" href="#Signals">Signals</a>

<li><a accesskey="9" href="#Timefns">Timefns</a>
<li><a href="#Locale">Locale</a>
<li><a href="#Reentrancy">Reentrancy</a>

<li><a href="#Misc">Misc</a>

<li><a href="#Posix">Posix</a>
<li><a href="#Syscalls">Syscalls</a>
<li><a href="#Arglists">Arglists</a>

<li><a href="#Library-Index">Library Index</a>
</ul>

<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Stdlib">Stdlib</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Introduction</h2>

<p>This reference manual describes the functions provided by the Red Hat
&ldquo;newlib&rdquo; version of the standard ANSI C library.  This document is not
intended as an overview or a tutorial for the C library.  Each library
function is listed with a synopsis of its use, a brief description,
return values (including error handling), and portability issues.

   <p>Some of the library functions depend on support from the underlying
operating system and may not be available on every platform.  For
embedded systems in particular, many of these underlying operating
system services may not be available or may not be fully functional.
The specific operating system subroutines required for a particular
library function are listed in the &ldquo;Portability&rdquo; section of the
function description.  See <a href="#Syscalls">Syscalls</a>, for a description of the
relevant operating system calls.

<div class="node">
<a name="Stdlib"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ctype">Ctype</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Standard Utility Functions (<samp><span class="file">stdlib.h</span></samp>)</h2>

<p>This chapter groups utility functions useful in a variety of programs.
The corresponding declarations are in the header file <samp><span class="file">stdlib.h</span></samp>.

<ul class="menu">
<li><a accesskey="1" href="#g_t_005fExit">_Exit</a>:        End program execution without cleaning up
<li><a accesskey="2" href="#a64l">a64l</a>:         String to long long
<li><a accesskey="3" href="#abort">abort</a>:        Abnormal termination of a program
<li><a accesskey="4" href="#abs">abs</a>:          Integer absolute value (magnitude)
<li><a accesskey="5" href="#assert">assert</a>:       Macro for Debugging Diagnostics
<li><a accesskey="6" href="#atexit">atexit</a>:       Request execution of functions at program exit
<li><a accesskey="7" href="#atof">atof</a>:         String to double or float
<li><a accesskey="8" href="#atoi">atoi</a>:         String to integer
<li><a accesskey="9" href="#atoll">atoll</a>:        String to long long
<li><a href="#bsearch">bsearch</a>: 	Binary search
<li><a href="#calloc">calloc</a>:       Allocate space for arrays
<li><a href="#div">div</a>:          Divide two integers
<li><a href="#ecvtbuf">ecvtbuf</a>:      Double or float to string of digits
<li><a href="#ecvt">ecvt</a>:         Double or float to string of digits (malloc result)
<li><a href="#g_t_005f_005fenv_005flock">__env_lock</a>: 		Lock environment list for getenv and setenv
<li><a href="#gvcvt">gvcvt</a>:        Format double or float as string
<li><a href="#exit">exit</a>:         End program execution
<li><a href="#getenv">getenv</a>:       Look up environment variable
<li><a href="#labs">labs</a>:         Long integer absolute value (magnitude)
<li><a href="#ldiv">ldiv</a>:         Divide two long integers
<li><a href="#llabs">llabs</a>:        Long long integer absolute value (magnitude)
<li><a href="#lldiv">lldiv</a>:        Divide two long long integers
<li><a href="#malloc">malloc</a>:       Allocate and manage memory (malloc, realloc, free)
<li><a href="#mallinfo">mallinfo</a>: 	Get information about allocated memory
<li><a href="#g_t_005f_005fmalloc_005flock">__malloc_lock</a>: 	Lock memory pool for malloc and free
<li><a href="#mbsrtowcs">mbsrtowcs</a>: 	Convert a character string to a wide-character string
<li><a href="#mbstowcs">mbstowcs</a>: 	Minimal multibyte string to wide string converter
<li><a href="#mblen">mblen</a>: 	Minimal multibyte length
<li><a href="#mbtowc">mbtowc</a>:       Minimal multibyte to wide character converter
<li><a href="#on_005fexit">on_exit</a>:      Request execution of functions at program exit
<li><a href="#qsort">qsort</a>: 	Array sort
<li><a href="#rand">rand</a>:         Pseudo-random numbers
<li><a href="#rand48">rand48</a>:       Uniformly distributed pseudo-random numbers
<li><a href="#strtod">strtod</a>:       String to double or float
<li><a href="#strtol">strtol</a>:       String to long
<li><a href="#strtoll">strtoll</a>:      String to long long
<li><a href="#strtoul">strtoul</a>:      String to unsigned long
<li><a href="#strtoull">strtoull</a>:     String to unsigned long long
<li><a href="#wcsrtombs">wcsrtombs</a>: 	Convert a wide-character string to a character string
<li><a href="#wcstod">wcstod</a>:       Wide string to double or float
<li><a href="#wcstol">wcstol</a>:       Wide string to long
<li><a href="#wcstoll">wcstoll</a>:      Wide string to long long
<li><a href="#wcstoul">wcstoul</a>:      Wide string to unsigned long
<li><a href="#wcstoull">wcstoull</a>:     Wide string to unsigned long long
<li><a href="#system">system</a>:       Execute command string
<li><a href="#wcstombs">wcstombs</a>: 	Minimal wide string to multibyte string converter
<li><a href="#wctomb">wctomb</a>:       Minimal wide character to multibyte converter
</ul>

<div class="node">
<a name="_Exit"></a>
<a name="g_t_005fExit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#a64l">a64l</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.1 <code>_Exit</code>&mdash;end program execution with no cleanup processing</h3>

<p><a name="index-g_t_005fExit-1"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void _Exit(int <var>code</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>_Exit</code> to return control from a program to the host operating
environment.  Use the argument <var>code</var> to pass an exit status to the
operating environment: two particular values, <code>EXIT_SUCCESS</code> and
<code>EXIT_FAILURE</code>, are defined in `<code>stdlib.h</code>' to indicate success or
failure in a portable fashion.

   <p><code>_Exit</code> differs from <code>exit</code> in that it does not run any
application-defined cleanup functions registered with <code>atexit</code> and
it does not clean up files and streams.  It is identical to <code>_exit</code>.

   <p><br>
<strong>Returns</strong><br>
<code>_Exit</code> does not return to its caller.

   <p><br>
<strong>Portability</strong><br>
<code>_Exit</code> is defined by the C99 standard.

   <p>Supporting OS subroutines required: <code>_exit</code>.

   <p><br>

<div class="node">
<a name="a64l"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#abort">abort</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005fExit">_Exit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.2 <code>a64l</code>, <code>l64a</code>&mdash;convert between radix-64 ASCII string and long</h3>

<p><a name="index-a64l-2"></a><a name="index-l64a-3"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long a64l(const char *<var>input</var>);
     char *l64a(long <var>input</var>);

</pre>
   <p><strong>Description</strong><br>
Conversion is performed between long and radix-64 characters.  The
<code>l64a</code> routine transforms up to 32 bits of input value starting from
least significant bits to the most significant bits.  The input value
is split up into a maximum of 5 groups of 6 bits and possibly one
group of 2 bits (bits 31 and 30).

   <p>Each group of 6 bits forms a value from 0&ndash;63 which is translated into
a character as follows:

     <ul>
<li>0 = '.'
<li>1 = '/'
<li>2&ndash;11 = '0' to '9'
<li>12&ndash;37 = 'A' to 'Z'
<li>38&ndash;63 = 'a' to 'z'
</ul>

   <p>When the remaining bits are zero or all bits have been translated, a
null terminator is appended to the string.  An input value of 0
results in the empty string.

   <p>The <code>a64l</code> function performs the reverse translation.  Each
character is used to generate a 6-bit value for up to 30 bits and then
a 2-bit value to complete a 32-bit result.  The null terminator means
that the remaining digits are 0.  An empty input string or NULL string
results in 0L.  An invalid string results in undefined behavior.  If
the size of a long is greater than 32 bits, the result is sign-extended.

   <p><br>
<strong>Returns</strong><br>
<code>l64a</code> returns a null-terminated string of 0 to 6 characters.
<code>a64l</code> returns the 32-bit translated value from the input character string.

   <p><br>
<strong>Portability</strong><br>
<code>l64a</code> and <code>a64l</code> are non-ANSI and are defined by the Single Unix Specification.

   <p>Supporting OS subroutines required: None.

   <p><br>

<div class="node">
<a name="abort"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#abs">abs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#a64l">a64l</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.3 <code>abort</code>&mdash;abnormal termination of a program</h3>

<p><a name="index-abort-4"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void abort(void);

</pre>
   <p><strong>Description</strong><br>
Use <code>abort</code> to signal that your program has detected a condition it
cannot deal with.  Normally, <code>abort</code> ends your program's execution.

   <p>Before terminating your program, <code>abort</code> raises the exception <code>SIGABRT</code>
(using `<code>raise(SIGABRT)</code>').  If you have used <code>signal</code> to register
an exception handler for this condition, that handler has the
opportunity to retain control, thereby avoiding program termination.

   <p>In this implementation, <code>abort</code> does not perform any stream- or
file-related cleanup (the host environment may do so; if not, you can
arrange for your program to do its own cleanup with a <code>SIGABRT</code>
exception handler).

   <p><br>
<strong>Returns</strong><br>
<code>abort</code> does not return to its caller.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>abort</code>.

   <p>Supporting OS subroutines required: <code>_exit</code> and optionally, <code>write</code>.

   <p><br>

<div class="node">
<a name="abs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#assert">assert</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#abort">abort</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.4 <code>abs</code>&mdash;integer absolute value (magnitude)</h3>

<p><a name="index-abs-5"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int abs(int <var>i</var>);

</pre>
   <p><strong>Description</strong><br>
<code>abs</code> returns
the absolute value of <var>i</var> (also called the magnitude
of <var>i</var>).  That is, if <var>i</var> is negative, the result is the opposite
of <var>i</var>, but if <var>i</var> is nonnegative the result is <var>i</var>.

   <p>The similar function <code>labs</code> uses and returns <code>long</code> rather than <code>int</code> values.

   <p><br>
<strong>Returns</strong><br>
The result is a nonnegative integer.

   <p><br>
<strong>Portability</strong><br>
<code>abs</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="assert"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#atexit">atexit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#abs">abs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.5 <code>assert</code>&mdash;macro for debugging diagnostics</h3>

<p><a name="index-assert-6"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;assert.h&gt;
     void assert(int <var>expression</var>);

</pre>
   <p><strong>Description</strong><br>
Use this macro to embed debuggging diagnostic statements in
your programs.  The argument <var>expression</var> should be an
expression which evaluates to true (nonzero) when your program
is working as you intended.

   <p>When <var>expression</var> evaluates to false (zero), <code>assert</code>
calls <code>abort</code>, after first printing a message showing what
failed and where:

<pre class="smallexample">      Assertion failed: <var>expression</var>, file <var>filename</var>, line <var>lineno</var>, function: <var>func</var>
</pre>
   <p>If the name of the current function is not known (for example,
when using a C89 compiler that does not understand __func__),
the function location is omitted.

   <p>The macro is defined to permit you to turn off all uses of
<code>assert</code> at compile time by defining <code>NDEBUG</code> as a
preprocessor variable.   If you do this, the <code>assert</code> macro
expands to

<pre class="smallexample">      (void(0))
</pre>
   <p><br>
<strong>Returns</strong><br>
<code>assert</code> does not return a value.

   <p><br>
<strong>Portability</strong><br>
The <code>assert</code> macro is required by ANSI, as is the behavior
when <code>NDEBUG</code> is defined.

   <p>Supporting OS subroutines required (only if enabled): <code>close</code>, <code>fstat</code>,
<code>getpid</code>, <code>isatty</code>, <code>kill</code>, <code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="atexit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#atof">atof</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#assert">assert</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.6 <code>atexit</code>&mdash;request execution of functions at program exit</h3>

<p><a name="index-atexit-7"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int atexit (void (*<var>function</var>)(void));

</pre>
   <p><strong>Description</strong><br>
You can use <code>atexit</code> to enroll functions in a list of functions that
will be called when your program terminates normally.  The argument is
a pointer to a user-defined function (which must not require arguments and
must not return a result).

   <p>The functions are kept in a LIFO stack; that is, the last function
enrolled by <code>atexit</code> will be the first to execute when your program
exits.

   <p>There is no built-in limit to the number of functions you can enroll
in this list; however, after every group of 32 functions is enrolled,
<code>atexit</code> will call <code>malloc</code> to get space for the next part of the
list.   The initial list of 32 functions is statically allocated, so
you can always count on at least that many slots available.

   <p><br>
<strong>Returns</strong><br>
<code>atexit</code> returns <code>0</code> if it succeeds in enrolling your function,
<code>-1</code> if it fails (possible only if no space was available for
<code>malloc</code> to extend the list of functions).

   <p><br>
<strong>Portability</strong><br>
<code>atexit</code> is required by the ANSI standard, which also specifies that
implementations must support enrolling at least 32 functions.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="atof"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#atoi">atoi</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#atexit">atexit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.7 <code>atof</code>, <code>atoff</code>&mdash;string to double or float</h3>

<p><a name="index-atof-8"></a><a name="index-atoff-9"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     double atof(const char *<var>s</var>);
     float atoff(const char *<var>s</var>);

</pre>
   <p><strong>Description</strong><br>
<code>atof</code> converts the initial portion of a string to a <code>double</code>.
<code>atoff</code> converts the initial portion of a string to a <code>float</code>.

   <p>The functions parse the character string <var>s</var>,
locating a substring which can be converted to a floating-point
value. The substring must match the format:
<pre class="smallexample">      [+|-]<var>digits</var>[.][<var>digits</var>][(e|E)[+|-]<var>digits</var>]
</pre>
   <p>The substring converted is the longest initial
fragment of <var>s</var> that has the expected format, beginning with
the first non-whitespace character.  The substring
is empty if <code>str</code> is empty, consists entirely
of whitespace, or if the first non-whitespace character is
something other than <code>+</code>, <code>-</code>, <code>.</code>, or a digit.

   <p><code>atof(</code><var>s</var><code>)</code> is implemented as <code>strtod(</code><var>s</var><code>, NULL)</code>.
<code>atoff(</code><var>s</var><code>)</code> is implemented as <code>strtof(</code><var>s</var><code>, NULL)</code>.

   <p><br>
<strong>Returns</strong><br>
<code>atof</code> returns the converted substring value, if any, as a
<code>double</code>; or <code>0.0</code>,  if no conversion could be performed.
If the correct value is out of the range of representable values, plus
or minus <code>HUGE_VAL</code> is returned, and <code>ERANGE</code> is stored in
<code>errno</code>.
If the correct value would cause underflow, <code>0.0</code> is returned
and <code>ERANGE</code> is stored in <code>errno</code>.

   <p><code>atoff</code> obeys the same rules as <code>atof</code>, except that it
returns a <code>float</code>.

   <p><br>
<strong>Portability</strong><br>
<code>atof</code> is ANSI C. <code>atof</code>, <code>atoi</code>, and <code>atol</code> are subsumed by <code>strod</code>
and <code>strol</code>, but are used extensively in existing code. These functions are
less reliable, but may be faster if the argument is verified to be in a valid
range.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="atoi"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#atoll">atoll</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#atof">atof</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.8 <code>atoi</code>, <code>atol</code>&mdash;string to integer</h3>

<p><a name="index-atoi-10"></a><a name="index-atol-11"></a><a name="index-g_t_005fatoi_005fr-12"></a><a name="index-g_t_005fatol_005fr-13"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int atoi(const char *<var>s</var>);
     long atol(const char *<var>s</var>);
     int _atoi_r(struct _reent *<var>ptr</var>, const char *<var>s</var>);
     long _atol_r(struct _reent *<var>ptr</var>, const char *<var>s</var>);

</pre>
   <p><strong>Description</strong><br>
<code>atoi</code> converts the initial portion of a string to an <code>int</code>.
<code>atol</code> converts the initial portion of a string to a <code>long</code>.

   <p><code>atoi(s)</code> is implemented as <code>(int)strtol(s, NULL, 10).</code>
<code>atol(s)</code> is implemented as <code>strtol(s, NULL, 10).</code>

   <p><code>_atoi_r</code> and <code>_atol_r</code> are reentrant versions of <code>atoi</code> and
<code>atol</code> respectively, passing the reentrancy struct pointer.

   <p><br>
<strong>Returns</strong><br>
The functions return the converted value, if any. If no conversion was
made, <code>0</code> is returned.

   <p><br>
<strong>Portability</strong><br>
<code>atoi</code>, <code>atol</code> are ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="atoll"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#bsearch">bsearch</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#atoi">atoi</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.9 <code>atoll</code>&mdash;convert a string to a long long integer</h3>

<p><a name="index-atoll-14"></a><a name="index-g_t_005fatoll_005fr-15"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long long atoll(const char *<var>str</var>);
     long long _atoll_r(struct _reent *<var>ptr</var>, const char *<var>str</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>atoll</code> converts the initial portion of the string
pointed to by <code>*</code><var>str</var> to a type <code>long long</code>.  A call to
atoll(str) in this implementation is equivalent to
strtoll(str, (char **)NULL, 10) including behavior on error.

   <p>The alternate function <code>_atoll_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The converted value.

   <p><br>
<strong>Portability</strong><br>
<code>atoll</code> is ISO 9899 (C99) and POSIX 1003.1-2001 compatable.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="bsearch"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#calloc">calloc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#atoll">atoll</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.10 <code>bsearch</code>&mdash;binary search</h3>

<p><a name="index-bsearch-16"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void *bsearch(const void *<var>key</var>, const void *<var>base</var>,
         size_t <var>nmemb</var>, size_t <var>size</var>,
         int (*<var>compar</var>)(const void *, const void *));

</pre>
   <p><strong>Description</strong><br>
<code>bsearch</code> searches an array beginning at <var>base</var> for any element
that matches <var>key</var>, using binary search.  <var>nmemb</var> is the element
count of the array; <var>size</var> is the size of each element.

   <p>The array must be sorted in ascending order with respect to the
comparison function <var>compar</var> (which you supply as the last argument of
<code>bsearch</code>).

   <p>You must define the comparison function <code>(*</code><var>compar</var><code>)</code> to have two
arguments; its result must be negative if the first argument is
less than the second, zero if the two arguments match, and
positive if the first argument is greater than the second (where
&ldquo;less than&rdquo; and &ldquo;greater than&rdquo; refer to whatever arbitrary
ordering is appropriate).

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to an element of <var>array</var> that matches <var>key</var>.  If
more than one matching element is available, the result may point to
any of them.

   <p><br>
<strong>Portability</strong><br>
<code>bsearch</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="calloc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#div">div</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#bsearch">bsearch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.11 <code>calloc</code>&mdash;allocate space for arrays</h3>

<p><a name="index-calloc-17"></a><a name="index-g_t_005fcalloc_005fr-18"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void *calloc(size_t <var>n</var>, size_t <var>s</var>);
     void *_calloc_r(void *<var>reent</var>, size_t <var>n</var>, size_t <var>s</var>);
</pre>
   <p><strong>Description</strong><br>
Use <code>calloc</code> to request a block of memory sufficient to hold an
array of <var>n</var> elements, each of which has size <var>s</var>.

   <p>The memory allocated by <code>calloc</code> comes out of the same memory pool
used by <code>malloc</code>, but the memory block is initialized to all zero
bytes.  (To avoid the overhead of initializing the space, use
<code>malloc</code> instead.)

   <p>The alternate function <code>_calloc_r</code> is reentrant.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
If successful, a pointer to the newly allocated space.

   <p>If unsuccessful, <code>NULL</code>.

   <p><br>
<strong>Portability</strong><br>
<code>calloc</code> is ANSI.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="div"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ecvtbuf">ecvtbuf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#calloc">calloc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.12 <code>div</code>&mdash;divide two integers</h3>

<p><a name="index-div-19"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     div_t div(int <var>n</var>, int <var>d</var>);

</pre>
   <p><strong>Description</strong><br>
Divide
<var>n</var>/<var>d</var>,
returning quotient and remainder as two integers in a structure <code>div_t</code>.

   <p><br>
<strong>Returns</strong><br>
The result is represented with the structure

<pre class="smallexample">      typedef struct
      {
       int quot;
       int rem;
      } div_t;
</pre>
   <p>where the <code>quot</code> field represents the quotient, and <code>rem</code> the
remainder.  For nonzero <var>d</var>, if `<var>r</var><code> = div(</code><var>n</var><code>,</code><var>d</var><code>);</code>' then
<var>n</var> equals `<var>r</var><code>.rem + </code><var>d</var><code>*</code><var>r</var><code>.quot</code>'.

   <p>To divide <code>long</code> rather than <code>int</code> values, use the similar
function <code>ldiv</code>.

   <p><br>
<strong>Portability</strong><br>
<code>div</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="ecvt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005f_005fenv_005flock">__env_lock</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ecvtbuf">ecvtbuf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.13 <code>ecvt</code>, <code>ecvtf</code>, <code>fcvt</code>, <code>fcvtf</code>&mdash;double or float to string</h3>

<p><a name="index-ecvt-20"></a><a name="index-ecvtf-21"></a><a name="index-fcvt-22"></a><a name="index-fcvtf-23"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;

     char *ecvt(double <var>val</var>, int <var>chars</var>, int *<var>decpt</var>, int *<var>sgn</var>);
     char *ecvtf(float <var>val</var>, int <var>chars</var>, int *<var>decpt</var>, int *<var>sgn</var>);

     char *fcvt(double <var>val</var>, int <var>decimals</var>,
         int *<var>decpt</var>, int *<var>sgn</var>);
     char *fcvtf(float <var>val</var>, int <var>decimals</var>,
         int *<var>decpt</var>, int *<var>sgn</var>);

</pre>
   <p><strong>Description</strong><br>
<code>ecvt</code> and <code>fcvt</code> produce (null-terminated) strings of digits
representating the <code>double</code> number <var>val</var>.
<code>ecvtf</code> and <code>fcvtf</code> produce the corresponding character
representations of <code>float</code> numbers.

   <p>(The <code>stdlib</code> functions <code>ecvtbuf</code> and <code>fcvtbuf</code> are reentrant
versions of <code>ecvt</code> and <code>fcvt</code>.)

   <p>The only difference between <code>ecvt</code> and <code>fcvt</code> is the
interpretation of the second argument (<var>chars</var> or <var>decimals</var>).
For <code>ecvt</code>, the second argument <var>chars</var> specifies the total number
of characters to write (which is also the number of significant digits
in the formatted string, since these two functions write only digits).
For <code>fcvt</code>, the second argument <var>decimals</var> specifies the number of
characters to write after the decimal point; all digits for the integer
part of <var>val</var> are always included.

   <p>Since <code>ecvt</code> and <code>fcvt</code> write only digits in the output string,
they record the location of the decimal point in <code>*</code><var>decpt</var>, and
the sign of the number in <code>*</code><var>sgn</var>.  After formatting a number,
<code>*</code><var>decpt</var> contains the number of digits to the left of the
decimal point.  <code>*</code><var>sgn</var> contains <code>0</code> if the number is positive,
and <code>1</code> if it is negative.

   <p><br>
<strong>Returns</strong><br>
All four functions return a pointer to the new string containing a
character representation of <var>val</var>.

   <p><br>
<strong>Portability</strong><br>
None of these functions are ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

   <p><br>
<div class="node">
<a name="gvcvt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#exit">exit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005f_005fenv_005flock">__env_lock</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.14 <code>gvcvt</code>, <code>gcvtf</code>&mdash;format double or float as string</h3>

<p><a name="index-gcvt-24"></a><a name="index-gcvtf-25"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;

     char *gcvt(double <var>val</var>, int <var>precision</var>, char *<var>buf</var>);
     char *gcvtf(float <var>val</var>, int <var>precision</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
<code>gcvt</code> writes a fully formatted number as a null-terminated
string in the buffer <code>*</code><var>buf</var>.  <code>gdvtf</code> produces corresponding
character representations of <code>float</code> numbers.

   <p><code>gcvt</code> uses the same rules as the <code>printf</code> format
`<code>%.</code><var>precision</var><code>g</code>'&mdash;only negative values are signed (with
`<code>-</code>'), and either exponential or ordinary decimal-fraction format
is chosen depending on the number of significant digits (specified by
<var>precision</var>).

   <p><br>
<strong>Returns</strong><br>
The result is a pointer to the formatted representation of <var>val</var>
(the same as the argument <var>buf</var>).

   <p><br>
<strong>Portability</strong><br>
Neither function is ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="ecvtbuf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ecvt">ecvt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#div">div</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.15 <code>ecvtbuf</code>, <code>fcvtbuf</code>&mdash;double or float to string</h3>

<p><a name="index-ecvtbuf-26"></a><a name="index-fcvtbuf-27"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     char *ecvtbuf(double <var>val</var>, int <var>chars</var>, int *<var>decpt</var>,
         int *<var>sgn</var>, char *<var>buf</var>);

     char *fcvtbuf(double <var>val</var>, int <var>decimals</var>, int *<var>decpt</var>,
         int *<var>sgn</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
<code>ecvtbuf</code> and <code>fcvtbuf</code> produce (null-terminated) strings
of digits representating the <code>double</code> number <var>val</var>.

   <p>The only difference between <code>ecvtbuf</code> and <code>fcvtbuf</code> is the
interpretation of the second argument (<var>chars</var> or
<var>decimals</var>). For <code>ecvtbuf</code>, the second argument <var>chars</var>
specifies the total number of characters to write (which is
also the number of significant digits in the formatted string,
since these two functions write only digits). For <code>fcvtbuf</code>,
the second argument <var>decimals</var> specifies the number of
characters to write after the decimal point; all digits for
the integer part of <var>val</var> are always included.

   <p>Since <code>ecvtbuf</code> and <code>fcvtbuf</code> write only digits in the
output string, they record the location of the decimal point
in <code>*</code><var>decpt</var>, and the sign of the number in <code>*</code><var>sgn</var>.
After formatting a number, <code>*</code><var>decpt</var> contains the number
of digits to the left of the decimal point.  <code>*</code><var>sgn</var>
contains <code>0</code> if the number is positive, and <code>1</code> if it is
negative.  For both functions, you supply a pointer <var>buf</var> to
an area of memory to hold the converted string.

   <p><br>
<strong>Returns</strong><br>
Both functions return a pointer to <var>buf</var>, the string
containing a character representation of <var>val</var>.

   <p><br>
<strong>Portability</strong><br>
Neither function is ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="__env_lock"></a>
<a name="g_t_005f_005fenv_005flock"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#gvcvt">gvcvt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ecvt">ecvt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.16 <code>__env_lock</code>, <code>__env_unlock</code>&mdash;lock environ variable</h3>

<p><a name="index-g_t_005f_005fenv_005flock-28"></a><a name="index-g_t_005f_005fenv_005funlock-29"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;envlock.h&gt;
     void __env_lock (struct _reent *<var>reent</var>);
     void __env_unlock (struct _reent *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>setenv</code> family of routines call these functions when they need to
modify the environ variable.  The version of these routines supplied in the
library use the lock API defined in sys/lock.h.  If multiple threads of
execution can call <code>setenv</code>, or if <code>setenv</code> can be called reentrantly,
then you need to define your own versions of these functions in order to
safely lock the memory pool during a call.  If you do not, the memory pool
may become corrupted.

   <p>A call to <code>setenv</code> may call <code>__env_lock</code> recursively; that is,
the sequence of calls may go <code>__env_lock</code>, <code>__env_lock</code>,
<code>__env_unlock</code>, <code>__env_unlock</code>.  Any implementation of these
routines must be careful to avoid causing a thread to wait for a lock
that it already holds.

   <p><br>

<div class="node">
<a name="exit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getenv">getenv</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#gvcvt">gvcvt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.17 <code>exit</code>&mdash;end program execution</h3>

<p><a name="index-exit-30"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void exit(int <var>code</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>exit</code> to return control from a program to the host operating
environment.  Use the argument <var>code</var> to pass an exit status to the
operating environment: two particular values, <code>EXIT_SUCCESS</code> and
<code>EXIT_FAILURE</code>, are defined in `<code>stdlib.h</code>' to indicate success or
failure in a portable fashion.

   <p><code>exit</code> does two kinds of cleanup before ending execution of your
program.  First, it calls all application-defined cleanup functions
you have enrolled with <code>atexit</code>.  Second, files and streams are
cleaned up: any pending output is delivered to the host system, each
open file or stream is closed, and files created by <code>tmpfile</code> are
deleted.

   <p><br>
<strong>Returns</strong><br>
<code>exit</code> does not return to its caller.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>exit</code>, and specifies that <code>EXIT_SUCCESS</code> and
<code>EXIT_FAILURE</code> must be defined.

   <p>Supporting OS subroutines required: <code>_exit</code>.

   <p><br>

<div class="node">
<a name="getenv"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#labs">labs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#exit">exit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.18 <code>getenv</code>&mdash;look up environment variable</h3>

<p><a name="index-getenv-31"></a><a name="index-environ-32"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     char *getenv(const char *<var>name</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getenv</code> searches the list of environment variable names and values
(using the global pointer &ldquo;<code>char **environ</code>&rdquo;) for a variable whose
name matches the string at <var>name</var>.  If a variable name matches,
<code>getenv</code> returns a pointer to the associated value.

   <p><br>
<strong>Returns</strong><br>
A pointer to the (string) value of the environment variable, or
<code>NULL</code> if there is no such environment variable.

   <p><br>
<strong>Portability</strong><br>
<code>getenv</code> is ANSI, but the rules for properly forming names of environment
variables vary from one system to another.

   <p><code>getenv</code> requires a global pointer <code>environ</code>.

   <p><br>

<div class="node">
<a name="labs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ldiv">ldiv</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getenv">getenv</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.19 <code>labs</code>&mdash;long integer absolute value</h3>

<p><a name="index-labs-33"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long labs(long <var>i</var>);

</pre>
   <p><strong>Description</strong><br>
<code>labs</code> returns
the absolute value of <var>i</var> (also called the magnitude
of <var>i</var>).  That is, if <var>i</var> is negative, the result is the opposite
of <var>i</var>, but if <var>i</var> is nonnegative the result is <var>i</var>.

   <p>The similar function <code>abs</code> uses and returns <code>int</code> rather than
<code>long</code> values.

   <p><br>
<strong>Returns</strong><br>
The result is a nonnegative long integer.

   <p><br>
<strong>Portability</strong><br>
<code>labs</code> is ANSI.

   <p>No supporting OS subroutine calls are required.

   <p><br>

<div class="node">
<a name="ldiv"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#llabs">llabs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#labs">labs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.20 <code>ldiv</code>&mdash;divide two long integers</h3>

<p><a name="index-ldiv-34"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     ldiv_t ldiv(long <var>n</var>, long <var>d</var>);

</pre>
   <p><strong>Description</strong><br>
Divide
<var>n</var>/<var>d</var>,
returning quotient and remainder as two long integers in a structure <code>ldiv_t</code>.

   <p><br>
<strong>Returns</strong><br>
The result is represented with the structure

<pre class="smallexample">      typedef struct
      {
       long quot;
       long rem;
      } ldiv_t;
</pre>
   <p>where the <code>quot</code> field represents the quotient, and <code>rem</code> the
remainder.  For nonzero <var>d</var>, if `<var>r</var><code> = ldiv(</code><var>n</var><code>,</code><var>d</var><code>);</code>' then
<var>n</var> equals `<var>r</var><code>.rem + </code><var>d</var><code>*</code><var>r</var><code>.quot</code>'.

   <p>To divide <code>int</code> rather than <code>long</code> values, use the similar
function <code>div</code>.

   <p><br>
<strong>Portability</strong><br>
<code>ldiv</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="llabs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#lldiv">lldiv</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ldiv">ldiv</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.21 <code>llabs</code>&mdash;compute the absolute value of an long long integer.</h3>

<p><a name="index-llabs-35"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long long llabs(long long j);

</pre>
   <p><strong>Description</strong><br>
The <code>llabs</code> function computes the absolute value of the long long integer
argument <var>j</var> (also called the magnitude of <var>j</var>).

   <p>The similar function <code>labs</code> uses and returns <code>long</code> rather than
<code>long long</code> values.

   <p><br>
<strong>Returns</strong><br>
A nonnegative long long integer.

   <p><br>
<strong>Portability</strong><br>
<code>llabs</code> is ISO 9899 (C99) compatable.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="lldiv"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#malloc">malloc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#llabs">llabs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.22 <code>lldiv</code>&mdash;divide two long long integers</h3>

<p><a name="index-lldiv-36"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     lldiv_t lldiv(long long <var>n</var>, long long <var>d</var>);

</pre>
   <p><strong>Description</strong><br>
Divide
<var>n</var>/<var>d</var>,
returning quotient and remainder as two long long integers in a structure
<code>lldiv_t</code>.

   <p><br>
<strong>Returns</strong><br>
The result is represented with the structure

<pre class="smallexample">      typedef struct
      {
       long long quot;
       long long rem;
      } lldiv_t;
</pre>
   <p>where the <code>quot</code> field represents the quotient, and <code>rem</code> the
remainder.  For nonzero <var>d</var>, if `<var>r</var><code> = ldiv(</code><var>n</var><code>,</code><var>d</var><code>);</code>' then
<var>n</var> equals `<var>r</var><code>.rem + </code><var>d</var><code>*</code><var>r</var><code>.quot</code>'.

   <p>To divide <code>long</code> rather than <code>long long</code> values, use the similar
function <code>ldiv</code>.

   <p><br>
<strong>Portability</strong><br>
<code>lldiv</code> is ISO 9899 (C99) compatable.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="malloc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mallinfo">mallinfo</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#lldiv">lldiv</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.23 <code>malloc</code>, <code>realloc</code>, <code>free</code>&mdash;manage memory</h3>

<p><a name="index-malloc-37"></a><a name="index-realloc-38"></a><a name="index-reallocf-39"></a><a name="index-free-40"></a><a name="index-memalign-41"></a><a name="index-malloc_005fusable_005fsize-42"></a><a name="index-g_t_005fmalloc_005fr-43"></a><a name="index-g_t_005frealloc_005fr-44"></a><a name="index-g_t_005freallocf_005fr-45"></a><a name="index-g_t_005ffree_005fr-46"></a><a name="index-g_t_005fmemalign_005fr-47"></a><a name="index-g_t_005fmalloc_005fusable_005fsize_005fr-48"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void *malloc(size_t <var>nbytes</var>);
     void *realloc(void *<var>aptr</var>, size_t <var>nbytes</var>);
     void *reallocf(void *<var>aptr</var>, size_t <var>nbytes</var>);
     void free(void *<var>aptr</var>);

     void *memalign(size_t <var>align</var>, size_t <var>nbytes</var>);

     size_t malloc_usable_size(void *<var>aptr</var>);

     void *_malloc_r(void *<var>reent</var>, size_t <var>nbytes</var>);
     void *_realloc_r(void *<var>reent</var>,
         void *<var>aptr</var>, size_t <var>nbytes</var>);
     void *_reallocf_r(void *<var>reent</var>,
         void *<var>aptr</var>, size_t <var>nbytes</var>);
     void _free_r(void *<var>reent</var>, void *<var>aptr</var>);

     void *_memalign_r(void *<var>reent</var>,
         size_t <var>align</var>, size_t <var>nbytes</var>);

     size_t _malloc_usable_size_r(void *<var>reent</var>, void *<var>aptr</var>);

</pre>
   <p><strong>Description</strong><br>
These functions manage a pool of system memory.

   <p>Use <code>malloc</code> to request allocation of an object with at least
<var>nbytes</var> bytes of storage available.  If the space is available,
<code>malloc</code> returns a pointer to a newly allocated block as its result.

   <p>If you already have a block of storage allocated by <code>malloc</code>, but
you no longer need all the space allocated to it, you can make it
smaller by calling <code>realloc</code> with both the object pointer and the
new desired size as arguments.  <code>realloc</code> guarantees that the
contents of the smaller object match the beginning of the original object.

   <p>Similarly, if you need more space for an object, use <code>realloc</code> to
request the larger size; again, <code>realloc</code> guarantees that the
beginning of the new, larger object matches the contents of the
original object.

   <p>When you no longer need an object originally allocated by <code>malloc</code>
or <code>realloc</code> (or the related function <code>calloc</code>), return it to the
memory storage pool by calling <code>free</code> with the address of the object
as the argument.  You can also use <code>realloc</code> for this purpose by
calling it with <code>0</code> as the <var>nbytes</var> argument.

   <p>The <code>reallocf</code> function behaves just like <code>realloc</code> except if the
function is required to allocate new storage and this fails.  In this
case <code>reallocf</code> will free the original object passed in whereas
<code>realloc</code> will not.

   <p>The <code>memalign</code> function returns a block of size <var>nbytes</var> aligned
to a <var>align</var> boundary.  The <var>align</var> argument must be a power of
two.

   <p>The <code>malloc_usable_size</code> function takes a pointer to a block
allocated by <code>malloc</code>.  It returns the amount of space that is
available in the block.  This may or may not be more than the size
requested from <code>malloc</code>, due to alignment or minimum size
constraints.

   <p>The alternate functions <code>_malloc_r</code>, <code>_realloc_r</code>, <code>_reallocf_r</code>,
<code>_free_r</code>, <code>_memalign_r</code>, and <code>_malloc_usable_size_r</code> are reentrant
versions.  The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p>If you have multiple threads of execution which may call any of these
routines, or if any of these routines may be called reentrantly, then
you must provide implementations of the <code>__malloc_lock</code> and
<code>__malloc_unlock</code> functions for your system.  See the documentation
for those functions.

   <p>These functions operate by calling the function <code>_sbrk_r</code> or
<code>sbrk</code>, which allocates space.  You may need to provide one of these
functions for your system.  <code>_sbrk_r</code> is called with a positive
value to allocate more space, and with a negative value to release
previously allocated space if it is no longer required.
See <a href="#Stubs">Stubs</a>.

   <p><br>
<strong>Returns</strong><br>
<code>malloc</code> returns a pointer to the newly allocated space, if
successful; otherwise it returns <code>NULL</code>.  If your application needs
to generate empty objects, you may use <code>malloc(0)</code> for this purpose.

   <p><code>realloc</code> returns a pointer to the new block of memory, or <code>NULL</code>
if a new block could not be allocated.  <code>NULL</code> is also the result
when you use `<code>realloc(</code><var>aptr</var><code>,0)</code>' (which has the same effect as
`<code>free(</code><var>aptr</var><code>)</code>').  You should always check the result of
<code>realloc</code>; successful reallocation is not guaranteed even when
you request a smaller object.

   <p><code>free</code> does not return a result.

   <p><code>memalign</code> returns a pointer to the newly allocated space.

   <p><code>malloc_usable_size</code> returns the usable size.

   <p><br>
<strong>Portability</strong><br>
<code>malloc</code>, <code>realloc</code>, and <code>free</code> are specified by the ANSI C
standard, but other conforming implementations of <code>malloc</code> may
behave differently when <var>nbytes</var> is zero.

   <p><code>memalign</code> is part of SVR4.

   <p><code>malloc_usable_size</code> is not portable.

   <p>Supporting OS subroutines required: <code>sbrk</code>.
<br>

<div class="node">
<a name="mallinfo"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005f_005fmalloc_005flock">__malloc_lock</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#malloc">malloc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.24 <code>mallinfo</code>, <code>malloc_stats</code>, <code>mallopt</code>&mdash;malloc support</h3>

<p><a name="index-mallinfo-49"></a><a name="index-malloc_005fstats-50"></a><a name="index-mallopt-51"></a><a name="index-g_t_005fmallinfo_005fr-52"></a><a name="index-g_t_005fmalloc_005fstats_005fr-53"></a><a name="index-g_t_005fmallopt_005fr-54"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;malloc.h&gt;
     struct mallinfo mallinfo(void);
     void malloc_stats(void);
     int mallopt(int <var>parameter</var>, <var>value</var>);

     struct mallinfo _mallinfo_r(void *<var>reent</var>);
     void _malloc_stats_r(void *<var>reent</var>);
     int _mallopt_r(void *<var>reent</var>, int <var>parameter</var>, <var>value</var>);

</pre>
   <p><strong>Description</strong><br>
<code>mallinfo</code> returns a structure describing the current state of
memory allocation.  The structure is defined in malloc.h.  The
following fields are defined: <code>arena</code> is the total amount of space
in the heap; <code>ordblks</code> is the number of chunks which are not in use;
<code>uordblks</code> is the total amount of space allocated by <code>malloc</code>;
<code>fordblks</code> is the total amount of space not in use; <code>keepcost</code> is
the size of the top most memory block.

   <p><code>malloc_stats</code> print some statistics about memory allocation on
standard error.

   <p><code>mallopt</code> takes a parameter and a value.  The parameters are defined
in malloc.h, and may be one of the following: <code>M_TRIM_THRESHOLD</code>
sets the maximum amount of unused space in the top most block before
releasing it back to the system in <code>free</code> (the space is released by
calling <code>_sbrk_r</code> with a negative argument); <code>M_TOP_PAD</code> is the
amount of padding to allocate whenever <code>_sbrk_r</code> is called to
allocate more space.

   <p>The alternate functions <code>_mallinfo_r</code>, <code>_malloc_stats_r</code>, and
<code>_mallopt_r</code> are reentrant versions.  The extra argument <var>reent</var>
is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>mallinfo</code> returns a mallinfo structure.  The structure is defined
in malloc.h.

   <p><code>malloc_stats</code> does not return a result.

   <p><code>mallopt</code> returns zero if the parameter could not be set, or
non-zero if it could be set.

   <p><br>
<strong>Portability</strong><br>
<code>mallinfo</code> and <code>mallopt</code> are provided by SVR4, but <code>mallopt</code>
takes different parameters on different systems.  <code>malloc_stats</code> is
not portable.

   <p><br>

<div class="node">
<a name="__malloc_lock"></a>
<a name="g_t_005f_005fmalloc_005flock"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mbsrtowcs">mbsrtowcs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mallinfo">mallinfo</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.25 <code>__malloc_lock</code>, <code>__malloc_unlock</code>&mdash;lock malloc pool</h3>

<p><a name="index-g_t_005f_005fmalloc_005flock-55"></a><a name="index-g_t_005f_005fmalloc_005funlock-56"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;malloc.h&gt;
     void __malloc_lock (struct _reent *<var>reent</var>);
     void __malloc_unlock (struct _reent *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>malloc</code> family of routines call these functions when they need to lock
the memory pool.  The version of these routines supplied in the library use
the lock API defined in sys/lock.h.  If multiple threads of execution can
call <code>malloc</code>, or if <code>malloc</code> can be called reentrantly, then you need to
define your own versions of these functions in order to safely lock the
memory pool during a call.  If you do not, the memory pool may become
corrupted.

   <p>A call to <code>malloc</code> may call <code>__malloc_lock</code> recursively; that is,
the sequence of calls may go <code>__malloc_lock</code>, <code>__malloc_lock</code>,
<code>__malloc_unlock</code>, <code>__malloc_unlock</code>.  Any implementation of these
routines must be careful to avoid causing a thread to wait for a lock
that it already holds.

   <p><br>

<div class="node">
<a name="mblen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mbtowc">mbtowc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mbstowcs">mbstowcs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.26 <code>mblen</code>&mdash;minimal multibyte length function</h3>

<p><a name="index-mblen-57"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int mblen(const char *<var>s</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
When _MB_CAPABLE is not defined, this is a minimal ANSI-conforming
implementation of <code>mblen</code>.  In this case, the
only &ldquo;multi-byte character sequences&rdquo; recognized are single bytes,
and thus <code>1</code> is returned unless <var>s</var> is the null pointer or
has a length of 0 or is the empty string.

   <p>When _MB_CAPABLE is defined, this routine calls <code>_mbtowc_r</code> to perform
the conversion, passing a state variable to allow state dependent
decoding.  The result is based on the locale setting which may
be restricted to a defined set of locales.

   <p><br>
<strong>Returns</strong><br>
This implementation of <code>mblen</code> returns <code>0</code> if
<var>s</var> is <code>NULL</code> or the empty string; it returns <code>1</code> if not _MB_CAPABLE or
the character is a single-byte character; it returns <code>-1</code>
if the multi-byte character is invalid; otherwise it returns
the number of bytes in the multibyte character.

   <p><br>
<strong>Portability</strong><br>
<code>mblen</code> is required in the ANSI C standard.  However, the precise
effects vary with the locale.

   <p><code>mblen</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="mbsrtowcs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mbstowcs">mbstowcs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005f_005fmalloc_005flock">__malloc_lock</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.27 <code>mbsrtowcs</code>, <code>mbsnrtowcs</code>&mdash;convert a character string to a wide-character string</h3>

<p><a name="index-mbsrtowcs-58"></a><a name="index-g_t_005fmbsrtowcs_005fr-59"></a><a name="index-mbsnrtowcs-60"></a><a name="index-g_t_005fmbsnrtowcs_005fr-61"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t mbsrtowcs(wchar_t *<var>dst</var>, const char **<var>src</var>, size_t <var>len</var>,
         mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t _mbsrtowcs_r(struct _reent *<var>ptr</var>, wchar_t *<var>dst</var>,
         const char **<var>src</var>, size_t <var>len</var>,
         mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t mbsnrtowcs(wchar_t *<var>dst</var>, const char **<var>src</var>,
         size_t <var>nms</var>, size_t <var>len</var>, mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t _mbsnrtowcs_r(struct _reent *<var>ptr</var>, wchar_t *<var>dst</var>,
         const char **<var>src</var>, size_t <var>nms</var>,
         size_t <var>len</var>, mbstate_t *<var>ps</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>mbsrtowcs</code> function converts a sequence of multibyte characters
pointed to indirectly by <var>src</var> into a sequence of corresponding wide
characters and stores at most <var>len</var> of them in the wchar_t array pointed
to by <var>dst</var>, until it encounters a terminating null character ('\0').

   <p>If <var>dst</var> is NULL, no characters are stored.

   <p>If <var>dst</var> is not NULL, the pointer pointed to by <var>src</var> is updated to point
to the character after the one that conversion stopped at.  If conversion
stops because a null character is encountered, *<var>src</var> is set to NULL.

   <p>The mbstate_t argument, <var>ps</var>, is used to keep track of the shift state.  If
it is NULL, <code>mbsrtowcs</code> uses an internal, static mbstate_t object, which
is initialized to the initial conversion state at program startup.

   <p>The <code>mbsnrtowcs</code> function behaves identically to <code>mbsrtowcs</code>, except that
conversion stops after reading at most <var>nms</var> bytes from the buffer pointed
to by <var>src</var>.

   <p><br>
<strong>Returns</strong><br>
The <code>mbsrtowcs</code> and <code>mbsnrtowcs</code> functions return the number of wide
characters stored in the array pointed to by <var>dst</var> if successful, otherwise
it returns (size_t)-1.

   <p><br>
<strong>Portability</strong><br>
<code>mbsrtowcs</code> is defined by the C99 standard.
<code>mbsnrtowcs</code> is defined by the POSIX.1-2008 standard.

   <p><br>

<div class="node">
<a name="mbstowcs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mblen">mblen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mbsrtowcs">mbsrtowcs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.28 <code>mbstowcs</code>&mdash;minimal multibyte string to wide char converter</h3>

<p><a name="index-mbstowcs-62"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int mbstowcs(wchar_t *<var>pwc</var>, const char *<var>s</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
When _MB_CAPABLE is not defined, this is a minimal ANSI-conforming
implementation of <code>mbstowcs</code>.  In this case, the
only &ldquo;multi-byte character sequences&rdquo; recognized are single bytes,
and they are &ldquo;converted&rdquo; to wide-char versions simply by byte
extension.

   <p>When _MB_CAPABLE is defined, this routine calls <code>_mbstowcs_r</code> to perform
the conversion, passing a state variable to allow state dependent
decoding.  The result is based on the locale setting which may
be restricted to a defined set of locales.

   <p><br>
<strong>Returns</strong><br>
This implementation of <code>mbstowcs</code> returns <code>0</code> if
<var>s</var> is <code>NULL</code> or is the empty string;
it returns <code>-1</code> if _MB_CAPABLE and one of the
multi-byte characters is invalid or incomplete;
otherwise it returns the minimum of: <code>n</code> or the
number of multi-byte characters in <code>s</code> plus 1 (to
compensate for the nul character).
If the return value is -1, the state of the <code>pwc</code> string is
indeterminate.  If the input has a length of 0, the output
string will be modified to contain a wchar_t nul terminator.

   <p><br>
<strong>Portability</strong><br>
<code>mbstowcs</code> is required in the ANSI C standard.  However, the precise
effects vary with the locale.

   <p><code>mbstowcs</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="mbtowc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#on_005fexit">on_exit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mblen">mblen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.29 <code>mbtowc</code>&mdash;minimal multibyte to wide char converter</h3>

<p><a name="index-mbtowc-63"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int mbtowc(wchar_t *<var>pwc</var>, const char *<var>s</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
When _MB_CAPABLE is not defined, this is a minimal ANSI-conforming
implementation of <code>mbtowc</code>.  In this case,
only &ldquo;multi-byte character sequences&rdquo; recognized are single bytes,
and they are &ldquo;converted&rdquo; to themselves.
Each call to <code>mbtowc</code> copies one character from <code>*</code><var>s</var> to
<code>*</code><var>pwc</var>, unless <var>s</var> is a null pointer.  The argument n
is ignored.

   <p>When _MB_CAPABLE is defined, this routine calls <code>_mbtowc_r</code> to perform
the conversion, passing a state variable to allow state dependent
decoding.  The result is based on the locale setting which may
be restricted to a defined set of locales.

   <p><br>
<strong>Returns</strong><br>
This implementation of <code>mbtowc</code> returns <code>0</code> if
<var>s</var> is <code>NULL</code> or is the empty string;
it returns <code>1</code> if not _MB_CAPABLE or
the character is a single-byte character; it returns <code>-1</code>
if n is <code>0</code> or the multi-byte character is invalid;
otherwise it returns the number of bytes in the multibyte character.
If the return value is -1, no changes are made to the <code>pwc</code>
output string.  If the input is the empty string, a wchar_t nul
is placed in the output string and 0 is returned.  If the input
has a length of 0, no changes are made to the <code>pwc</code> output string.

   <p><br>
<strong>Portability</strong><br>
<code>mbtowc</code> is required in the ANSI C standard.  However, the precise
effects vary with the locale.

   <p><code>mbtowc</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="on_exit"></a>
<a name="on_005fexit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#qsort">qsort</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mbtowc">mbtowc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.30 <code>on_exit</code>&mdash;request execution of function with argument at program exit</h3>

<p><a name="index-on_005fexit-64"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int on_exit (void (*<var>function</var>)(int, void *), void *<var>arg</var>);

</pre>
   <p><strong>Description</strong><br>
You can use <code>on_exit</code> to enroll functions in a list of functions that
will be called when your program terminates normally.  The argument is
a pointer to a user-defined function which takes two arguments.  The
first is the status code passed to exit and the second argument is of type
pointer to void.  The function must not return a result.  The value
of <var>arg</var> is registered and passed as the argument to <var>function</var>.

   <p>The functions are kept in a LIFO stack; that is, the last function
enrolled by <code>atexit</code> or <code>on_exit</code> will be the first to execute when
your program exits.  You can intermix functions using <code>atexit</code> and
<code>on_exit</code>.

   <p>There is no built-in limit to the number of functions you can enroll
in this list; however, after every group of 32 functions is enrolled,
<code>atexit</code>/<code>on_exit</code> will call <code>malloc</code> to get space for the next part
of the list.   The initial list of 32 functions is statically allocated, so
you can always count on at least that many slots available.

   <p><br>
<strong>Returns</strong><br>
<code>on_exit</code> returns <code>0</code> if it succeeds in enrolling your function,
<code>-1</code> if it fails (possible only if no space was available for
<code>malloc</code> to extend the list of functions).

   <p><br>
<strong>Portability</strong><br>
<code>on_exit</code> is a non-standard glibc extension

   <p>Supporting OS subroutines required: None

   <p><br>

<div class="node">
<a name="qsort"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#rand">rand</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#on_005fexit">on_exit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.31 <code>qsort</code>&mdash;sort an array</h3>

<p><a name="index-qsort-65"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     void qsort(void *<var>base</var>, size_t <var>nmemb</var>, size_t <var>size</var>,
         int (*<var>compar</var>)(const void *, const void *) );

</pre>
   <p><strong>Description</strong><br>
<code>qsort</code> sorts an array (beginning at <var>base</var>) of <var>nmemb</var> objects.
<var>size</var> describes the size of each element of the array.

   <p>You must supply a pointer to a comparison function, using the argument
shown as <var>compar</var>.  (This permits sorting objects of unknown
properties.)  Define the comparison function to accept two arguments,
each a pointer to an element of the array starting at <var>base</var>.  The
result of <code>(*</code><var>compar</var><code>)</code> must be negative if the first argument is
less than the second, zero if the two arguments match, and positive if
the first argument is greater than the second (where &ldquo;less than&rdquo; and
&ldquo;greater than&rdquo; refer to whatever arbitrary ordering is appropriate).

   <p>The array is sorted in place; that is, when <code>qsort</code> returns, the
array elements beginning at <var>base</var> have been reordered.

   <p><br>
<strong>Returns</strong><br>
<code>qsort</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
<code>qsort</code> is required by ANSI (without specifying the sorting algorithm).

   <p><br>

<div class="node">
<a name="rand"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#rand48">rand48</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#qsort">qsort</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.32 <code>rand</code>, <code>srand</code>&mdash;pseudo-random numbers</h3>

<p><a name="index-rand-66"></a><a name="index-srand-67"></a><a name="index-rand_005fr-68"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int rand(void);
     void srand(unsigned int <var>seed</var>);
     int rand_r(unsigned int *<var>seed</var>);

</pre>
   <p><strong>Description</strong><br>
<code>rand</code> returns a different integer each time it is called; each
integer is chosen by an algorithm designed to be unpredictable, so
that you can use <code>rand</code> when you require a random number.
The algorithm depends on a static variable called the &ldquo;random seed&rdquo;;
starting with a given value of the random seed always produces the
same sequence of numbers in successive calls to <code>rand</code>.

   <p>You can set the random seed using <code>srand</code>; it does nothing beyond
storing its argument in the static variable used by <code>rand</code>.  You can
exploit this to make the pseudo-random sequence less predictable, if
you wish, by using some other unpredictable value (often the least
significant parts of a time-varying value) as the random seed before
beginning a sequence of calls to <code>rand</code>; or, if you wish to ensure
(for example, while debugging) that successive runs of your program
use the same &ldquo;random&rdquo; numbers, you can use <code>srand</code> to set the same
random seed at the outset.

   <p><br>
<strong>Returns</strong><br>
<code>rand</code> returns the next pseudo-random integer in sequence; it is a
number between <code>0</code> and <code>RAND_MAX</code> (inclusive).

   <p><code>srand</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
<code>rand</code> is required by ANSI, but the algorithm for pseudo-random
number generation is not specified; therefore, even if you use
the same random seed, you cannot expect the same sequence of results
on two different systems.

   <p><code>rand</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="rand48"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtod">strtod</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#rand">rand</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.33 <code>rand48</code>, <code>drand48</code>, <code>erand48</code>, <code>lrand48</code>, <code>nrand48</code>, <code>mrand48</code>, <code>jrand48</code>, <code>srand48</code>, <code>seed48</code>, <code>lcong48</code>&mdash;pseudo-random number generators and initialization routines</h3>

<p><a name="index-rand48-69"></a><a name="index-drand48-70"></a><a name="index-erand48-71"></a><a name="index-lrand48-72"></a><a name="index-nrand48-73"></a><a name="index-mrand48-74"></a><a name="index-jrand48-75"></a><a name="index-srand48-76"></a><a name="index-seed48-77"></a><a name="index-lcong48-78"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     double drand48(void);
     double erand48(unsigned short <var>xseed</var>[3]);
     long lrand48(void);
     long nrand48(unsigned short <var>xseed</var>[3]);
     long mrand48(void);
     long jrand48(unsigned short <var>xseed</var>[3]);
     void srand48(long <var>seed</var>);
     unsigned short *seed48(unsigned short <var>xseed</var>[3]);
     void lcong48(unsigned short <var>p</var>[7]);

</pre>
   <p><strong>Description</strong><br>
The <code>rand48</code> family of functions generates pseudo-random numbers
using a linear congruential algorithm working on integers 48 bits in size.
The particular formula employed is
r(n+1) = (a * r(n) + c) mod m
where the default values are
for the multiplicand a = 0xfdeece66d = 25214903917 and
the addend c = 0xb = 11. The modulo is always fixed at m = 2 ** 48.
r(n) is called the seed of the random number generator.

   <p>For all the six generator routines described next, the first
computational step is to perform a single iteration of the algorithm.

   <p><code>drand48</code> and <code>erand48</code>
return values of type double. The full 48 bits of r(n+1) are
loaded into the mantissa of the returned value, with the exponent set
such that the values produced lie in the interval [0.0, 1.0].

   <p><code>lrand48</code> and <code>nrand48</code>
return values of type long in the range
[0, 2**31-1]. The high-order (31) bits of
r(n+1) are loaded into the lower bits of the returned value, with
the topmost (sign) bit set to zero.

   <p><code>mrand48</code> and <code>jrand48</code>
return values of type long in the range
[-2**31, 2**31-1]. The high-order (32) bits of
r(n+1) are loaded into the returned value.

   <p><code>drand48</code>, <code>lrand48</code>, and <code>mrand48</code>
use an internal buffer to store r(n). For these functions
the initial value of r(0) = 0x1234abcd330e = 20017429951246.

   <p>On the other hand, <code>erand48</code>, <code>nrand48</code>, and <code>jrand48</code>
use a user-supplied buffer to store the seed r(n),
which consists of an array of 3 shorts, where the zeroth member
holds the least significant bits.

   <p>All functions share the same multiplicand and addend.

   <p><code>srand48</code> is used to initialize the internal buffer r(n) of
<code>drand48</code>, <code>lrand48</code>, and <code>mrand48</code>
such that the 32 bits of the seed value are copied into the upper 32 bits
of r(n), with the lower 16 bits of r(n) arbitrarily being set to 0x330e.
Additionally, the constant multiplicand and addend of the algorithm are
reset to the default values given above.

   <p><code>seed48</code> also initializes the internal buffer r(n) of
<code>drand48</code>, <code>lrand48</code>, and <code>mrand48</code>,
but here all 48 bits of the seed can be specified in an array of 3 shorts,
where the zeroth member specifies the lowest bits. Again,
the constant multiplicand and addend of the algorithm are
reset to the default values given above.
<code>seed48</code> returns a pointer to an array of 3 shorts which contains
the old seed.
This array is statically allocated, thus its contents are lost after
each new call to <code>seed48</code>.

   <p>Finally, <code>lcong48</code> allows full control over the multiplicand and
addend used in <code>drand48</code>, <code>erand48</code>, <code>lrand48</code>, <code>nrand48</code>,
<code>mrand48</code>, and <code>jrand48</code>,
and the seed used in <code>drand48</code>, <code>lrand48</code>, and <code>mrand48</code>.
An array of 7 shorts is passed as parameter; the first three shorts are
used to initialize the seed; the second three are used to initialize the
multiplicand; and the last short is used to initialize the addend.
It is thus not possible to use values greater than 0xffff as the addend.

   <p>Note that all three methods of seeding the random number generator
always also set the multiplicand and addend for any of the six
generator calls.

   <p>For a more powerful random number generator, see <code>random</code>.

   <p><br>
<strong>Portability</strong><br>
SUS requires these functions.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="strtod"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtol">strtol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#rand48">rand48</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.34 <code>strtod</code>, <code>strtof</code>&mdash;string to double or float</h3>

<p><a name="index-strtod-79"></a><a name="index-g_t_005fstrtod_005fr-80"></a><a name="index-strtof-81"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     double strtod(const char *<var>str</var>, char **<var>tail</var>);
     float strtof(const char *<var>str</var>, char **<var>tail</var>);

     double _strtod_r(void *<var>reent</var>,
         const char *<var>str</var>, char **<var>tail</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>strtod</code> parses the character string <var>str</var>,
producing a substring which can be converted to a double
value.  The substring converted is the longest initial
subsequence of <var>str</var>, beginning with the first
non-whitespace character, that has one of these formats:
<pre class="smallexample">     [+|-]<var>digits</var>[.[<var>digits</var>]][(e|E)[+|-]<var>digits</var>]
     [+|-].<var>digits</var>[(e|E)[+|-]<var>digits</var>]
     [+|-](i|I)(n|N)(f|F)[(i|I)(n|N)(i|I)(t|T)(y|Y)]
     [+|-](n|N)(a|A)(n|N)[&lt;(&gt;[<var>hexdigits</var>]&lt;)&gt;]
     [+|-]0(x|X)<var>hexdigits</var>[.[<var>hexdigits</var>]][(p|P)[+|-]<var>digits</var>]
     [+|-]0(x|X).<var>hexdigits</var>[(p|P)[+|-]<var>digits</var>]
</pre>
   <p>The substring contains no characters if <var>str</var> is empty, consists
entirely of whitespace, or if the first non-whitespace
character is something other than <code>+</code>, <code>-</code>, <code>.</code>, or a
digit, and cannot be parsed as infinity or NaN. If the platform
does not support NaN, then NaN is treated as an empty substring.
If the substring is empty, no conversion is done, and
the value of <var>str</var> is stored in <code>*</code><var>tail</var>.  Otherwise,
the substring is converted, and a pointer to the final string
(which will contain at least the terminating null character of
<var>str</var>) is stored in <code>*</code><var>tail</var>.  If you want no
assignment to <code>*</code><var>tail</var>, pass a null pointer as <var>tail</var>.
<code>strtof</code> is identical to <code>strtod</code> except for its return type.

   <p>This implementation returns the nearest machine number to the
input decimal string.  Ties are broken by using the IEEE
round-even rule.  However, <code>strtof</code> is currently subject to
double rounding errors.

   <p>The alternate function <code>_strtod_r</code> is a reentrant version.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>strtod</code> returns the converted substring value, if any.  If
no conversion could be performed, 0 is returned.  If the
correct value is out of the range of representable values,
plus or minus <code>HUGE_VAL</code> is returned, and <code>ERANGE</code> is
stored in errno. If the correct value would cause underflow, 0
is returned and <code>ERANGE</code> is stored in errno.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="strtol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtoll">strtoll</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtod">strtod</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.35 <code>strtol</code>&mdash;string to long</h3>

<p><a name="index-strtol-82"></a><a name="index-g_t_005fstrtol_005fr-83"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long strtol(const char *<var>s</var>, char **<var>ptr</var>,int <var>base</var>);

     long _strtol_r(void *<var>reent</var>,
         const char *<var>s</var>, char **<var>ptr</var>,int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>strtol</code> converts the string <code>*</code><var>s</var> to
a <code>long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of characters resembling an integer in the radix specified by <var>base</var>;
and a trailing portion consisting of zero or more unparseable characters,
and always including the terminating null character. Then, it attempts
to convert the subject string into a <code>long</code> and returns the
result.

   <p>If the value of <var>base</var> is 0, the subject string is expected to look
like a normal C integer constant: an optional sign, a possible `<code>0x</code>'
indicating a hexadecimal base, and a number. If <var>base</var> is between
2 and 36, the expected form of the subject is a sequence of letters
and digits representing an integer in the radix specified by <var>base</var>,
with an optional plus or minus sign. The letters <code>a</code>&ndash;<code>z</code> (or,
equivalently, <code>A</code>&ndash;<code>Z</code>) are used to signify values from 10 to 35;
only letters whose ascribed values are less than <var>base</var> are
permitted. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible letter or digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>strtol</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading 0 and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. If the subject string begins with
a minus sign, the value is negated. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (or not in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_strtol_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>strtol</code> returns the converted value, if any. If no conversion was
made, 0 is returned.

   <p><code>strtol</code> returns <code>LONG_MAX</code> or <code>LONG_MIN</code> if the magnitude of
the converted value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>strtol</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="strtoll"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtoul">strtoul</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtol">strtol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.36 <code>strtoll</code>&mdash;string to long long</h3>

<p><a name="index-strtoll-84"></a><a name="index-g_t_005fstrtoll_005fr-85"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     long long strtoll(const char *<var>s</var>, char **<var>ptr</var>,int <var>base</var>);

     long long _strtoll_r(void *<var>reent</var>,
         const char *<var>s</var>, char **<var>ptr</var>,int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>strtoll</code> converts the string <code>*</code><var>s</var> to
a <code>long long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of characters resembling an integer in the radix specified by <var>base</var>;
and a trailing portion consisting of zero or more unparseable characters,
and always including the terminating null character. Then, it attempts
to convert the subject string into a <code>long long</code> and returns the
result.

   <p>If the value of <var>base</var> is 0, the subject string is expected to look
like a normal C integer constant: an optional sign, a possible `<code>0x</code>'
indicating a hexadecimal base, and a number. If <var>base</var> is between
2 and 36, the expected form of the subject is a sequence of letters
and digits representing an integer in the radix specified by <var>base</var>,
with an optional plus or minus sign. The letters <code>a</code>&ndash;<code>z</code> (or,
equivalently, <code>A</code>&ndash;<code>Z</code>) are used to signify values from 10 to 35;
only letters whose ascribed values are less than <var>base</var> are
permitted. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible letter or digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>strtoll</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading 0 and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. If the subject string begins with
a minus sign, the value is negated. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (or not in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_strtoll_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>strtoll</code> returns the converted value, if any. If no conversion was
made, 0 is returned.

   <p><code>strtoll</code> returns <code>LONG_LONG_MAX</code> or <code>LONG_LONG_MIN</code> if the magnitude of
the converted value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>strtoll</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="strtoul"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtoull">strtoull</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtoll">strtoll</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.37 <code>strtoul</code>&mdash;string to unsigned long</h3>

<p><a name="index-strtoul-86"></a><a name="index-g_t_005fstrtoul_005fr-87"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     unsigned long strtoul(const char *<var>s</var>, char **<var>ptr</var>,
         int <var>base</var>);

     unsigned long _strtoul_r(void *<var>reent</var>, const char *<var>s</var>,
         char **<var>ptr</var>, int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>strtoul</code> converts the string <code>*</code><var>s</var> to
an <code>unsigned long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of the digits meaningful in the radix specified by <var>base</var>
(for example, <code>0</code> through <code>7</code> if the value of <var>base</var> is 8);
and a trailing portion consisting of one or more unparseable characters,
which always includes the terminating null character. Then, it attempts
to convert the subject string into an unsigned long integer, and returns the
result.

   <p>If the value of <var>base</var> is zero, the subject string is expected to look
like a normal C integer constant (save that no optional sign is permitted):
a possible <code>0x</code> indicating hexadecimal radix, and a number.
If <var>base</var> is between 2 and 36, the expected form of the subject is a
sequence of digits (which may include letters, depending on the
base) representing an integer in the radix specified by <var>base</var>.
The letters <code>a</code>&ndash;<code>z</code> (or <code>A</code>&ndash;<code>Z</code>) are used as digits valued from
10 to 35. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>strtoul</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading <code>0</code> and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (that is, if <code>*</code><var>s</var> does not start
with a substring in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_strtoul_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>strtoul</code> returns the converted value, if any. If no conversion was
made, <code>0</code> is returned.

   <p><code>strtoul</code> returns <code>ULONG_MAX</code> if the magnitude of the converted
value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>strtoul</code> is ANSI.

   <p><code>strtoul</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strtoull"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsrtombs">wcsrtombs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtoul">strtoul</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.38 <code>strtoull</code>&mdash;string to unsigned long long</h3>

<p><a name="index-strtoull-88"></a><a name="index-g_t_005fstrtoull_005fr-89"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     unsigned long long strtoull(const char *<var>s</var>, char **<var>ptr</var>,
         int <var>base</var>);

     unsigned long long _strtoull_r(void *<var>reent</var>, const char *<var>s</var>,
         char **<var>ptr</var>, int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>strtoull</code> converts the string <code>*</code><var>s</var> to
an <code>unsigned long long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of the digits meaningful in the radix specified by <var>base</var>
(for example, <code>0</code> through <code>7</code> if the value of <var>base</var> is 8);
and a trailing portion consisting of one or more unparseable characters,
which always includes the terminating null character. Then, it attempts
to convert the subject string into an unsigned long long integer, and returns the
result.

   <p>If the value of <var>base</var> is zero, the subject string is expected to look
like a normal C integer constant (save that no optional sign is permitted):
a possible <code>0x</code> indicating hexadecimal radix, and a number.
If <var>base</var> is between 2 and 36, the expected form of the subject is a
sequence of digits (which may include letters, depending on the
base) representing an integer in the radix specified by <var>base</var>.
The letters <code>a</code>&ndash;<code>z</code> (or <code>A</code>&ndash;<code>Z</code>) are used as digits valued from
10 to 35. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>strtoull</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading <code>0</code> and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (that is, if <code>*</code><var>s</var> does not start
with a substring in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_strtoull_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>strtoull</code> returns the converted value, if any. If no conversion was
made, <code>0</code> is returned.

   <p><code>strtoull</code> returns <code>ULONG_LONG_MAX</code> if the magnitude of the converted
value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>strtoull</code> is ANSI.

   <p><code>strtoull</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wcsrtombs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstod">wcstod</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtoull">strtoull</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.39 <code>wcsrtombs</code>, <code>wcsnrtombs</code>&mdash;convert a wide-character string to a character string</h3>

<p><a name="index-wcsrtombs-90"></a><a name="index-g_t_005fwcsrtombs_005fr-91"></a><a name="index-wcsnrtombs-92"></a><a name="index-g_t_005fwcsnrtombs_005fr-93"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcsrtombs(char *<var>dst</var>, const wchar_t **<var>src</var>, size_t <var>len</var>,
         mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t _wcsrtombs_r(struct _reent *<var>ptr</var>, char *<var>dst</var>,
         const wchar_t **<var>src</var>, size_t <var>len</var>,
         mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t wcsnrtombs(char *<var>dst</var>, const wchar_t **<var>src</var>,
         size_t <var>nwc</var>, size_t <var>len</var>, mbstate_t *<var>ps</var>);

     #include &lt;wchar.h&gt;
     size_t _wcsnrtombs_r(struct _reent *<var>ptr</var>, char *<var>dst</var>,
         const wchar_t **<var>src</var>, size_t <var>nwc</var>,
         size_t <var>len</var>, mbstate_t *<var>ps</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsrtombs</code> function converts a string of wide characters indirectly
pointed to by <var>src</var> to a corresponding multibyte character string stored in
the array pointed to by <var>dst</var>&gt;.  No more than <var>len</var> bytes are written to
<var>dst</var>&gt;.

   <p>If <var>dst</var>&gt; is NULL, no characters are stored.

   <p>If <var>dst</var>&gt; is not NULL, the pointer pointed to by <var>src</var> is updated to point
to the character after the one that conversion stopped at.  If conversion
stops because a null character is encountered, *<var>src</var> is set to NULL.

   <p>The mbstate_t argument, <var>ps</var>, is used to keep track of the shift state.  If
it is NULL, <code>wcsrtombs</code> uses an internal, static mbstate_t object, which
is initialized to the initial conversion state at program startup.

   <p>The <code>wcsnrtombs</code> function behaves identically to <code>wcsrtombs</code>, except that
conversion stops after reading at most <var>nwc</var> characters from the buffer
pointed to by <var>src</var>.

   <p><br>
<strong>Returns</strong><br>
The <code>wcsrtombs</code> and <code>wcsnrtombs</code> functions return the number of bytes
stored in the array pointed to by <var>dst</var> (not including any terminating
null), if successful, otherwise it returns (size_t)-1.

   <p><br>
<strong>Portability</strong><br>
<code>wcsrtombs</code> is defined by C99 standard.
<code>wcsnrtombs</code> is defined by the POSIX.1-2008 standard.

   <p><br>

<div class="node">
<a name="wcstod"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstol">wcstol</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsrtombs">wcsrtombs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.40 <code>wcstod</code>, <code>wcstof</code>&mdash;wide char string to double or float</h3>

<p><a name="index-wcstod-94"></a><a name="index-g_t_005fwcstod_005fr-95"></a><a name="index-wcstof-96"></a><a name="index-g_t_005fwcstof_005fr-97"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     double wcstod(const wchar_t *<var>str</var>, wchar_t **<var>tail</var>);
     float wcstof(const wchar_t *<var>str</var>, wchar_t **<var>tail</var>);

     double _wcstod_r(void *<var>reent</var>,
         const wchar_t *<var>str</var>, wchar_t **<var>tail</var>);
     float _wcstof_r(void *<var>reent</var>,
         const wchar_t *<var>str</var>, wchar_t **<var>tail</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>wcstod</code> parses the wide character string <var>str</var>,
producing a substring which can be converted to a double
value.  The substring converted is the longest initial
subsequence of <var>str</var>, beginning with the first
non-whitespace character, that has one of these formats:
<pre class="smallexample">     [+|-]<var>digits</var>[.[<var>digits</var>]][(e|E)[+|-]<var>digits</var>]
     [+|-].<var>digits</var>[(e|E)[+|-]<var>digits</var>]
     [+|-](i|I)(n|N)(f|F)[(i|I)(n|N)(i|I)(t|T)(y|Y)]
     [+|-](n|N)(a|A)(n|N)[&lt;(&gt;[<var>hexdigits</var>]&lt;)&gt;]
     [+|-]0(x|X)<var>hexdigits</var>[.[<var>hexdigits</var>]][(p|P)[+|-]<var>digits</var>]
     [+|-]0(x|X).<var>hexdigits</var>[(p|P)[+|-]<var>digits</var>]
</pre>
   <p>The substring contains no characters if <var>str</var> is empty, consists
entirely of whitespace, or if the first non-whitespace
character is something other than <code>+</code>, <code>-</code>, <code>.</code>, or a
digit, and cannot be parsed as infinity or NaN. If the platform
does not support NaN, then NaN is treated as an empty substring.
If the substring is empty, no conversion is done, and
the value of <var>str</var> is stored in <code>*</code><var>tail</var>.  Otherwise,
the substring is converted, and a pointer to the final string
(which will contain at least the terminating null character of
<var>str</var>) is stored in <code>*</code><var>tail</var>.  If you want no
assignment to <code>*</code><var>tail</var>, pass a null pointer as <var>tail</var>.
<code>wcstof</code> is identical to <code>wcstod</code> except for its return type.

   <p>This implementation returns the nearest machine number to the
input decimal string.  Ties are broken by using the IEEE
round-even rule.  However, <code>wcstof</code> is currently subject to
double rounding errors.

   <p>The alternate functions <code>_wcstod_r</code> and <code>_wcstof_r</code> are
reentrant versions of <code>wcstod</code> and <code>wcstof</code>, respectively.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
Return the converted substring value, if any.  If
no conversion could be performed, 0 is returned.  If the
correct value is out of the range of representable values,
plus or minus <code>HUGE_VAL</code> is returned, and <code>ERANGE</code> is
stored in errno. If the correct value would cause underflow, 0
is returned and <code>ERANGE</code> is stored in errno.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="wcstol"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstoll">wcstoll</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstod">wcstod</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.41 <code>wcstol</code>&mdash;wide string to long</h3>

<p><a name="index-wcstol-98"></a><a name="index-g_t_005fwcstol_005fr-99"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     long wcstol(const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,int <var>base</var>);

     long _wcstol_r(void *<var>reent</var>,
         const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>wcstol</code> converts the wide string <code>*</code><var>s</var> to
a <code>long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of characters resembling an integer in the radix specified by <var>base</var>;
and a trailing portion consisting of zero or more unparseable characters,
and always including the terminating null character. Then, it attempts
to convert the subject string into a <code>long</code> and returns the
result.

   <p>If the value of <var>base</var> is 0, the subject string is expected to look
like a normal C integer constant: an optional sign, a possible `<code>0x</code>'
indicating a hexadecimal base, and a number. If <var>base</var> is between
2 and 36, the expected form of the subject is a sequence of letters
and digits representing an integer in the radix specified by <var>base</var>,
with an optional plus or minus sign. The letters <code>a</code>&ndash;<code>z</code> (or,
equivalently, <code>A</code>&ndash;<code>Z</code>) are used to signify values from 10 to 35;
only letters whose ascribed values are less than <var>base</var> are
permitted. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible letter or digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>wcstol</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading 0 and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. If the subject string begins with
a minus sign, the value is negated. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (or not in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_wcstol_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>wcstol</code> returns the converted value, if any. If no conversion was
made, 0 is returned.

   <p><code>wcstol</code> returns <code>LONG_MAX</code> or <code>LONG_MIN</code> if the magnitude of
the converted value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>wcstol</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcstoll"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstoul">wcstoul</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstol">wcstol</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.42 <code>wcstoll</code>&mdash;wide string to long long</h3>

<p><a name="index-wcstoll-100"></a><a name="index-g_t_005fwcstoll_005fr-101"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     long long wcstoll(const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,int <var>base</var>);

     long long _wcstoll_r(void *<var>reent</var>,
         const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>wcstoll</code> converts the wide string <code>*</code><var>s</var> to
a <code>long long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of characters resembling an integer in the radix specified by <var>base</var>;
and a trailing portion consisting of zero or more unparseable characters,
and always including the terminating null character. Then, it attempts
to convert the subject string into a <code>long long</code> and returns the
result.

   <p>If the value of <var>base</var> is 0, the subject string is expected to look
like a normal C integer constant: an optional sign, a possible `<code>0x</code>'
indicating a hexadecimal base, and a number. If <var>base</var> is between
2 and 36, the expected form of the subject is a sequence of letters
and digits representing an integer in the radix specified by <var>base</var>,
with an optional plus or minus sign. The letters <code>a</code>&ndash;<code>z</code> (or,
equivalently, <code>A</code>&ndash;<code>Z</code>) are used to signify values from 10 to 35;
only letters whose ascribed values are less than <var>base</var> are
permitted. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible letter or digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>wcstoll</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading 0 and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. If the subject string begins with
a minus sign, the value is negated. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (or not in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_wcstoll_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>wcstoll</code> returns the converted value, if any. If no conversion was
made, 0 is returned.

   <p><code>wcstoll</code> returns <code>LONG_LONG_MAX</code> or <code>LONG_LONG_MIN</code> if the magnitude of
the converted value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>wcstoll</code> is ANSI.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcstoul"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstoull">wcstoull</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstoll">wcstoll</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.43 <code>wcstoul</code>&mdash;wide string to unsigned long</h3>

<p><a name="index-wcstoul-102"></a><a name="index-g_t_005fwcstoul_005fr-103"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     unsigned long wcstoul(const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,
         int <var>base</var>);

     unsigned long _wcstoul_r(void *<var>reent</var>, const wchar_t *<var>s</var>,
         wchar_t **<var>ptr</var>, int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>wcstoul</code> converts the wide string <code>*</code><var>s</var> to
an <code>unsigned long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of the digits meaningful in the radix specified by <var>base</var>
(for example, <code>0</code> through <code>7</code> if the value of <var>base</var> is 8);
and a trailing portion consisting of one or more unparseable characters,
which always includes the terminating null character. Then, it attempts
to convert the subject string into an unsigned long integer, and returns the
result.

   <p>If the value of <var>base</var> is zero, the subject string is expected to look
like a normal C integer constant (save that no optional sign is permitted):
a possible <code>0x</code> indicating hexadecimal radix, and a number.
If <var>base</var> is between 2 and 36, the expected form of the subject is a
sequence of digits (which may include letters, depending on the
base) representing an integer in the radix specified by <var>base</var>.
The letters <code>a</code>&ndash;<code>z</code> (or <code>A</code>&ndash;<code>Z</code>) are used as digits valued from
10 to 35. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>wcstoul</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading <code>0</code> and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (that is, if <code>*</code><var>s</var> does not start
with a substring in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_wcstoul_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>wcstoul</code> returns the converted value, if any. If no conversion was
made, <code>0</code> is returned.

   <p><code>wcstoul</code> returns <code>ULONG_MAX</code> if the magnitude of the converted
value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>wcstoul</code> is ANSI.

   <p><code>wcstoul</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wcstoull"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#system">system</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstoul">wcstoul</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.44 <code>wcstoull</code>&mdash;wide string to unsigned long long</h3>

<p><a name="index-wcstoull-104"></a><a name="index-g_t_005fwcstoull_005fr-105"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     unsigned long long wcstoull(const wchar_t *<var>s</var>, wchar_t **<var>ptr</var>,
         int <var>base</var>);

     unsigned long long _wcstoull_r(void *<var>reent</var>, const wchar_t *<var>s</var>,
         wchar_t **<var>ptr</var>, int <var>base</var>);

</pre>
   <p><strong>Description</strong><br>
The function <code>wcstoull</code> converts the wide string <code>*</code><var>s</var> to
an <code>unsigned long long</code>. First, it breaks down the string into three parts:
leading whitespace, which is ignored; a subject string consisting
of the digits meaningful in the radix specified by <var>base</var>
(for example, <code>0</code> through <code>7</code> if the value of <var>base</var> is 8);
and a trailing portion consisting of one or more unparseable characters,
which always includes the terminating null character. Then, it attempts
to convert the subject string into an unsigned long long integer, and returns the
result.

   <p>If the value of <var>base</var> is zero, the subject string is expected to look
like a normal C integer constant:  an optional sign (<code>+</code> or <code>-</code>),
a possible <code>0x</code> indicating hexadecimal radix or a possible &lt;0&gt; indicating
octal radix, and a number.
If <var>base</var> is between 2 and 36, the expected form of the subject is a
sequence of digits (which may include letters, depending on the
base) representing an integer in the radix specified by <var>base</var>.
The letters <code>a</code>&ndash;<code>z</code> (or <code>A</code>&ndash;<code>Z</code>) are used as digits valued from
10 to 35. If <var>base</var> is 16, a leading <code>0x</code> is permitted.

   <p>The subject sequence is the longest initial sequence of the input
string that has the expected form, starting with the first
non-whitespace character.  If the string is empty or consists entirely
of whitespace, or if the first non-whitespace character is not a
permissible digit, the subject string is empty.

   <p>If the subject string is acceptable, and the value of <var>base</var> is zero,
<code>wcstoull</code> attempts to determine the radix from the input string. A
string with a leading <code>0x</code> is treated as a hexadecimal value; a string with
a leading <code>0</code> and no <code>x</code> is treated as octal; all other strings are
treated as decimal. If <var>base</var> is between 2 and 36, it is used as the
conversion radix, as described above. Finally, a pointer to the first
character past the converted subject string is stored in <var>ptr</var>, if
<var>ptr</var> is not <code>NULL</code>.

   <p>If the subject string is empty (that is, if <code>*</code><var>s</var> does not start
with a substring in acceptable form), no conversion
is performed and the value of <var>s</var> is stored in <var>ptr</var> (if <var>ptr</var> is
not <code>NULL</code>).

   <p>The alternate function <code>_wcstoull_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>wcstoull</code> returns <code>0</code> and sets <code>errno</code> to <code>EINVAL</code> if the value of
<var>base</var> is not supported.

   <p><code>wcstoull</code> returns the converted value, if any. If no conversion was
made, <code>0</code> is returned.

   <p><code>wcstoull</code> returns <code>ULLONG_MAX</code> if the magnitude of the converted
value is too large, and sets <code>errno</code> to <code>ERANGE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>wcstoull</code> is ANSI.

   <p><code>wcstoull</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="system"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstombs">wcstombs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstoull">wcstoull</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.45 <code>system</code>&mdash;execute command string</h3>

<p><a name="index-system-106"></a><a name="index-g_t_005fsystem_005fr-107"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int system(char *<var>s</var>);

     int _system_r(void *<var>reent</var>, char *<var>s</var>);

</pre>
   <p><strong>Description</strong><br>

   <p>Use <code>system</code> to pass a command string <code>*</code><var>s</var> to <code>/bin/sh</code> on
your system, and wait for it to finish executing.

   <p>Use &ldquo;<code>system(NULL)</code>&rdquo; to test whether your system has <code>/bin/sh</code>
available.

   <p>The alternate function <code>_system_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>system(NULL)</code> returns a non-zero value if <code>/bin/sh</code> is available, and
<code>0</code> if it is not.

   <p>With a command argument, the result of <code>system</code> is the exit status
returned by <code>/bin/sh</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>system</code>, but leaves the nature and effects of a
command processor undefined.  ANSI C does, however, specify that
<code>system(NULL)</code> return zero or nonzero to report on the existence of
a command processor.

   <p>POSIX.2 requires <code>system</code>, and requires that it invoke a <code>sh</code>.
Where <code>sh</code> is found is left unspecified.

   <p>Supporting OS subroutines required: <code>_exit</code>, <code>_execve</code>, <code>_fork_r</code>,
<code>_wait_r</code>.

   <p><br>

<div class="node">
<a name="wcstombs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wctomb">wctomb</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#system">system</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.46 <code>wcstombs</code>&mdash;minimal wide char string to multibyte string converter</h3>

<p><a name="index-wcstombs-108"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     size_t wcstombs(char *<var>s</var>, const wchar_t *<var>pwc</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
When _MB_CAPABLE is not defined, this is a minimal ANSI-conforming
implementation of <code>wcstombs</code>.  In this case,
all wide-characters are expected to represent single bytes and so
are converted simply by casting to char.

   <p>When _MB_CAPABLE is defined, this routine calls <code>_wcstombs_r</code> to perform
the conversion, passing a state variable to allow state dependent
decoding.  The result is based on the locale setting which may
be restricted to a defined set of locales.

   <p><br>
<strong>Returns</strong><br>
This implementation of <code>wcstombs</code> returns <code>0</code> if
<var>s</var> is <code>NULL</code> or is the empty string;
it returns <code>-1</code> if _MB_CAPABLE and one of the
wide-char characters does not represent a valid multi-byte character;
otherwise it returns the minimum of: <code>n</code> or the
number of bytes that are transferred to <code>s</code>, not including the
nul terminator.

   <p>If the return value is -1, the state of the <code>pwc</code> string is
indeterminate.  If the input has a length of 0, the output
string will be modified to contain a wchar_t nul terminator if
<code>n</code> &gt; 0.

   <p><br>
<strong>Portability</strong><br>
<code>wcstombs</code> is required in the ANSI C standard.  However, the precise
effects vary with the locale.

   <p><code>wcstombs</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wctomb"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstombs">wcstombs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdlib">Stdlib</a>

</div>

<h3 class="section">2.47 <code>wctomb</code>&mdash;minimal wide char to multibyte converter</h3>

<p><a name="index-wctomb-109"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     int wctomb(char *<var>s</var>, wchar_t <var>wchar</var>);

</pre>
   <p><strong>Description</strong><br>
When _MB_CAPABLE is not defined, this is a minimal ANSI-conforming
implementation of <code>wctomb</code>.  The
only &ldquo;wide characters&rdquo; recognized are single bytes,
and they are &ldquo;converted&rdquo; to themselves.

   <p>When _MB_CAPABLE is defined, this routine calls <code>_wctomb_r</code> to perform
the conversion, passing a state variable to allow state dependent
decoding.  The result is based on the locale setting which may
be restricted to a defined set of locales.

   <p>Each call to <code>wctomb</code> modifies <code>*</code><var>s</var> unless <var>s</var> is a null
pointer or _MB_CAPABLE is defined and <var>wchar</var> is invalid.

   <p><br>
<strong>Returns</strong><br>
This implementation of <code>wctomb</code> returns <code>0</code> if
<var>s</var> is <code>NULL</code>; it returns <code>-1</code> if _MB_CAPABLE is enabled
and the wchar is not a valid multi-byte character, it returns <code>1</code>
if _MB_CAPABLE is not defined or the wchar is in reality a single
byte character, otherwise it returns the number of bytes in the
multi-byte character.

   <p><br>
<strong>Portability</strong><br>
<code>wctomb</code> is required in the ANSI C standard.  However, the precise
effects vary with the locale.

   <p><code>wctomb</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="Ctype"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Stdio">Stdio</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stdlib">Stdlib</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Character Type Macros and Functions (<samp><span class="file">ctype.h</span></samp>)</h2>

<p>This chapter groups macros (which are also available as subroutines)
to classify characters into several categories (alphabetic,
numeric, control characters, whitespace, and so on), or to perform
simple character mappings.

   <p>The header file <samp><span class="file">ctype.h</span></samp> defines the macros.

<ul class="menu">
<li><a accesskey="1" href="#isalnum">isalnum</a>:    Alphanumeric character predicate
<li><a accesskey="2" href="#isalpha">isalpha</a>:    Alphabetic character predicate
<li><a accesskey="3" href="#isascii">isascii</a>:    ASCII character predicate
<li><a accesskey="4" href="#iscntrl">iscntrl</a>:    Control character predicate
<li><a accesskey="5" href="#isdigit">isdigit</a>:    Decimal digit predicate
<li><a accesskey="6" href="#islower">islower</a>:    Lowercase character predicate
<li><a accesskey="7" href="#isprint">isprint</a>:    Printable character predicates (isprint, isgraph)
<li><a accesskey="8" href="#ispunct">ispunct</a>:    Punctuation character predicate
<li><a accesskey="9" href="#isspace">isspace</a>:    Whitespace character predicate
<li><a href="#isupper">isupper</a>:    Uppercase character predicate
<li><a href="#isxdigit">isxdigit</a>:   Hexadecimal digit predicate
<li><a href="#toascii">toascii</a>:    Force integers to ASCII range
<li><a href="#tolower">tolower</a>:    Translate characters to lowercase
<li><a href="#toupper">toupper</a>:    Translate characters to uppercase
<li><a href="#iswalnum">iswalnum</a>:   Alphanumeric wide character predicate
<li><a href="#iswalpha">iswalpha</a>:   Alphabetic wide character predicate
<li><a href="#iswblank">iswblank</a>:   Blank wide character predicate
<li><a href="#iswcntrl">iswcntrl</a>:   Control wide character predicate
<li><a href="#iswdigit">iswdigit</a>:   Decimal digit wide character predicate
<li><a href="#iswgraph">iswgraph</a>:   Graphic wide character predicate
<li><a href="#iswlower">iswlower</a>:   Lowercase wide character predicate
<li><a href="#iswprint">iswprint</a>:   Printable wide character predicate
<li><a href="#iswpunct">iswpunct</a>:   Punctuation wide character predicate
<li><a href="#iswspace">iswspace</a>:   Whitespace wide character predicate
<li><a href="#iswupper">iswupper</a>:   Uppercase wide character predicate
<li><a href="#iswxdigit">iswxdigit</a>:  Hexadecimal digit wide character predicate
<li><a href="#iswctype">iswctype</a>:   Extensible wide-character test
<li><a href="#wctype">wctype</a>:     Compute wide-character test type
<li><a href="#towlower">towlower</a>:   Translate wide characters to lowercase
<li><a href="#towupper">towupper</a>:   Translate wide characters to uppercase
<li><a href="#towctrans">towctrans</a>:  Extensible wide-character translation
<li><a href="#wctrans">wctrans</a>:    Compute wide-character translation type
</ul>

<div class="node">
<a name="isalnum"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isalpha">isalpha</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.1 <code>isalnum</code>&mdash;alphanumeric character predicate</h3>

<p><a name="index-isalnum-110"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isalnum(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isalnum</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for alphabetic or
numeric ASCII characters, and <code>0</code> for other arguments.  It is defined
for all integer values.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isalnum</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isalnum</code> returns non-zero if <var>c</var> is a letter (<code>a</code>&ndash;<code>z</code> or
<code>A</code>&ndash;<code>Z</code>) or a digit (<code>0</code>&ndash;<code>9</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isalnum</code> is ANSI C.

   <p>No OS subroutines are required.

   <p><br>

<div class="node">
<a name="isalpha"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isascii">isascii</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isalnum">isalnum</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.2 <code>isalpha</code>&mdash;alphabetic character predicate</h3>

<p><a name="index-isalpha-111"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isalpha(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isalpha</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero when <var>c</var> represents an
alphabetic ASCII character, and 0 otherwise.  It is defined only when
<code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isalpha</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isalpha</code> returns non-zero if <var>c</var> is a letter (<code>A</code>&ndash;<code>Z</code> or
<code>a</code>&ndash;<code>z</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isalpha</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isascii"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iscntrl">iscntrl</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isalpha">isalpha</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.3 <code>isascii</code>&mdash;ASCII character predicate</h3>

<p><a name="index-isascii-112"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isascii(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isascii</code> is a macro which returns non-zero when <var>c</var> is an ASCII
character, and 0 otherwise.  It is defined for all integer values.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isascii</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isascii</code> returns non-zero if the low order byte of <var>c</var> is in the range
0 to 127 (<code>0x00</code>&ndash;<code>0x7F</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isascii</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iscntrl"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isdigit">isdigit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isascii">isascii</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.4 <code>iscntrl</code>&mdash;control character predicate</h3>

<p><a name="index-iscntrl-113"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int iscntrl(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iscntrl</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for control characters, and 0
for other characters.  It is defined only when <code>isascii</code>(<var>c</var>) is
true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef iscntrl</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>iscntrl</code> returns non-zero if <var>c</var> is a delete character or ordinary
control character (<code>0x7F</code> or <code>0x00</code>&ndash;<code>0x1F</code>).

   <p><br>
<strong>Portability</strong><br>
<code>iscntrl</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isdigit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#islower">islower</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iscntrl">iscntrl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.5 <code>isdigit</code>&mdash;decimal digit predicate</h3>

<p><a name="index-isdigit-114"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isdigit(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isdigit</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for decimal digits, and 0 for
other characters.  It is defined only when <code>isascii</code>(<var>c</var>) is true
or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isdigit</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isdigit</code> returns non-zero if <var>c</var> is a decimal digit (<code>0</code>&ndash;<code>9</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isdigit</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="islower"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isprint">isprint</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isdigit">isdigit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.6 <code>islower</code>&mdash;lowercase character predicate</h3>

<p><a name="index-islower-115"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int islower(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>islower</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for minuscules
(lowercase alphabetic characters), and 0 for other characters.
It is defined only when <code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef islower</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>islower</code> returns non-zero if <var>c</var> is a lowercase letter (<code>a</code>&ndash;<code>z</code>).

   <p><br>
<strong>Portability</strong><br>
<code>islower</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isprint"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ispunct">ispunct</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#islower">islower</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.7 <code>isprint</code>, <code>isgraph</code>&mdash;printable character predicates</h3>

<p><a name="index-isprint-116"></a><a name="index-isgraph-117"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isprint(int <var>c</var>);
     int isgraph(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isprint</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for printable
characters, and 0 for other character arguments.
It is defined only when <code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining either macro using `<code>#undef isprint</code>' or `<code>#undef isgraph</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isprint</code> returns non-zero if <var>c</var> is a printing character,
(<code>0x20</code>&ndash;<code>0x7E</code>).
<code>isgraph</code> behaves identically to <code>isprint</code>, except that the space
character (<code>0x20</code>) is excluded.

   <p><br>
<strong>Portability</strong><br>
<code>isprint</code> and <code>isgraph</code> are ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="ispunct"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isspace">isspace</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isprint">isprint</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.8 <code>ispunct</code>&mdash;punctuation character predicate</h3>

<p><a name="index-ispunct-118"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int ispunct(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>ispunct</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for printable
punctuation characters, and 0 for other characters.  It is defined
only when <code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef ispunct</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>ispunct</code> returns non-zero if <var>c</var> is a printable punctuation character
(<code>isgraph(</code><var>c</var><code>) &amp;&amp; !isalnum(</code><var>c</var><code>)</code>).

   <p><br>
<strong>Portability</strong><br>
<code>ispunct</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isspace"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isupper">isupper</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ispunct">ispunct</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.9 <code>isspace</code>&mdash;whitespace character predicate</h3>

<p><a name="index-isspace-119"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isspace(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isspace</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for whitespace
characters, and 0 for other characters.  It is defined only when <code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isspace</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isspace</code> returns non-zero if <var>c</var> is a space, tab, carriage return, new
line, vertical tab, or formfeed (<code>0x09</code>&ndash;<code>0x0D</code>, <code>0x20</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isspace</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isupper"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#isxdigit">isxdigit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isspace">isspace</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.10 <code>isupper</code>&mdash;uppercase character predicate</h3>

<p><a name="index-isupper-120"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isupper(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isupper</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for uppercase letters
(<code>A</code>&ndash;<code>Z</code>), and 0 for other characters.  It is defined only when
<code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isupper</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isupper</code> returns non-zero if <var>c</var> is a uppercase letter (A-Z).

   <p><br>
<strong>Portability</strong><br>
<code>isupper</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="isxdigit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#toascii">toascii</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isupper">isupper</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.11 <code>isxdigit</code>&mdash;hexadecimal digit predicate</h3>

<p><a name="index-isxdigit-121"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int isxdigit(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>isxdigit</code> is a macro which classifies ASCII integer values by table
lookup.  It is a predicate returning non-zero for hexadecimal digits,
and <code>0</code> for other characters.  It is defined only when
<code>isascii</code>(<var>c</var>) is true or <var>c</var> is EOF.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining the macro using `<code>#undef isxdigit</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>isxdigit</code> returns non-zero if <var>c</var> is a hexadecimal digit
(<code>0</code>&ndash;<code>9</code>, <code>a</code>&ndash;<code>f</code>, or <code>A</code>&ndash;<code>F</code>).

   <p><br>
<strong>Portability</strong><br>
<code>isxdigit</code> is ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="toascii"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tolower">tolower</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#isxdigit">isxdigit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.12 <code>toascii</code>&mdash;force integers to ASCII range</h3>

<p><a name="index-toascii-122"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int toascii(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>toascii</code> is a macro which coerces integers to the ASCII range (0&ndash;127) by zeroing any higher-order bits.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining this macro using `<code>#undef toascii</code>'.

   <p><br>
<strong>Returns</strong><br>
<code>toascii</code> returns integers between 0 and 127.

   <p><br>
<strong>Portability</strong><br>
<code>toascii</code> is not ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="tolower"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#toupper">toupper</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#toascii">toascii</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.13 <code>tolower</code>&mdash;translate characters to lowercase</h3>

<p><a name="index-tolower-123"></a><a name="index-g_t_005ftolower-124"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int tolower(int <var>c</var>);
     int _tolower(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>tolower</code> is a macro which converts uppercase characters to lowercase,
leaving all other characters unchanged.  It is only defined when
<var>c</var> is an integer in the range <code>EOF</code> to <code>255</code>.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining this macro using `<code>#undef tolower</code>'.

   <p><code>_tolower</code> performs the same conversion as <code>tolower</code>, but should
only be used when <var>c</var> is known to be an uppercase character (<code>A</code>&ndash;<code>Z</code>).

   <p><br>
<strong>Returns</strong><br>
<code>tolower</code> returns the lowercase equivalent of <var>c</var> when it is a
character between <code>A</code> and <code>Z</code>, and <var>c</var> otherwise.

   <p><code>_tolower</code> returns the lowercase equivalent of <var>c</var> when it is a
character between <code>A</code> and <code>Z</code>.  If <var>c</var> is not one of these
characters, the behaviour of <code>_tolower</code> is undefined.

   <p><br>
<strong>Portability</strong><br>
<code>tolower</code> is ANSI C.  <code>_tolower</code> is not recommended for portable
programs.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="toupper"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswalnum">iswalnum</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tolower">tolower</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.14 <code>toupper</code>&mdash;translate characters to uppercase</h3>

<p><a name="index-toupper-125"></a><a name="index-g_t_005ftoupper-126"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;ctype.h&gt;
     int toupper(int <var>c</var>);
     int _toupper(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>toupper</code> is a macro which converts lowercase characters to uppercase,
leaving all other characters unchanged.  It is only defined when
<var>c</var> is an integer in the range <code>EOF</code> to <code>255</code>.

   <p>You can use a compiled subroutine instead of the macro definition by
undefining this macro using `<code>#undef toupper</code>'.

   <p><code>_toupper</code> performs the same conversion as <code>toupper</code>, but should
only be used when <var>c</var> is known to be a lowercase character (<code>a</code>&ndash;<code>z</code>).

   <p><br>
<strong>Returns</strong><br>
<code>toupper</code> returns the uppercase equivalent of <var>c</var> when it is a
character between <code>a</code> and <code>z</code>, and <var>c</var> otherwise.

   <p><code>_toupper</code> returns the uppercase equivalent of <var>c</var> when it is a
character between <code>a</code> and <code>z</code>.  If <var>c</var> is not one of these
characters, the behaviour of <code>_toupper</code> is undefined.

   <p><br>
<strong>Portability</strong><br>
<code>toupper</code> is ANSI C.  <code>_toupper</code> is not recommended for portable programs.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswalnum"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswalpha">iswalpha</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#toupper">toupper</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.15 <code>iswalnum</code>&mdash;alphanumeric wide character test</h3>

<p><a name="index-iswalnum-127"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswalnum(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswalnum</code> is a function which classifies wide-character values that
are alphanumeric.

   <p><br>
<strong>Returns</strong><br>
<code>iswalnum</code> returns non-zero if <var>c</var> is a alphanumeric wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswalnum</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswalpha"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswblank">iswblank</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswalnum">iswalnum</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.16 <code>iswalpha</code>&mdash;alphabetic wide character test</h3>

<p><a name="index-iswalpha-128"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswalpha(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswalpha</code> is a function which classifies wide-character values that
are alphabetic.

   <p><br>
<strong>Returns</strong><br>
<code>iswalpha</code> returns non-zero if <var>c</var> is an alphabetic wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswalpha</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswcntrl"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswdigit">iswdigit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswblank">iswblank</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.17 <code>iswcntrl</code>&mdash;control wide character test</h3>

<p><a name="index-iswcntrl-129"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswcntrl(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswcntrl</code> is a function which classifies wide-character values that
are categorized as control characters.

   <p><br>
<strong>Returns</strong><br>
<code>iswcntrl</code> returns non-zero if <var>c</var> is a control wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswcntrl</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswblank"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswcntrl">iswcntrl</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswalpha">iswalpha</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.18 <code>iswblank</code>&mdash;blank wide character test</h3>

<p><a name="index-iswblank-130"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswblank(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswblank</code> is a function which classifies wide-character values that
are categorized as blank.

   <p><br>
<strong>Returns</strong><br>
<code>iswblank</code> returns non-zero if <var>c</var> is a blank wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswblank</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswdigit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswgraph">iswgraph</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswcntrl">iswcntrl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.19 <code>iswdigit</code>&mdash;decimal digit wide character test</h3>

<p><a name="index-iswdigit-131"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswdigit(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswdigit</code> is a function which classifies wide-character values that
are decimal digits.

   <p><br>
<strong>Returns</strong><br>
<code>iswdigit</code> returns non-zero if <var>c</var> is a decimal digit wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswdigit</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswgraph"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswlower">iswlower</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswdigit">iswdigit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.20 <code>iswgraph</code>&mdash;graphic wide character test</h3>

<p><a name="index-iswgraph-132"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswgraph(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswgraph</code> is a function which classifies wide-character values that
are graphic.

   <p><br>
<strong>Returns</strong><br>
<code>iswgraph</code> returns non-zero if <var>c</var> is a graphic wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswgraph</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswlower"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswprint">iswprint</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswgraph">iswgraph</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.21 <code>iswlower</code>&mdash;lowercase wide character test</h3>

<p><a name="index-iswlower-133"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswlower(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswlower</code> is a function which classifies wide-character values that
have uppercase translations.

   <p><br>
<strong>Returns</strong><br>
<code>iswlower</code> returns non-zero if <var>c</var> is a lowercase wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswlower</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswprint"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswpunct">iswpunct</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswlower">iswlower</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.22 <code>iswprint</code>&mdash;printable wide character test</h3>

<p><a name="index-iswprint-134"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswprint(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswprint</code> is a function which classifies wide-character values that
are printable.

   <p><br>
<strong>Returns</strong><br>
<code>iswprint</code> returns non-zero if <var>c</var> is a printable wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswprint</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswpunct"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswspace">iswspace</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswprint">iswprint</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.23 <code>iswpunct</code>&mdash;punctuation wide character test</h3>

<p><a name="index-iswpunct-135"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswpunct(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswpunct</code> is a function which classifies wide-character values that
are punctuation.

   <p><br>
<strong>Returns</strong><br>
<code>iswpunct</code> returns non-zero if <var>c</var> is a punctuation wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswpunct</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswspace"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswupper">iswupper</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswpunct">iswpunct</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.24 <code>iswspace</code>&mdash;whitespace wide character test</h3>

<p><a name="index-iswspace-136"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswspace(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswspace</code> is a function which classifies wide-character values that
are categorized as whitespace.

   <p><br>
<strong>Returns</strong><br>
<code>iswspace</code> returns non-zero if <var>c</var> is a whitespace wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswspace</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswupper"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswxdigit">iswxdigit</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswspace">iswspace</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.25 <code>iswupper</code>&mdash;uppercase wide character test</h3>

<p><a name="index-iswupper-137"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswupper(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswupper</code> is a function which classifies wide-character values that
have uppercase translations.

   <p><br>
<strong>Returns</strong><br>
<code>iswupper</code> returns non-zero if <var>c</var> is a uppercase wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswupper</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswxdigit"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#iswctype">iswctype</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswupper">iswupper</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.26 <code>iswxdigit</code>&mdash;hexadecimal digit wide character test</h3>

<p><a name="index-iswxdigit-138"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswxdigit(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswxdigit</code> is a function which classifies wide character values that
are hexadecimal digits.

   <p><br>
<strong>Returns</strong><br>
<code>iswxdigit</code> returns non-zero if <var>c</var> is a hexadecimal digit wide character.

   <p><br>
<strong>Portability</strong><br>
<code>iswxdigit</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="iswctype"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wctype">wctype</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswxdigit">iswxdigit</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.27 <code>iswctype</code>&mdash;extensible wide-character test</h3>

<p><a name="index-iswctype-139"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     int iswctype(wint_t <var>c</var>, wctype_t <var>desc</var>);

</pre>
   <p><strong>Description</strong><br>
<code>iswctype</code> is a function which classifies wide-character values using the
wide-character test specified by <var>desc</var>.

   <p><br>
<strong>Returns</strong><br>
<code>iswctype</code> returns non-zero if and only if <var>c</var> matches the test specified by <var>desc</var>.
If <var>desc</var> is unknown, zero is returned.

   <p><br>
<strong>Portability</strong><br>
<code>iswctype</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wctype"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#towlower">towlower</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#iswctype">iswctype</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.28 <code>wctype</code>&mdash;get wide-character classification type</h3>

<p><a name="index-wctype-140"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     wctype_t wctype(const char *<var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wctype</code> is a function which takes a string <var>c</var> and gives back
the appropriate wctype_t type value associated with the string,
if one exists.  The following values are guaranteed to be recognized:
"alnum", "alpha", "blank", "cntrl", "digit", "graph", "lower", "print",
"punct", "space", "upper", and "xdigit".

   <p><br>
<strong>Returns</strong><br>
<code>wctype</code> returns 0 and sets <code>errno</code> to <code>EINVAL</code> if the
given name is invalid.  Otherwise, it returns a valid non-zero wctype_t
value.

   <p><br>
<strong>Portability</strong><br>
<code>wctype</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="towlower"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#towupper">towupper</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wctype">wctype</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.29 <code>towlower</code>&mdash;translate wide characters to lowercase</h3>

<p><a name="index-towlower-141"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     wint_t towlower(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>towlower</code> is a function which converts uppercase wide characters to
lowercase, leaving all other characters unchanged.

   <p><br>
<strong>Returns</strong><br>
<code>towlower</code> returns the lowercase equivalent of <var>c</var> when it is a
uppercase wide character; otherwise, it returns the input character.

   <p><br>
<strong>Portability</strong><br>
<code>towlower</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="towupper"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#towctrans">towctrans</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#towlower">towlower</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.30 <code>towupper</code>&mdash;translate wide characters to uppercase</h3>

<p><a name="index-towupper-142"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     wint_t towupper(wint_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>towupper</code> is a function which converts lowercase wide characters to
uppercase, leaving all other characters unchanged.

   <p><br>
<strong>Returns</strong><br>
<code>towupper</code> returns the uppercase equivalent of <var>c</var> when it is a
lowercase wide character, otherwise, it returns the input character.

   <p><br>
<strong>Portability</strong><br>
<code>towupper</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="towctrans"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wctrans">wctrans</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#towupper">towupper</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.31 <code>towctrans</code>&mdash;extensible wide-character translation</h3>

<p><a name="index-towctrans-143"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     wint_t towctrans(wint_t <var>c</var>, wctrans_t <var>w</var>);

</pre>
   <p><strong>Description</strong><br>
<code>towctrans</code> is a function which converts wide characters based on
a specified translation type <var>w</var>.  If the translation type is
invalid or cannot be applied to the current character, no change
to the character is made.

   <p><br>
<strong>Returns</strong><br>
<code>towctrans</code> returns the translated equivalent of <var>c</var> when it is a
valid for the given translation, otherwise, it returns the input character.
When the translation type is invalid, <code>errno</code> is set <code>EINVAL</code>.

   <p><br>
<strong>Portability</strong><br>
<code>towctrans</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wctrans"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#towctrans">towctrans</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ctype">Ctype</a>

</div>

<h3 class="section">3.32 <code>wctrans</code>&mdash;get wide-character translation type</h3>

<p><a name="index-wctrans-144"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wctype.h&gt;
     wctrans_t wctrans(const char *<var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wctrans</code> is a function which takes a string <var>c</var> and gives back
the appropriate wctrans_t type value associated with the string,
if one exists.  The following values are guaranteed to be recognized:
"tolower" and "toupper".

   <p><br>
<strong>Returns</strong><br>
<code>wctrans</code> returns 0 and sets <code>errno</code> to <code>EINVAL</code> if the
given name is invalid.  Otherwise, it returns a valid non-zero wctrans_t
value.

   <p><br>
<strong>Portability</strong><br>
<code>wctrans</code> is C99.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="Stdio"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Stdio64">Stdio64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ctype">Ctype</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Input and Output (<samp><span class="file">stdio.h</span></samp>)</h2>

<p>This chapter comprises functions to manage files
or other input/output streams. Among these functions are subroutines
to generate or scan strings according to specifications from a format string.

   <p>The underlying facilities for input and output depend on the host
system, but these functions provide a uniform interface.

   <p>The corresponding declarations are in <samp><span class="file">stdio.h</span></samp>.

   <p>The reentrant versions of these functions use macros

<pre class="example">     _stdin_r(<var>reent</var>)
     _stdout_r(<var>reent</var>)
     _stderr_r(<var>reent</var>)
</pre>
   <p class="noindent">instead of the globals <code>stdin</code>, <code>stdout</code>, and
<code>stderr</code>.  The argument &lt;[reent]&gt; is a pointer to a reentrancy
structure.

<ul class="menu">
<li><a accesskey="1" href="#clearerr">clearerr</a>:     Clear file or stream error indicator
<li><a accesskey="2" href="#diprintf">diprintf</a>:     Print to a file descriptor (integer only)
<li><a accesskey="3" href="#dprintf">dprintf</a>:      Print to a file descriptor
<li><a accesskey="4" href="#fclose">fclose</a>:       Close a file
<li><a accesskey="5" href="#fcloseall">fcloseall</a>:    Close all files
<li><a accesskey="6" href="#fdopen">fdopen</a>:       Turn an open file into a stream
<li><a accesskey="7" href="#feof">feof</a>:         Test for end of file
<li><a accesskey="8" href="#ferror">ferror</a>:       Test whether read/write error has occurred
<li><a accesskey="9" href="#fflush">fflush</a>:       Flush buffered file output
<li><a href="#fgetc">fgetc</a>:        Get a character from a file or stream
<li><a href="#fgetpos">fgetpos</a>:      Record position in a stream or file
<li><a href="#fgets">fgets</a>:        Get character string from a file or stream
<li><a href="#fgetwc">fgetwc</a>:       Get a wide character from a file or stream
<li><a href="#fgetws">fgetws</a>:       Get a wide character string from a file or stream
<li><a href="#fileno">fileno</a>:       Get file descriptor associated with stream
<li><a href="#fmemopen">fmemopen</a>:     Open a stream around a fixed-length buffer
<li><a href="#fopen">fopen</a>:        Open a file
<li><a href="#fopencookie">fopencookie</a>:  Open a stream with custom callbacks
<li><a href="#fpurge">fpurge</a>:       Discard all pending I/O on a stream
<li><a href="#fputc">fputc</a>:        Write a character on a stream or file
<li><a href="#fputs">fputs</a>:        Write a character string in a file or stream
<li><a href="#fputwc">fputwc</a>:       Write a wide character to a file or stream
<li><a href="#fputws">fputws</a>:       Write a wide character string to a file or stream
<li><a href="#fread">fread</a>:        Read array elements from a file
<li><a href="#freopen">freopen</a>:      Open a file using an existing file descriptor
<li><a href="#fseek">fseek</a>:        Set file position
<li><a href="#fsetpos">fsetpos</a>:      Restore position of a stream or file
<li><a href="#ftell">ftell</a>:        Return position in a stream or file
<li><a href="#funopen">funopen</a>:      Open a stream with custom callbacks
<li><a href="#fwide">fwide</a>: 	Set and determine the orientation of a FILE stream
<li><a href="#fwrite">fwrite</a>:       Write array elements from memory to a file or stream
<li><a href="#getc">getc</a>:         Get a character from a file or stream (macro)
<li><a href="#getc_005funlocked">getc_unlocked</a>: 	Get a character from a file or stream (macro)
<li><a href="#getchar">getchar</a>:      Get a character from standard input (macro)
<li><a href="#getchar_005funlocked">getchar_unlocked</a>: 	Get a character from standard input (macro)
<li><a href="#getdelim">getdelim</a>:     Get character string from a file or stream
<li><a href="#getline">getline</a>:      Get character string from a file or stream
<li><a href="#gets">gets</a>:         Get character string from standard input (obsolete)
<li><a href="#getw">getw</a>:         Get a word (int) from a file or stream
<li><a href="#getwchar">getwchar</a>:     Get a wide character from standard input
<li><a href="#mktemp">mktemp</a>:       Generate unused file name
<li><a href="#open_005fmemstream">open_memstream</a>: 	Open a write stream around an arbitrary-length buffer
<li><a href="#perror">perror</a>:       Print an error message on standard error
<li><a href="#putc">putc</a>:         Write a character on a stream or file (macro)
<li><a href="#putc_005funlocked">putc_unlocked</a>: 	Write a character on a stream or file (macro)
<li><a href="#putchar">putchar</a>:      Write a character on standard output (macro)
<li><a href="#putchar_005funlocked">putchar_unlocked</a>: 	Write a character on standard output (macro)
<li><a href="#puts">puts</a>:         Write a character string on standard output
<li><a href="#putw">putw</a>:         Write a word (int) to a file or stream
<li><a href="#putwchar">putwchar</a>:     Write a wide character to standard output
<li><a href="#remove">remove</a>:       Delete a file's name
<li><a href="#rename">rename</a>:       Rename a file
<li><a href="#rewind">rewind</a>:       Reinitialize a file or stream
<li><a href="#setbuf">setbuf</a>:       Specify full buffering for a file or stream
<li><a href="#setbuffer">setbuffer</a>:    Specify full buffering for a file or stream with size
<li><a href="#setlinebuf">setlinebuf</a>:   Specify line buffering for a file or stream
<li><a href="#setvbuf">setvbuf</a>:      Specify buffering for a file or stream
<li><a href="#siprintf">siprintf</a>:     Write formatted output (integer only)
<li><a href="#siscanf">siscanf</a>:      Scan and format input (integer only)
<li><a href="#sprintf">sprintf</a>:      Write formatted output
<li><a href="#sscanf">sscanf</a>:       Scan and format input
<li><a href="#swprintf">swprintf</a>:     Write formatted wide character output
<li><a href="#swscanf">swscanf</a>:      Scan and format wide character input
<li><a href="#tmpfile">tmpfile</a>:      Create a temporary file
<li><a href="#tmpnam">tmpnam</a>:       Generate name for a temporary file
<li><a href="#ungetc">ungetc</a>:       Push data back into a stream
<li><a href="#ungetwc">ungetwc</a>:      Push wide character data back into a stream
<li><a href="#vfprintf">vfprintf</a>:     Format variable argument list
<li><a href="#vfscanf">vfscanf</a>:      Scan variable argument list
<li><a href="#vfwprintf">vfwprintf</a>:    Format variable wide character argument list
<li><a href="#vfwscanf">vfwscanf</a>:     Scan and format argument list from wide character input
<li><a href="#viprintf">viprintf</a>:     Format variable argument list (integer only)
<li><a href="#viscanf">viscanf</a>:      Scan variable format list (integer only)
</ul>

<div class="node">
<a name="clearerr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#diprintf">diprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.1 <code>clearerr</code>&mdash;clear file or stream error indicator</h3>

<p><a name="index-clearerr-145"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void clearerr(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>stdio</code> functions maintain an error indicator with each file
pointer <var>fp</var>, to record whether any read or write errors have
occurred on the associated file or stream.  Similarly, it maintains an
end-of-file indicator to record whether there is no more data in the
file.

   <p>Use <code>clearerr</code> to reset both of these indicators.

   <p>See <code>ferror</code> and <code>feof</code> to query the two indicators.

   <p><br>
<strong>Returns</strong><br>
<code>clearerr</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>clearerr</code>.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="diprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#dprintf">dprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#clearerr">clearerr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.2 <code>diprintf</code>, <code>vdiprintf</code>&mdash;print to a file descriptor (integer only)</h3>

<p><a name="index-diprintf-146"></a><a name="index-g_t_005fdiprintf_005fr-147"></a><a name="index-vdiprintf-148"></a><a name="index-g_t_005fvdiprintf_005fr-149"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int diprintf(int <var>fd</var>, const char *<var>format</var>, ...);
     int vdiprintf(int <var>fd</var>, const char *<var>format</var>, va_list <var>ap</var>);
     int _diprintf_r(struct _reent *<var>ptr</var>, int <var>fd</var>,
         const char *<var>format</var>, ...);
     int _vdiprintf_r(struct _reent *<var>ptr</var>, int <var>fd</var>,
         const char *<var>format</var>, va_list <var>ap</var>);

</pre>
   <p><strong>Description</strong><br>
<code>diprintf</code> and <code>vdiprintf</code> are similar to <code>dprintf</code> and <code>vdprintf</code>,
except that only integer format specifiers are processed.

   <p>The functions <code>_diprintf_r</code> and <code>_vdiprintf_r</code> are simply
reentrant versions of the functions above.

   <p><br>
<strong>Returns</strong><br>
Similar to <code>dprintf</code> and <code>vdprintf</code>.

   <p><br>
<strong>Portability</strong><br>
This set of functions is an integer-only extension, and is not portable.

   <p>Supporting OS subroutines required: <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="dprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fclose">fclose</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#diprintf">diprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.3 <code>dprintf</code>, <code>vdprintf</code>&mdash;print to a file descriptor</h3>

<p><a name="index-dprintf-150"></a><a name="index-g_t_005fdprintf_005fr-151"></a><a name="index-vdprintf-152"></a><a name="index-g_t_005fvdprintf_005fr-153"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int dprintf(int <var>fd</var>, const char *<var>format</var>, ...);
     int vdprintf(int <var>fd</var>, const char *<var>format</var>, va_list <var>ap</var>);
     int _dprintf_r(struct _reent *<var>ptr</var>, int <var>fd</var>,
         const char *<var>format</var>, ...);
     int _vdprintf_r(struct _reent *<var>ptr</var>, int <var>fd</var>,
         const char *<var>format</var>, va_list <var>ap</var>);

</pre>
   <p><strong>Description</strong><br>
<code>dprintf</code> and <code>vdprintf</code> allow printing a format, similarly to
<code>printf</code>, but write to a file descriptor instead of to a <code>FILE</code>
stream.

   <p>The functions <code>_dprintf_r</code> and <code>_vdprintf_r</code> are simply
reentrant versions of the functions above.

   <p><br>
<strong>Returns</strong><br>
The return value and errors are exactly as for <code>write</code>, except that
<code>errno</code> may also be set to <code>ENOMEM</code> if the heap is exhausted.

   <p><br>
<strong>Portability</strong><br>
This function is originally a GNU extension in glibc and is not portable.

   <p>Supporting OS subroutines required: <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fclose"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fcloseall">fcloseall</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#dprintf">dprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.4 <code>fclose</code>&mdash;close a file</h3>

<p><a name="index-fclose-154"></a><a name="index-g_t_005ffclose_005fr-155"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fclose(FILE *<var>fp</var>);
     int _fclose_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
If the file or stream identified by <var>fp</var> is open, <code>fclose</code> closes
it, after first ensuring that any pending data is written (by calling
<code>fflush(</code><var>fp</var><code>)</code>).

   <p>The alternate function <code>_fclose_r</code> is a reentrant version.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>fclose</code> returns <code>0</code> if successful (including when <var>fp</var> is
<code>NULL</code> or not an open file); otherwise, it returns <code>EOF</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fclose</code> is required by ANSI C.

   <p>Required OS subroutines: <code>close</code>, <code>fstat</code>, <code>isatty</code>, <code>lseek</code>,
<code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fcloseall"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fdopen">fdopen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fclose">fclose</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.5 <code>fcloseall</code>&mdash;close all files</h3>

<p><a name="index-fcloseall-156"></a><a name="index-g_t_005ffcloseall_005fr-157"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fcloseall(void);
     int _fcloseall_r (struct _reent *<var>ptr</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fcloseall</code> closes all files in the current reentrancy struct's domain.
The function <code>_fcloseall_r</code> is the same function, except the reentrancy
struct is passed in as the <var>ptr</var> argument.

   <p>This function is not recommended as it closes all streams, including
the std streams.

   <p><br>
<strong>Returns</strong><br>
<code>fclose</code> returns <code>0</code> if all closes are successful.  Otherwise,
EOF is returned.

   <p><br>
<strong>Portability</strong><br>
<code>fcloseall</code> is a glibc extension.

   <p>Required OS subroutines: <code>close</code>, <code>fstat</code>, <code>isatty</code>, <code>lseek</code>,
<code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fdopen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#feof">feof</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fcloseall">fcloseall</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.6 <code>fdopen</code>&mdash;turn open file into a stream</h3>

<p><a name="index-fdopen-158"></a><a name="index-g_t_005ffdopen_005fr-159"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *fdopen(int <var>fd</var>, const char *<var>mode</var>);
     FILE *_fdopen_r(struct _reent *<var>reent</var>,
         int <var>fd</var>, const char *<var>mode</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fdopen</code> produces a file descriptor of type <code>FILE *</code>, from a
descriptor for an already-open file (returned, for example, by the
system subroutine <code>open</code> rather than by <code>fopen</code>).
The <var>mode</var> argument has the same meanings as in <code>fopen</code>.

   <p><br>
<strong>Returns</strong><br>
File pointer or <code>NULL</code>, as for <code>fopen</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fdopen</code> is ANSI.

   <p><br>

<div class="node">
<a name="feof"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ferror">ferror</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fdopen">fdopen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.7 <code>feof</code>&mdash;test for end of file</h3>

<p><a name="index-feof-160"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int feof(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>feof</code> tests whether or not the end of the file identified by <var>fp</var>
has been reached.

   <p><br>
<strong>Returns</strong><br>
<code>feof</code> returns <code>0</code> if the end of file has not yet been reached; if
at end of file, the result is nonzero.

   <p><br>
<strong>Portability</strong><br>
<code>feof</code> is required by ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="ferror"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fflush">fflush</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#feof">feof</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.8 <code>ferror</code>&mdash;test whether read/write error has occurred</h3>

<p><a name="index-ferror-161"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int ferror(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>stdio</code> functions maintain an error indicator with each file
pointer <var>fp</var>, to record whether any read or write errors have
occurred on the associated file or stream.
Use <code>ferror</code> to query this indicator.

   <p>See <code>clearerr</code> to reset the error indicator.

   <p><br>
<strong>Returns</strong><br>
<code>ferror</code> returns <code>0</code> if no errors have occurred; it returns a
nonzero value otherwise.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>ferror</code>.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fflush"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgetc">fgetc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ferror">ferror</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.9 <code>fflush</code>&mdash;flush buffered file output</h3>

<p><a name="index-fflush-162"></a><a name="index-g_t_005ffflush_005fr-163"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fflush(FILE *<var>fp</var>);

     int _fflush_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>stdio</code> output functions can buffer output before delivering it
to the host system, in order to minimize the overhead of system calls.

   <p>Use <code>fflush</code> to deliver any such pending output (for the file
or stream identified by <var>fp</var>) to the host system.

   <p>If <var>fp</var> is <code>NULL</code>, <code>fflush</code> delivers pending output from all
open files.

   <p>Additionally, if <var>fp</var> is a seekable input stream visiting a file
descriptor, set the position of the file descriptor to match next
unread byte, useful for obeying POSIX semantics when ending a process
without consuming all input from the stream.

   <p>The alternate function <code>_fflush_r</code> is a reentrant version, where the
extra argument <var>reent</var> is a pointer to a reentrancy structure, and
<var>fp</var> must not be NULL.

   <p><br>
<strong>Returns</strong><br>
<code>fflush</code> returns <code>0</code> unless it encounters a write error; in that
situation, it returns <code>EOF</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fflush</code>.  The behavior on input streams is only
specified by POSIX, and not all implementations follow POSIX rules.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fgetc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgetpos">fgetpos</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fflush">fflush</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.10 <code>fgetc</code>&mdash;get a character from a file or stream</h3>

<p><a name="index-fgetc-164"></a><a name="index-g_t_005ffgetc_005fr-165"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fgetc(FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _fgetc_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>fgetc</code> to get the next single character from the file or stream
identified by <var>fp</var>.  As a side effect, <code>fgetc</code> advances the file's
current position indicator.

   <p>For a macro version of this function, see <code>getc</code>.

   <p>The function <code>_fgetc_r</code> is simply a reentrant version of
<code>fgetc</code> that is passed the additional reentrant structure
pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
The next character (read as an <code>unsigned char</code>, and cast to
<code>int</code>), unless there is no more data, or the host system reports a
read error; in either of these situations, <code>fgetc</code> returns <code>EOF</code>.

   <p>You can distinguish the two situations that cause an <code>EOF</code> result by
using the <code>ferror</code> and <code>feof</code> functions.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fgetc</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fgetpos"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgets">fgets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgetc">fgetc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.11 <code>fgetpos</code>&mdash;record position in a stream or file</h3>

<p><a name="index-fgetpos-166"></a><a name="index-g_t_005ffgetpos_005fr-167"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fgetpos(FILE *<var>fp</var>, fpos_t *<var>pos</var>);
     int _fgetpos_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>, fpos_t *<var>pos</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fgetpos</code> to report on the current position for a file
identified by <var>fp</var>; <code>fgetpos</code> will write a value
representing that position at <code>*</code><var>pos</var>.  Later, you can
use this value with <code>fsetpos</code> to return the file to this
position.

   <p>In the current implementation, <code>fgetpos</code> simply uses a character
count to represent the file position; this is the same number that
would be returned by <code>ftell</code>.

   <p><br>
<strong>Returns</strong><br>
<code>fgetpos</code> returns <code>0</code> when successful.  If <code>fgetpos</code> fails, the
result is <code>1</code>.  Failure occurs on streams that do not support
positioning; the global <code>errno</code> indicates this condition with the
value <code>ESPIPE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fgetpos</code> is required by the ANSI C standard, but the meaning of the
value it records is not specified beyond requiring that it be
acceptable as an argument to <code>fsetpos</code>.  In particular, other
conforming C implementations may return a different result from
<code>ftell</code> than what <code>fgetpos</code> writes at <code>*</code><var>pos</var>.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fgets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgetwc">fgetwc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgetpos">fgetpos</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.12 <code>fgets</code>&mdash;get character string from a file or stream</h3>

<p><a name="index-fgets-168"></a><a name="index-g_t_005ffgets_005fr-169"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     char *fgets(char *<var>buf</var>, int <var>n</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     char *_fgets_r(struct _reent *<var>ptr</var>, char *<var>buf</var>, int <var>n</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Reads at most <var>n-1</var> characters from <var>fp</var> until a newline
is found. The characters including to the newline are stored
in <var>buf</var>. The buffer is terminated with a 0.

   <p>The <code>_fgets_r</code> function is simply the reentrant version of
<code>fgets</code> and is passed an additional reentrancy structure
pointer: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
<code>fgets</code> returns the buffer passed to it, with the data
filled in. If end of file occurs with some data already
accumulated, the data is returned with no other indication. If
no data are read, NULL is returned instead.

   <p><br>
<strong>Portability</strong><br>
<code>fgets</code> should replace all uses of <code>gets</code>. Note however
that <code>fgets</code> returns all of the data, while <code>gets</code> removes
the trailing newline (with no indication that it has done so.)

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fgetwc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgetws">fgetws</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgets">fgets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.13 <code>fgetwc</code>, <code>getwc</code>&mdash;get a wide character from a file or stream</h3>

<p><a name="index-fgetwc-170"></a><a name="index-g_t_005ffgetwc_005fr-171"></a><a name="index-getwc-172"></a><a name="index-g_t_005fgetwc_005fr-173"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t fgetwc(FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t _fgetwc_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t getwc(FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t _getwc_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>fgetwc</code> to get the next wide character from the file or stream
identified by <var>fp</var>.  As a side effect, <code>fgetwc</code> advances the file's
current position indicator.

   <p>The  <code>getwc</code>  function  or macro functions identically to <code>fgetwc</code>.  It
may be implemented as a macro, and may evaluate its argument more  than
once. There is no reason ever to use it.

   <p><code>_fgetwc_r</code> and <code>_getwc_r</code> are simply reentrant versions of
<code>fgetwc</code> and <code>getwc</code> that are passed the additional reentrant
structure pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
The next wide character cast to <code>wint_t</code>), unless there is no more data,
or the host system reports a read error; in either of these situations,
<code>fgetwc</code> and <code>getwc</code> return <code>WEOF</code>.

   <p>You can distinguish the two situations that cause an <code>EOF</code> result by
using the <code>ferror</code> and <code>feof</code> functions.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX.1-2001

   <p><br>

<div class="node">
<a name="fgetws"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fileno">fileno</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgetwc">fgetwc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.14 <code>fgetws</code>&mdash;get wide character string from a file or stream</h3>

<p><a name="index-fgetws-174"></a><a name="index-g_t_005ffgetws_005fr-175"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *fgetws(wchar_t *<var>ws</var>, int <var>n</var>, FILE *<var>fp</var>);

     #include &lt;wchar.h&gt;
     wchar_t *_fgetws_r(struct _reent *<var>ptr</var>, wchar_t *<var>ws</var>, int <var>n</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Reads at most <var>n-1</var> wide characters from <var>fp</var> until a newline
is found. The wide characters including to the newline are stored
in <var>ws</var>. The buffer is terminated with a 0.

   <p>The <code>_fgetws_r</code> function is simply the reentrant version of
<code>fgetws</code> and is passed an additional reentrancy structure
pointer: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
<code>fgetws</code> returns the buffer passed to it, with the data
filled in. If end of file occurs with some data already
accumulated, the data is returned with no other indication. If
no data are read, NULL is returned instead.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX.1-2001

   <p><br>

<div class="node">
<a name="fileno"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fmemopen">fmemopen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgetws">fgetws</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.15 <code>fileno</code>&mdash;return file descriptor associated with stream</h3>

<p><a name="index-fileno-176"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fileno(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
You can use <code>fileno</code> to return the file descriptor identified by <var>fp</var>.

   <p><br>
<strong>Returns</strong><br>
<code>fileno</code> returns a non-negative integer when successful.
If <var>fp</var> is not an open stream, <code>fileno</code> returns -1.

   <p><br>
<strong>Portability</strong><br>
<code>fileno</code> is not part of ANSI C.
POSIX requires <code>fileno</code>.

   <p>Supporting OS subroutines required: none.

   <p><br>

<div class="node">
<a name="fmemopen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fopen">fopen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fileno">fileno</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.16 <code>fmemopen</code>&mdash;open a stream around a fixed-length string</h3>

<p><a name="index-fmemopen-177"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *fmemopen(void *restrict <var>buf</var>, size_t <var>size</var>,
         const char *restrict <var>mode</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fmemopen</code> creates a seekable <code>FILE</code> stream that wraps a
fixed-length buffer of <var>size</var> bytes starting at <var>buf</var>.  The stream
is opened with <var>mode</var> treated as in <code>fopen</code>, where append mode
starts writing at the first NUL byte.  If <var>buf</var> is NULL, then
<var>size</var> bytes are automatically provided as if by <code>malloc</code>, with
the initial size of 0, and <var>mode</var> must contain <code>+</code> so that data
can be read after it is written.

   <p>The stream maintains a current position, which moves according to
bytes read or written, and which can be one past the end of the array.
The stream also maintains a current file size, which is never greater
than <var>size</var>.  If <var>mode</var> starts with <code>r</code>, the position starts at
<code>0</code>, and file size starts at <var>size</var> if <var>buf</var> was provided.  If
<var>mode</var> starts with <code>w</code>, the position and file size start at <code>0</code>,
and if <var>buf</var> was provided, the first byte is set to NUL.  If
<var>mode</var> starts with <code>a</code>, the position and file size start at the
location of the first NUL byte, or else <var>size</var> if <var>buf</var> was
provided.

   <p>When reading, NUL bytes have no significance, and reads cannot exceed
the current file size.  When writing, the file size can increase up to
<var>size</var> as needed, and NUL bytes may be embedded in the stream (see
<code>open_memstream</code> for an alternative that automatically enlarges the
buffer).  When the stream is flushed or closed after a write that
changed the file size, a NUL byte is written at the current position
if there is still room; if the stream is not also open for reading, a
NUL byte is additionally written at the last byte of <var>buf</var> when the
stream has exceeded <var>size</var>, so that a write-only <var>buf</var> is always
NUL-terminated when the stream is flushed or closed (and the initial
<var>size</var> should take this into account).  It is not possible to seek
outside the bounds of <var>size</var>.  A NUL byte written during a flush is
restored to its previous value when seeking elsewhere in the string.

   <p><br>
<strong>Returns</strong><br>
The return value is an open FILE pointer on success.  On error,
<code>NULL</code> is returned, and <code>errno</code> will be set to EINVAL if <var>size</var>
is zero or <var>mode</var> is invalid, ENOMEM if <var>buf</var> was NULL and memory
could not be allocated, or EMFILE if too many streams are already
open.

   <p><br>
<strong>Portability</strong><br>
This function is being added to POSIX 200x, but is not in POSIX 2001.

   <p>Supporting OS subroutines required: <code>sbrk</code>.

   <p><br>

<div class="node">
<a name="fopen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fopencookie">fopencookie</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fmemopen">fmemopen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.17 <code>fopen</code>&mdash;open a file</h3>

<p><a name="index-fopen-178"></a><a name="index-g_t_005ffopen_005fr-179"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *fopen(const char *<var>file</var>, const char *<var>mode</var>);

     FILE *_fopen_r(struct _reent *<var>reent</var>,
         const char *<var>file</var>, const char *<var>mode</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fopen</code> initializes the data structures needed to read or write a
file.  Specify the file's name as the string at <var>file</var>, and the kind
of access you need to the file with the string at <var>mode</var>.

   <p>The alternate function <code>_fopen_r</code> is a reentrant version.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p>Three fundamental kinds of access are available: read, write, and append.
<code>*</code><var>mode</var> must begin with one of the three characters `<code>r</code>',
`<code>w</code>', or `<code>a</code>', to select one of these:

     <dl>
<dt><code>r</code><dd>Open the file for reading; the operation will fail if the file does
not exist, or if the host system does not permit you to read it.

     <br><dt><code>w</code><dd>Open the file for writing <em>from the beginning</em> of the file:
effectively, this always creates a new file.  If the file whose name you
specified already existed, its old contents are discarded.

     <br><dt><code>a</code><dd>Open the file for appending data, that is writing from the end of
file.  When you open a file this way, all data always goes to the
current end of file; you cannot change this using <code>fseek</code>.
</dl>

   <p>Some host systems distinguish between &ldquo;binary&rdquo; and &ldquo;text&rdquo; files.
Such systems may perform data transformations on data written to, or
read from, files opened as &ldquo;text&rdquo;.
If your system is one of these, then you can append a `<code>b</code>' to any
of the three modes above, to specify that you are opening the file as
a binary file (the default is to open the file as a text file).

   <p>`<code>rb</code>', then, means &ldquo;read binary&rdquo;; `<code>wb</code>', &ldquo;write binary&rdquo;; and
`<code>ab</code>', &ldquo;append binary&rdquo;.

   <p>To make C programs more portable, the `<code>b</code>' is accepted on all
systems, whether or not it makes a difference.

   <p>Finally, you might need to both read and write from the same file.
You can also append a `<code>+</code>' to any of the three modes, to permit
this.  (If you want to append both `<code>b</code>' and `<code>+</code>', you can do it
in either order: for example, <code>"rb+"</code> means the same thing as
<code>"r+b"</code> when used as a mode string.)

   <p>Use <code>"r+"</code> (or <code>"rb+"</code>) to permit reading and writing anywhere in
an existing file, without discarding any data; <code>"w+"</code> (or <code>"wb+"</code>)
to create a new file (or begin by discarding all data from an old one)
that permits reading and writing anywhere in it; and <code>"a+"</code> (or
<code>"ab+"</code>) to permit reading anywhere in an existing file, but writing
only at the end.

   <p><br>
<strong>Returns</strong><br>
<code>fopen</code> returns a file pointer which you can use for other file
operations, unless the file you requested could not be opened; in that
situation, the result is <code>NULL</code>.  If the reason for failure was an
invalid string at <var>mode</var>, <code>errno</code> is set to <code>EINVAL</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fopen</code> is required by ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>open</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fopencookie"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fpurge">fpurge</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fopen">fopen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.18 <code>fopencookie</code>&mdash;open a stream with custom callbacks</h3>

<p><a name="index-fopencookie-180"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *fopencookie(const void *<var>cookie</var>, const char *<var>mode</var>,
         cookie_io_functions_t <var>functions</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fopencookie</code> creates a <code>FILE</code> stream where I/O is performed using
custom callbacks.  The callbacks are registered via the structure:

   <p>typedef ssize_t (*cookie_read_function_t)(void *_cookie, char *_buf,
size_t _n);
typedef ssize_t (*cookie_write_function_t)(void *_cookie,
const char *_buf, size_t _n);
typedef int (*cookie_seek_function_t)(void *_cookie, off_t *_off,
int _whence);
typedef int (*cookie_close_function_t)(void *_cookie);

<pre class="smallexample">     	typedef struct
     	{
     		cookie_read_function_t	*read;
     		cookie_write_function_t *write;
     		cookie_seek_function_t	*seek;
     		cookie_close_function_t *close;
     	} cookie_io_functions_t;
</pre>
   <p>The stream is opened with <var>mode</var> treated as in <code>fopen</code>.  The
callbacks <var>functions.read</var> and <var>functions.write</var> may only be NULL
when <var>mode</var> does not require them.

   <p><var>functions.read</var> should return -1 on failure, or else the number of
bytes read (0 on EOF).  It is similar to <code>read</code>, except that
<var>cookie</var> will be passed as the first argument.

   <p><var>functions.write</var> should return -1 on failure, or else the number of
bytes written.  It is similar to <code>write</code>, except that <var>cookie</var>
will be passed as the first argument.

   <p><var>functions.seek</var> should return -1 on failure, and 0 on success, with
<var>_off</var> set to the current file position.  It is a cross between
<code>lseek</code> and <code>fseek</code>, with the <var>_whence</var> argument interpreted in
the same manner.  A NULL <var>functions.seek</var> makes the stream behave
similarly to a pipe in relation to stdio functions that require
positioning.

   <p><var>functions.close</var> should return -1 on failure, or 0 on success.  It
is similar to <code>close</code>, except that <var>cookie</var> will be passed as the
first argument.  A NULL <var>functions.close</var> merely flushes all data
then lets <code>fclose</code> succeed.  A failed close will still invalidate
the stream.

   <p>Read and write I/O functions are allowed to change the underlying
buffer on fully buffered or line buffered streams by calling
<code>setvbuf</code>.  They are also not required to completely fill or empty
the buffer.  They are not, however, allowed to change streams from
unbuffered to buffered or to change the state of the line buffering
flag.  They must also be prepared to have read or write calls occur on
buffers other than the one most recently specified.

   <p><br>
<strong>Returns</strong><br>
The return value is an open FILE pointer on success.  On error,
<code>NULL</code> is returned, and <code>errno</code> will be set to EINVAL if a
function pointer is missing or <var>mode</var> is invalid, ENOMEM if the
stream cannot be created, or EMFILE if too many streams are already
open.

   <p><br>
<strong>Portability</strong><br>
This function is a newlib extension, copying the prototype from Linux.
It is not portable.  See also the <code>funopen</code> interface from BSD.

   <p>Supporting OS subroutines required: <code>sbrk</code>.

   <p><br>

<div class="node">
<a name="fpurge"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fputc">fputc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fopencookie">fopencookie</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.19 <code>fpurge</code>&mdash;discard pending file I/O</h3>

<p><a name="index-fpurge-181"></a><a name="index-g_t_005ffpurge_005fr-182"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fpurge(FILE *<var>fp</var>);

     int _fpurge_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>fpurge</code> to clear all buffers of the given stream.  For output
streams, this discards data not yet written to disk.  For input streams,
this discards any data from <code>ungetc</code> and any data retrieved from disk
but not yet read via <code>getc</code>.  This is more severe than <code>fflush</code>,
and generally is only needed when manually altering the underlying file
descriptor of a stream.

   <p>The alternate function <code>_fpurge_r</code> is a reentrant version, where the
extra argument <var>reent</var> is a pointer to a reentrancy structure, and
<var>fp</var> must not be NULL.

   <p><br>
<strong>Returns</strong><br>
<code>fpurge</code> returns <code>0</code> unless <var>fp</var> is not valid, in which case it
returns <code>EOF</code> and sets <code>errno</code>.

   <p><br>
<strong>Portability</strong><br>
These functions are not portable to any standard.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fputc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fputs">fputs</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fpurge">fpurge</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.20 <code>fputc</code>&mdash;write a character on a stream or file</h3>

<p><a name="index-fputc-183"></a><a name="index-g_t_005ffputc_005fr-184"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fputc(int <var>ch</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _fputc_r(struct _rent *<var>ptr</var>, int <var>ch</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fputc</code> converts the argument <var>ch</var> from an <code>int</code> to an
<code>unsigned char</code>, then writes it to the file or stream identified by
<var>fp</var>.

   <p>If the file was opened with append mode (or if the stream cannot
support positioning), then the new character goes at the end of the
file or stream.  Otherwise, the new character is written at the
current value of the position indicator, and the position indicator
oadvances by one.

   <p>For a macro version of this function, see <code>putc</code>.

   <p>The <code>_fputc_r</code> function is simply a reentrant version of <code>fputc</code>
that takes an additional reentrant structure argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If successful, <code>fputc</code> returns its argument <var>ch</var>.  If an error
intervenes, the result is <code>EOF</code>.  You can use `<code>ferror(</code><var>fp</var><code>)</code>' to
query for errors.

   <p><br>
<strong>Portability</strong><br>
<code>fputc</code> is required by ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fputs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fputwc">fputwc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fputc">fputc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.21 <code>fputs</code>&mdash;write a character string in a file or stream</h3>

<p><a name="index-fputs-185"></a><a name="index-g_t_005ffputs_005fr-186"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fputs(const char *<var>s</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _fputs_r(struct _reent *<var>ptr</var>, const char *<var>s</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fputs</code> writes the string at <var>s</var> (but without the trailing null)
to the file or stream identified by <var>fp</var>.

   <p><code>_fputs_r</code> is simply the reentrant version of <code>fputs</code> that takes
an additional reentrant struct pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If successful, the result is <code>0</code>; otherwise, the result is <code>EOF</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fputs</code>, but does not specify that the result on
success must be <code>0</code>; any non-negative value is permitted.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fputwc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fputws">fputws</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fputs">fputs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.22 <code>fputwc</code>, <code>putwc</code>&mdash;write a wide character on a stream or file</h3>

<p><a name="index-fputwc-187"></a><a name="index-g_t_005ffputwc_005fr-188"></a><a name="index-putwc-189"></a><a name="index-g_t_005fputwc_005fr-190"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t fputwc(wchar_t <var>wc</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t _fputwc_r(struct _reent *<var>ptr</var>, wchar_t <var>wc</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t putwc(wchar_t <var>wc</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t _putwc_r(struct _reent *<var>ptr</var>, wchar_t <var>wc</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fputwc</code> writes the wide character argument <var>wc</var> to the file or
stream identified by <var>fp</var>.

   <p>If the file was opened with append mode (or if the stream cannot
support positioning), then the new wide character goes at the end of the
file or stream.  Otherwise, the new wide character is written at the
current value of the position indicator, and the position indicator
oadvances by one.

   <p>The <code>putwc</code> function or macro functions identically to <code>fputwc</code>.  It
may be implemented as a macro, and may evaluate its argument more than
once. There is no reason ever to use it.

   <p>The <code>_fputwc_r</code> and <code>_putwc_r</code> functions are simply reentrant versions
of <code>fputwc</code> and <code>putwc</code> that take an additional reentrant structure
argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If successful, <code>fputwc</code> and <code>putwc</code> return their argument <var>wc</var>.
If an error intervenes, the result is <code>EOF</code>.  You can use
`<code>ferror(</code><var>fp</var><code>)</code>' to query for errors.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX.1-2001

   <p><br>

<div class="node">
<a name="fputws"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fread">fread</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fputwc">fputwc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.23 <code>fputws</code>&mdash;write a wide character string in a file or stream</h3>

<p><a name="index-fputws-191"></a><a name="index-g_t_005ffputws_005fr-192"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int fputws(const wchar_t *<var>ws</var>, FILE *<var>fp</var>);

     #include &lt;wchar.h&gt;
     int _fputws_r(struct _reent *<var>ptr</var>, const wchar_t *<var>ws</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fputws</code> writes the wide character string at <var>ws</var> (but without the
trailing null) to the file or stream identified by <var>fp</var>.

   <p><code>_fputws_r</code> is simply the reentrant version of <code>fputws</code> that takes
an additional reentrant struct pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If successful, the result is a non-negative integer; otherwise, the result
is <code>-1</code> to indicate an error.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX.1-2001

   <p><br>

<div class="node">
<a name="fread"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#freopen">freopen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fputws">fputws</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.24 <code>fread</code>&mdash;read array elements from a file</h3>

<p><a name="index-fread-193"></a><a name="index-g_t_005ffread_005fr-194"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     size_t fread(void *<var>buf</var>, size_t <var>size</var>, size_t <var>count</var>,
         FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     size_t _fread_r(struct _reent *<var>ptr</var>, void *<var>buf</var>,
         size_t <var>size</var>, size_t <var>count</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fread</code> attempts to copy, from the file or stream identified by
<var>fp</var>, <var>count</var> elements (each of size <var>size</var>) into memory,
starting at <var>buf</var>.   <code>fread</code> may copy fewer elements than
<var>count</var> if an error, or end of file, intervenes.

   <p><code>fread</code> also advances the file position indicator (if any) for
<var>fp</var> by the number of <em>characters</em> actually read.

   <p><code>_fread_r</code> is simply the reentrant version of <code>fread</code> that
takes an additional reentrant structure pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
The result of <code>fread</code> is the number of elements it succeeded in
reading.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fread</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="freopen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fseek">fseek</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fread">fread</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.25 <code>freopen</code>&mdash;open a file using an existing file descriptor</h3>

<p><a name="index-freopen-195"></a><a name="index-g_t_005ffreopen_005fr-196"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *freopen(const char *<var>file</var>, const char *<var>mode</var>,
         FILE *<var>fp</var>);
     FILE *_freopen_r(struct _reent *<var>ptr</var>, const char *<var>file</var>,
         const char *<var>mode</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Use this variant of <code>fopen</code> if you wish to specify a particular file
descriptor <var>fp</var> (notably <code>stdin</code>, <code>stdout</code>, or <code>stderr</code>) for
the file.

   <p>If <var>fp</var> was associated with another file or stream, <code>freopen</code>
closes that other file or stream (but ignores any errors while closing
it).

   <p><var>file</var> and <var>mode</var> are used just as in <code>fopen</code>.

   <p>If <var>file</var> is <code>NULL</code>, the underlying stream is modified rather than
closed.  The file cannot be given a more permissive access mode (for
example, a <var>mode</var> of "w" will fail on a read-only file descriptor),
but can change status such as append or binary mode.  If modification
is not possible, failure occurs.

   <p><br>
<strong>Returns</strong><br>
If successful, the result is the same as the argument <var>fp</var>.  If the
file cannot be opened as specified, the result is <code>NULL</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>freopen</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>open</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fseek"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fsetpos">fsetpos</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#freopen">freopen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.26 <code>fseek</code>, <code>fseeko</code>&mdash;set file position</h3>

<p><a name="index-fseek-197"></a><a name="index-fseeko-198"></a><a name="index-g_t_005ffseek_005fr-199"></a><a name="index-g_t_005ffseeko_005fr-200"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fseek(FILE *<var>fp</var>, long <var>offset</var>, int <var>whence</var>)
     int fseeko(FILE *<var>fp</var>, off_t <var>offset</var>, int <var>whence</var>)
     int _fseek_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         long <var>offset</var>, int <var>whence</var>)
     int _fseeko_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         off_t <var>offset</var>, int <var>whence</var>)

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fseek</code>/<code>fseeko</code> to set the position for the file identified by
<var>fp</var>.  The value of <var>offset</var> determines the new position, in one
of three ways selected by the value of <var>whence</var> (defined as macros
in `<code>stdio.h</code>'):

   <p><code>SEEK_SET</code>&mdash;<var>offset</var> is the absolute file position (an offset
from the beginning of the file) desired.  <var>offset</var> must be positive.

   <p><code>SEEK_CUR</code>&mdash;<var>offset</var> is relative to the current file position.
<var>offset</var> can meaningfully be either positive or negative.

   <p><code>SEEK_END</code>&mdash;<var>offset</var> is relative to the current end of file.
<var>offset</var> can meaningfully be either positive (to increase the size
of the file) or negative.

   <p>See <code>ftell</code>/<code>ftello</code> to determine the current file position.

   <p><br>
<strong>Returns</strong><br>
<code>fseek</code>/<code>fseeko</code> return <code>0</code> when successful.  On failure, the
result is <code>EOF</code>.  The reason for failure is indicated in <code>errno</code>:
either <code>ESPIPE</code> (the stream identified by <var>fp</var> doesn't support
repositioning) or <code>EINVAL</code> (invalid file position).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fseek</code>.

   <p><code>fseeko</code> is defined by the Single Unix specification.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fsetpos"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ftell">ftell</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fseek">fseek</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.27 <code>fsetpos</code>&mdash;restore position of a stream or file</h3>

<p><a name="index-fsetpos-201"></a><a name="index-g_t_005ffsetpos_005fr-202"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fsetpos(FILE *<var>fp</var>, const fpos_t *<var>pos</var>);
     int _fsetpos_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         const fpos_t *<var>pos</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fsetpos</code> to return the file identified by <var>fp</var> to a previous
position <code>*</code><var>pos</var> (after first recording it with <code>fgetpos</code>).

   <p>See <code>fseek</code> for a similar facility.

   <p><br>
<strong>Returns</strong><br>
<code>fgetpos</code> returns <code>0</code> when successful.  If <code>fgetpos</code> fails, the
result is <code>1</code>.  The reason for failure is indicated in <code>errno</code>:
either <code>ESPIPE</code> (the stream identified by <var>fp</var> doesn't support
repositioning) or <code>EINVAL</code> (invalid file position).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fsetpos</code>, but does not specify the nature of
<code>*</code><var>pos</var> beyond identifying it as written by <code>fgetpos</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="ftell"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#funopen">funopen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fsetpos">fsetpos</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.28 <code>ftell</code>, <code>ftello</code>&mdash;return position in a stream or file</h3>

<p><a name="index-ftell-203"></a><a name="index-ftello-204"></a><a name="index-g_t_005fftell_005fr-205"></a><a name="index-g_t_005fftello_005fr-206"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     long ftell(FILE *<var>fp</var>);
     off_t ftello(FILE *<var>fp</var>);
     long _ftell_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);
     off_t _ftello_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>The result of <code>ftell</code>/<code>ftello</code> is the current position for a file
identified by <var>fp</var>.  If you record this result, you can later
use it with <code>fseek</code>/<code>fseeko</code> to return the file to this
position.  The difference between <code>ftell</code> and <code>ftello</code> is that
<code>ftell</code> returns <code>long</code> and <code>ftello</code> returns <code>off_t</code>.

   <p>In the current implementation, <code>ftell</code>/<code>ftello</code> simply uses a character
count to represent the file position; this is the same number that
would be recorded by <code>fgetpos</code>.

   <p><br>
<strong>Returns</strong><br>
<code>ftell</code>/<code>ftello</code> return the file position, if possible.  If they cannot do
this, they return <code>-1L</code>.  Failure occurs on streams that do not support
positioning; the global <code>errno</code> indicates this condition with the
value <code>ESPIPE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>ftell</code> is required by the ANSI C standard, but the meaning of its
result (when successful) is not specified beyond requiring that it be
acceptable as an argument to <code>fseek</code>.  In particular, other
conforming C implementations may return a different result from
<code>ftell</code> than what <code>fgetpos</code> records.

   <p><code>ftello</code> is defined by the Single Unix specification.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="funopen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fwide">fwide</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ftell">ftell</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.29 <code>funopen</code>, <code>fropen</code>, <code>fwopen</code>&mdash;open a stream with custom callbacks</h3>

<p><a name="index-funopen-207"></a><a name="index-fropen-208"></a><a name="index-fwopen-209"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *funopen(const void *<var>cookie</var>,
         int (*<var>readfn</var>) (void *cookie, char *buf, int n),
         int (*<var>writefn</var>) (void *cookie, const char *buf, int n),
         fpos_t (*<var>seekfn</var>) (void *cookie, fpos_t off, int whence),
         int (*<var>closefn</var>) (void *cookie));
     FILE *fropen(const void *<var>cookie</var>,
         int (*<var>readfn</var>) (void *cookie, char *buf, int n));
     FILE *fwopen(const void *<var>cookie</var>,
         int (*<var>writefn</var>) (void *cookie, const char *buf, int n));

</pre>
   <p><strong>Description</strong><br>
<code>funopen</code> creates a <code>FILE</code> stream where I/O is performed using
custom callbacks.  At least one of <var>readfn</var> and <var>writefn</var> must be
provided, which determines whether the stream behaves with mode &lt;"r"&gt;,
&lt;"w"&gt;, or &lt;"r+"&gt;.

   <p><var>readfn</var> should return -1 on failure, or else the number of bytes
read (0 on EOF).  It is similar to <code>read</code>, except that &lt;int&gt; rather
than &lt;size_t&gt; bounds a transaction size, and <var>cookie</var> will be passed
as the first argument.  A NULL <var>readfn</var> makes attempts to read the
stream fail.

   <p><var>writefn</var> should return -1 on failure, or else the number of bytes
written.  It is similar to <code>write</code>, except that &lt;int&gt; rather than
&lt;size_t&gt; bounds a transaction size, and <var>cookie</var> will be passed as
the first argument.  A NULL <var>writefn</var> makes attempts to write the
stream fail.

   <p><var>seekfn</var> should return (fpos_t)-1 on failure, or else the current
file position.  It is similar to <code>lseek</code>, except that <var>cookie</var>
will be passed as the first argument.  A NULL <var>seekfn</var> makes the
stream behave similarly to a pipe in relation to stdio functions that
require positioning.  This implementation assumes fpos_t and off_t are
the same type.

   <p><var>closefn</var> should return -1 on failure, or 0 on success.  It is
similar to <code>close</code>, except that <var>cookie</var> will be passed as the
first argument.  A NULL <var>closefn</var> merely flushes all data then lets
<code>fclose</code> succeed.  A failed close will still invalidate the stream.

   <p>Read and write I/O functions are allowed to change the underlying
buffer on fully buffered or line buffered streams by calling
<code>setvbuf</code>.  They are also not required to completely fill or empty
the buffer.  They are not, however, allowed to change streams from
unbuffered to buffered or to change the state of the line buffering
flag.  They must also be prepared to have read or write calls occur on
buffers other than the one most recently specified.

   <p>The functions <code>fropen</code> and <code>fwopen</code> are convenience macros around
<code>funopen</code> that only use the specified callback.

   <p><br>
<strong>Returns</strong><br>
The return value is an open FILE pointer on success.  On error,
<code>NULL</code> is returned, and <code>errno</code> will be set to EINVAL if a
function pointer is missing, ENOMEM if the stream cannot be created,
or EMFILE if too many streams are already open.

   <p><br>
<strong>Portability</strong><br>
This function is a newlib extension, copying the prototype from BSD.
It is not portable.  See also the <code>fopencookie</code> interface from Linux.

   <p>Supporting OS subroutines required: <code>sbrk</code>.

   <p><br>

<div class="node">
<a name="fwide"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fwrite">fwrite</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#funopen">funopen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.30 <code>fwide</code>&mdash;set and determine the orientation of a FILE stream</h3>

<p><a name="index-fwide-210"></a><a name="index-g_t_005ffwide_005fr-211"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int fwide(FILE *<var>fp</var>, int <var>mode</var>)

     int _fwide_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>, int <var>mode</var>)

</pre>
   <p><strong>Description</strong><br>
When <var>mode</var> is zero, the <code>fwide</code> function determines the current
orientation of <var>fp</var>. It returns a value &gt; 0 if <var>fp</var> is
wide-character oriented, i.e. if wide character I/O is permitted but
char I/O is disallowed. It returns a value &lt; 0 if <var>fp</var> is byte
oriented, i.e. if char I/O is permitted but wide character I/O is
disallowed. It returns zero if <var>fp</var> has no orientation yet; in
this case the next I/O operation might change the orientation (to byte
oriented if it is a char I/O operation, or to wide-character oriented
if it is a wide character I/O operation).

   <p>Once a stream has an orientation, it cannot be changed and persists
until the stream is closed, unless the stream is re-opened with freopen,
which removes the orientation of the stream.

   <p>When <var>mode</var> is non-zero, the <code>fwide</code> function first attempts to set
<var>fp</var>'s orientation (to wide-character oriented if <var>mode</var> &gt; 0, or to
byte oriented if <var>mode</var> &lt; 0). It then returns a value denoting the
current orientation, as above.

   <p><br>
<strong>Returns</strong><br>
The <code>fwide</code> function returns <var>fp</var>'s orientation, after possibly
changing it. A return value &gt; 0 means wide-character oriented. A return
value &lt; 0 means byte oriented. A return value of zero means undecided.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX.1-2001.

   <p><br>

<div class="node">
<a name="fwrite"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getc">getc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fwide">fwide</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.31 <code>fwrite</code>&mdash;write array elements</h3>

<p><a name="index-fwrite-212"></a><a name="index-g_t_005ffwrite_005fr-213"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     size_t fwrite(const void *<var>buf</var>, size_t <var>size</var>,
         size_t <var>count</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     size_t _fwrite_r(struct _reent *<var>ptr</var>, const void *<var>buf</var>, size_t <var>size</var>,
         size_t <var>count</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fwrite</code> attempts to copy, starting from the memory location
<var>buf</var>, <var>count</var> elements (each of size <var>size</var>) into the file or
stream identified by <var>fp</var>.  <code>fwrite</code> may copy fewer elements than
<var>count</var> if an error intervenes.

   <p><code>fwrite</code> also advances the file position indicator (if any) for
<var>fp</var> by the number of <em>characters</em> actually written.

   <p><code>_fwrite_r</code> is simply the reentrant version of <code>fwrite</code> that
takes an additional reentrant structure argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If <code>fwrite</code> succeeds in writing all the elements you specify, the
result is the same as the argument <var>count</var>.  In any event, the
result is the number of complete elements that <code>fwrite</code> copied to
the file.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>fwrite</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="getc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getc_005funlocked">getc_unlocked</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fwrite">fwrite</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.32 <code>getc</code>&mdash;read a character (macro)</h3>

<p><a name="index-getc-214"></a><a name="index-g_t_005fgetc_005fr-215"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getc(FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _getc_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getc</code> is a macro, defined in <code>stdio.h</code>.  You can use <code>getc</code>
to get the next single character from the file or stream
identified by <var>fp</var>.  As a side effect, <code>getc</code> advances the file's
current position indicator.

   <p>For a subroutine version of this macro, see <code>fgetc</code>.

   <p>The <code>_getc_r</code> function is simply the reentrant version of <code>getc</code>
which passes an additional reentrancy structure pointer argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
The next character (read as an <code>unsigned char</code>, and cast to
<code>int</code>), unless there is no more data, or the host system reports a
read error; in either of these situations, <code>getc</code> returns <code>EOF</code>.

   <p>You can distinguish the two situations that cause an <code>EOF</code> result by
using the <code>ferror</code> and <code>feof</code> functions.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>getc</code>; it suggests, but does not require, that
<code>getc</code> be implemented as a macro.  The standard explicitly permits
macro implementations of <code>getc</code> to use the argument more than once;
therefore, in a portable program, you should not use an expression
with side effects as the <code>getc</code> argument.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="getc_unlocked"></a>
<a name="getc_005funlocked"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getchar">getchar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getc">getc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.33 <code>getc_unlocked</code>&mdash;non-thread-safe version of getc (macro)</h3>

<p><a name="index-getc_005funlocked-216"></a><a name="index-g_t_005fgetc_005funlocked_005fr-217"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getc_unlocked(FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _getc_unlocked_r(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getc_unlocked</code> is a non-thread-safe version of <code>getc</code> declared in
<code>stdio.h</code>.  <code>getc_unlocked</code> may only safely be used within a scope
protected by flockfile() (or ftrylockfile()) and funlockfile().  These
functions may safely be used in a multi-threaded program if and only
if they are called while the invoking thread owns the ( FILE *)
object, as is the case after a successful call to the flockfile() or
ftrylockfile() functions.  If threads are disabled, then
<code>getc_unlocked</code> is equivalent to <code>getc</code>.

   <p>The <code>_getc_unlocked_r</code> function is simply the reentrant version of
<code>get_unlocked</code> which passes an additional reentrancy structure pointer
argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
See <code>getc</code>.

   <p><br>
<strong>Portability</strong><br>
POSIX 1003.1 requires <code>getc_unlocked</code>.  <code>getc_unlocked</code> may be
implemented as a macro, so arguments should not have side-effects.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.
<br>

<div class="node">
<a name="getchar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getchar_005funlocked">getchar_unlocked</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getc_005funlocked">getc_unlocked</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.34 <code>getchar</code>&mdash;read a character (macro)</h3>

<p><a name="index-getchar-218"></a><a name="index-g_t_005fgetchar_005fr-219"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getchar(void);

     int _getchar_r(struct _reent *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getchar</code> is a macro, defined in <code>stdio.h</code>.  You can use <code>getchar</code>
to get the next single character from the standard input stream.
As a side effect, <code>getchar</code> advances the standard input's
current position indicator.

   <p>The alternate function <code>_getchar_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The next character (read as an <code>unsigned char</code>, and cast to
<code>int</code>), unless there is no more data, or the host system reports a
read error; in either of these situations, <code>getchar</code> returns <code>EOF</code>.

   <p>You can distinguish the two situations that cause an <code>EOF</code> result by
using `<code>ferror(stdin)</code>' and `<code>feof(stdin)</code>'.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>getchar</code>; it suggests, but does not require, that
<code>getchar</code> be implemented as a macro.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="getchar_unlocked"></a>
<a name="getchar_005funlocked"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getdelim">getdelim</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getchar">getchar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.35 <code>getchar_unlocked</code>&mdash;non-thread-safe version of getchar (macro)</h3>

<p><a name="index-getchar_005funlocked-220"></a><a name="index-g_t_005fgetchar_005funlocked_005fr-221"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getchar_unlocked();

     #include &lt;stdio.h&gt;
     int _getchar_unlocked_r(struct _reent *<var>ptr</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getchar_unlocked</code> is a non-thread-safe version of <code>getchar</code>
declared in <code>stdio.h</code>.  <code>getchar_unlocked</code> may only safely be used
within a scope protected by flockfile() (or ftrylockfile()) and
funlockfile().  These functions may safely be used in a multi-threaded
program if and only if they are called while the invoking thread owns
the ( FILE *) object, as is the case after a successful call to the
flockfile() or ftrylockfile() functions.  If threads are disabled,
then <code>getchar_unlocked</code> is equivalent to <code>getchar</code>.

   <p>The <code>_getchar_unlocked_r</code> function is simply the reentrant version of
<code>getchar_unlocked</code> which passes an addtional reentrancy structure pointer
argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
See <code>getchar</code>.

   <p><br>
<strong>Portability</strong><br>
POSIX 1003.1 requires <code>getchar_unlocked</code>.  <code>getchar_unlocked</code> may
be implemented as a macro.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.
<br>

<div class="node">
<a name="getdelim"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getline">getline</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getchar_005funlocked">getchar_unlocked</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.36 <code>getdelim</code>&mdash;read a line up to a specified line delimiter</h3>

<p><a name="index-getdelim-222"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getdelim(char **<var>bufptr</var>, size_t *<var>n</var>,
         int <var>delim</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getdelim</code> reads a file <var>fp</var> up to and possibly including a specified
delimiter <var>delim</var>.  The line is read into a buffer pointed to
by <var>bufptr</var> and designated with size *<var>n</var>.  If the buffer is
not large enough, it will be dynamically grown by <code>getdelim</code>.
As the buffer is grown, the pointer to the size <var>n</var> will be
updated.

   <p><br>
<strong>Returns</strong><br>
<code>getdelim</code> returns <code>-1</code> if no characters were successfully read;
otherwise, it returns the number of bytes successfully read.
At end of file, the result is nonzero.

   <p><br>
<strong>Portability</strong><br>
<code>getdelim</code> is a glibc extension.

   <p>No supporting OS subroutines are directly required.

   <p><br>

<div class="node">
<a name="getline"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#gets">gets</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getdelim">getdelim</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.37 <code>getline</code>&mdash;read a line from a file</h3>

<p><a name="index-getline-223"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     ssize_t getline(char **<var>bufptr</var>, size_t *<var>n</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getline</code> reads a file <var>fp</var> up to and possibly including the
newline character.  The line is read into a buffer pointed to
by <var>bufptr</var> and designated with size *<var>n</var>.  If the buffer is
not large enough, it will be dynamically grown by <code>getdelim</code>.
As the buffer is grown, the pointer to the size <var>n</var> will be
updated.

   <p><code>getline</code> is equivalent to getdelim(bufptr, n, '\n', fp);

   <p><br>
<strong>Returns</strong><br>
<code>getline</code> returns <code>-1</code> if no characters were successfully read,
otherwise, it returns the number of bytes successfully read.
at end of file, the result is nonzero.

   <p><br>
<strong>Portability</strong><br>
<code>getline</code> is a glibc extension.

   <p>No supporting OS subroutines are directly required.

   <p><br>

<div class="node">
<a name="gets"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getw">getw</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getline">getline</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.38 <code>gets</code>&mdash;get character string (obsolete, use <code>fgets</code> instead)</h3>

<p><a name="index-gets-224"></a><a name="index-g_t_005fgets_005fr-225"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     char *gets(char *<var>buf</var>);

     char *_gets_r(struct _reent *<var>reent</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
Reads characters from standard input until a newline is found.
The characters up to the newline are stored in <var>buf</var>. The
newline is discarded, and the buffer is terminated with a 0.

   <p>This is a <em>dangerous</em> function, as it has no way of checking
the amount of space available in <var>buf</var>. One of the attacks
used by the Internet Worm of 1988 used this to overrun a
buffer allocated on the stack of the finger daemon and
overwrite the return address, causing the daemon to execute
code downloaded into it over the connection.

   <p>The alternate function <code>_gets_r</code> is a reentrant version.  The extra
argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>gets</code> returns the buffer passed to it, with the data filled
in. If end of file occurs with some data already accumulated,
the data is returned with no other indication. If end of file
occurs with no data in the buffer, NULL is returned.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="getw"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#getwchar">getwchar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#gets">gets</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.39 <code>getw</code>&mdash;read a word (int)</h3>

<p><a name="index-getw-226"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int getw(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getw</code> is a function, defined in <code>stdio.h</code>.  You can use <code>getw</code>
to get the next word from the file or stream identified by <var>fp</var>.  As
a side effect, <code>getw</code> advances the file's current position
indicator.

   <p><br>
<strong>Returns</strong><br>
The next word (read as an <code>int</code>), unless there is no more
data or the host system reports a read error; in either of these
situations, <code>getw</code> returns <code>EOF</code>.  Since <code>EOF</code> is a valid
<code>int</code>, you must use <code>ferror</code> or <code>feof</code> to distinguish these
situations.

   <p><br>
<strong>Portability</strong><br>
<code>getw</code> is a remnant of K&amp;R C; it is not part of any ISO C Standard.
<code>fread</code> should be used instead.  In fact, this implementation of
<code>getw</code> is based upon <code>fread</code>.

   <p>Supporting OS subroutines required: <code>fread</code>.
<br>

<div class="node">
<a name="getwchar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mktemp">mktemp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getw">getw</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.40 <code>getwchar</code>&mdash;read a wide character from standard input</h3>

<p><a name="index-getwchar-227"></a><a name="index-g_t_005fgetwchar_005fr-228"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wint_t getwchar(void);

     wint_t _getwchar_r(struct _reent *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
<code>getwchar</code> function or macro is the wide character equivalent of
the <code>getchar</code> function.  You can use <code>getwchar</code> to get the next
wide character from the standard input stream.  As a side effect,
<code>getwchar</code> advances the standard input's current position indicator.

   <p>The alternate function <code>_getwchar_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The next wide character cast to <code>wint_t</code>, unless there is no more
data, or the host system reports a read error; in either of these
situations, <code>getwchar</code> returns <code>WEOF</code>.

   <p>You can distinguish the two situations that cause an <code>WEOF</code> result by
using `<code>ferror(stdin)</code>' and `<code>feof(stdin)</code>'.

   <p><br>
<strong>Portability</strong><br>
C99

   <p><br>

<div class="node">
<a name="mktemp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#open_005fmemstream">open_memstream</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#getwchar">getwchar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.41 <code>mktemp</code>, <code>mkstemp</code>, <code>mkostemp</code>, <code>mkstemps</code>,</h3>

<p><a name="index-mktemp-229"></a><a name="index-mkdtemp-230"></a><a name="index-mkstemp-231"></a><a name="index-mkstemps-232"></a><a name="index-mkostemp-233"></a><a name="index-mkostemps-234"></a><a name="index-g_t_005fmktemp_005fr-235"></a><a name="index-g_t_005fmkdtemp_005fr-236"></a><a name="index-g_t_005fmkstemp_005fr-237"></a><a name="index-g_t_005fmkstemps_005fr-238"></a><a name="index-g_t_005fmkostemp_005fr-239"></a><a name="index-g_t_005fmkostemps_005fr-240"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdlib.h&gt;
     char *mktemp(char *<var>path</var>);
     char *mkdtemp(char *<var>path</var>);
     int mkstemp(char *<var>path</var>);
     int mkstemps(char *<var>path</var>, int <var>suffixlen</var>);
     int mkostemp(char *<var>path</var>, int <var>flags</var>);
     int mkostemps(char *<var>path</var>, int <var>suffixlen</var>, int <var>flags</var>);

     char *_mktemp_r(struct _reent *<var>reent</var>, char *<var>path</var>);
     char *_mkdtemp_r(struct _reent *<var>reent</var>, char *<var>path</var>);
     int *_mkstemp_r(struct _reent *<var>reent</var>, char *<var>path</var>);
     int *_mkstemps_r(struct _reent *<var>reent</var>, char *<var>path</var>, int <var>len</var>);
     int *_mkostemp_r(struct _reent *<var>reent</var>, char *<var>path</var>,
         int <var>flags</var>);
     int *_mkostemps_r(struct _reent *<var>reent</var>, char *<var>path</var>, int <var>len</var>,
         int <var>flags</var>);

</pre>
   <p><strong>Description</strong><br>
<code>mktemp</code>, <code>mkstemp</code>, and <code>mkstemps</code> attempt to generate a file name
that is not yet in use for any existing file.  <code>mkstemp</code> and <code>mkstemps</code>
create the file and open it for reading and writing; <code>mktemp</code> simply
generates the file name (making <code>mktemp</code> a security risk).  <code>mkostemp</code>
and <code>mkostemps</code> allow the addition of other <code>open</code> flags, such
as <code>O_CLOEXEC</code>, <code>O_APPEND</code>, or <code>O_SYNC</code>.  On platforms with a
separate text mode, <code>mkstemp</code> forces <code>O_BINARY</code>, while <code>mkostemp</code>
allows the choice between <code>O_BINARY</code>, <code>O_TEXT</code>, or 0 for default.
<code>mkdtemp</code> attempts to create a directory instead of a file, with a
permissions mask of 0700.

   <p>You supply a simple pattern for the generated file name, as the string
at <var>path</var>.  The pattern should be a valid filename (including path
information if you wish) ending with at least six `<code>X</code>'
characters.  The generated filename will match the leading part of the
name you supply, with the trailing `<code>X</code>' characters replaced by some
combination of digits and letters.  With <code>mkstemps</code>, the `<code>X</code>'
characters end <var>suffixlen</var> bytes before the end of the string.

   <p>The alternate functions <code>_mktemp_r</code>, <code>_mkdtemp_r</code>, <code>_mkstemp_r</code>,
<code>_mkostemp_r</code>, <code>_mkostemps_r</code>, and <code>_mkstemps_r</code> are reentrant
versions.  The extra argument <var>reent</var> is a pointer to a reentrancy
structure.

   <p><br>
<strong>Returns</strong><br>
<code>mktemp</code> returns the pointer <var>path</var> to the modified string
representing an unused filename, unless it could not generate one, or
the pattern you provided is not suitable for a filename; in that case,
it returns <code>NULL</code>.  Be aware that there is an inherent race between
generating the name and attempting to create a file by that name;
you are advised to use <code>O_EXCL|O_CREAT</code>.

   <p><code>mkdtemp</code> returns the pointer <var>path</var> to the modified string if the
directory was created, otherwise it returns <code>NULL</code>.

   <p><code>mkstemp</code>, <code>mkstemps</code>, <code>mkostemp</code>, and <code>mkostemps</code> return a file
descriptor to the newly created file, unless it could not generate an
unused filename, or the pattern you provided is not suitable for a
filename; in that case, it returns <code>-1</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C does not require either <code>mktemp</code> or <code>mkstemp</code>; the System
V Interface Definition requires <code>mktemp</code> as of Issue 2.  POSIX 2001
requires <code>mkstemp</code>, and POSIX 2008 requires <code>mkdtemp</code> while
deprecating <code>mktemp</code>.  <code>mkstemps</code>, <code>mkostemp</code>, and <code>mkostemps</code>
are not standardized.

   <p>Supporting OS subroutines required: <code>getpid</code>, <code>mkdir</code>, <code>open</code>, <code>stat</code>.

   <p><br>

<div class="node">
<a name="open_memstream"></a>
<a name="open_005fmemstream"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#perror">perror</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mktemp">mktemp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.42 <code>open_memstream</code>, <code>open_wmemstream</code>&mdash;open a write stream around an arbitrary-length string</h3>

<p><a name="index-open_005fmemstream-241"></a><a name="index-open_005fwmemstream-242"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *open_memstream(char **restrict <var>buf</var>,
         size_t *restrict <var>size</var>);

     #include &lt;wchar.h&gt;
     FILE *open_wmemstream(wchar_t **restrict <var>buf</var>,
         size_t *restrict <var>size</var>);

</pre>
   <p><strong>Description</strong><br>
<code>open_memstream</code> creates a seekable, byte-oriented <code>FILE</code> stream that
wraps an arbitrary-length buffer, created as if by <code>malloc</code>.  The current
contents of *<var>buf</var> are ignored; this implementation uses *<var>size</var>
as a hint of the maximum size expected, but does not fail if the hint
was wrong.  The parameters <var>buf</var> and <var>size</var> are later stored
through following any call to <code>fflush</code> or <code>fclose</code>, set to the
current address and usable size of the allocated string; although
after fflush, the pointer is only valid until another stream operation
that results in a write.  Behavior is undefined if the user alters
either *<var>buf</var> or *<var>size</var> prior to <code>fclose</code>.

   <p><code>open_wmemstream</code> is like <code>open_memstream</code> just with the associated
stream being wide-oriented.  The size set in <var>size</var> in subsequent
operations is the number of wide characters.

   <p>The stream is write-only, since the user can directly read *<var>buf</var>
after a flush; see <code>fmemopen</code> for a way to wrap a string with a
readable stream.  The user is responsible for calling <code>free</code> on
the final *<var>buf</var> after <code>fclose</code>.

   <p>Any time the stream is flushed, a NUL byte is written at the current
position (but is not counted in the buffer length), so that the string
is always NUL-terminated after at most *<var>size</var> bytes (or wide characters
in case of <code>open_wmemstream</code>).  However, data previously written beyond
the current stream offset is not lost, and the NUL value written during a
flush is restored to its previous value when seeking elsewhere in the string.

   <p><br>
<strong>Returns</strong><br>
The return value is an open FILE pointer on success.  On error,
<code>NULL</code> is returned, and <code>errno</code> will be set to EINVAL if <var>buf</var>
or <var>size</var> is NULL, ENOMEM if memory could not be allocated, or
EMFILE if too many streams are already open.

   <p><br>
<strong>Portability</strong><br>
POSIX.1-2008

   <p>Supporting OS subroutines required: <code>sbrk</code>.

   <p><br>

<div class="node">
<a name="perror"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putc">putc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#open_005fmemstream">open_memstream</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.43 <code>perror</code>&mdash;print an error message on standard error</h3>

<p><a name="index-perror-243"></a><a name="index-g_t_005fperror_005fr-244"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void perror(char *<var>prefix</var>);

     void _perror_r(struct _reent *<var>reent</var>, char *<var>prefix</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>perror</code> to print (on standard error) an error message
corresponding to the current value of the global variable <code>errno</code>.
Unless you use <code>NULL</code> as the value of the argument <var>prefix</var>, the
error message will begin with the string at <var>prefix</var>, followed by a
colon and a space (<code>: </code>). The remainder of the error message is one
of the strings described for <code>strerror</code>.

   <p>The alternate function <code>_perror_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>perror</code> returns no result.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>perror</code>, but the strings issued vary from one
implementation to another.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="putc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putc_005funlocked">putc_unlocked</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#perror">perror</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.44 <code>putc</code>&mdash;write a character (macro)</h3>

<p><a name="index-putc-245"></a><a name="index-g_t_005fputc_005fr-246"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int putc(int <var>ch</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _putc_r(struct _reent *<var>ptr</var>, int <var>ch</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>putc</code> is a macro, defined in <code>stdio.h</code>.  <code>putc</code>
writes the argument <var>ch</var> to the file or stream identified by
<var>fp</var>, after converting it from an <code>int</code> to an <code>unsigned char</code>.

   <p>If the file was opened with append mode (or if the stream cannot
support positioning), then the new character goes at the end of the
file or stream.  Otherwise, the new character is written at the
current value of the position indicator, and the position indicator
advances by one.

   <p>For a subroutine version of this macro, see <code>fputc</code>.

   <p>The <code>_putc_r</code> function is simply the reentrant version of
<code>putc</code> that takes an additional reentrant structure argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
If successful, <code>putc</code> returns its argument <var>ch</var>.  If an error
intervenes, the result is <code>EOF</code>.  You can use `<code>ferror(</code><var>fp</var><code>)</code>' to
query for errors.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>putc</code>; it suggests, but does not require, that
<code>putc</code> be implemented as a macro.  The standard explicitly permits
macro implementations of <code>putc</code> to use the <var>fp</var> argument more than once;
therefore, in a portable program, you should not use an expression
with side effects as this argument.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="putc_unlocked"></a>
<a name="putc_005funlocked"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putchar">putchar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putc">putc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.45 <code>putc_unlocked</code>&mdash;non-thread-safe version of putc (macro)</h3>

<p><a name="index-putc_005funlocked-247"></a><a name="index-g_t_005fputc_005funlocked_005fr-248"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int putc_unlocked(int <var>ch</var>, FILE *<var>fp</var>);

     #include &lt;stdio.h&gt;
     int _putc_unlocked_r(struct _reent *<var>ptr</var>, int <var>ch</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>putc_unlocked</code> is a non-thread-safe version of <code>putc</code> declared in
<code>stdio.h</code>.  <code>putc_unlocked</code> may only safely be used within a scope
protected by flockfile() (or ftrylockfile()) and funlockfile().  These
functions may safely be used in a multi-threaded program if and only
if they are called while the invoking thread owns the ( FILE *)
object, as is the case after a successful call to the flockfile() or
ftrylockfile() functions.  If threads are disabled, then
<code>putc_unlocked</code> is equivalent to <code>putc</code>.

   <p>The function <code>_putc_unlocked_r</code> is simply the reentrant version of
<code>putc_unlocked</code> that takes an additional reentrant structure pointer
argument: <var>ptr</var>.

   <p><br>
<strong>Returns</strong><br>
See <code>putc</code>.

   <p><br>
<strong>Portability</strong><br>
POSIX 1003.1 requires <code>putc_unlocked</code>.  <code>putc_unlocked</code> may be
implemented as a macro, so arguments should not have side-effects.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="putchar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putchar_005funlocked">putchar_unlocked</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putc_005funlocked">putc_unlocked</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.46 <code>putchar</code>&mdash;write a character (macro)</h3>

<p><a name="index-putchar-249"></a><a name="index-g_t_005fputchar_005fr-250"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int putchar(int <var>ch</var>);

     int _putchar_r(struct _reent *<var>reent</var>, int <var>ch</var>);

</pre>
   <p><strong>Description</strong><br>
<code>putchar</code> is a macro, defined in <code>stdio.h</code>.  <code>putchar</code>
writes its argument to the standard output stream,
after converting it from an <code>int</code> to an <code>unsigned char</code>.

   <p>The alternate function <code>_putchar_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
If successful, <code>putchar</code> returns its argument <var>ch</var>.  If an error
intervenes, the result is <code>EOF</code>.  You can use `<code>ferror(stdin)</code>' to
query for errors.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>putchar</code>; it suggests, but does not require, that
<code>putchar</code> be implemented as a macro.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="putchar_unlocked"></a>
<a name="putchar_005funlocked"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#puts">puts</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putchar">putchar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.47 <code>putchar_unlocked</code>&mdash;non-thread-safe version of putchar (macro)</h3>

<p><a name="index-putchar_005funlocked-251"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int putchar_unlocked(int <var>ch</var>);

</pre>
   <p><strong>Description</strong><br>
<code>putchar_unlocked</code> is a non-thread-safe version of <code>putchar</code>
declared in <code>stdio.h</code>.  <code>putchar_unlocked</code> may only safely be used
within a scope protected by flockfile() (or ftrylockfile()) and
funlockfile().  These functions may safely be used in a multi-threaded
program if and only if they are called while the invoking thread owns
the ( FILE *) object, as is the case after a successful call to the
flockfile() or ftrylockfile() functions.  If threads are disabled,
then <code>putchar_unlocked</code> is equivalent to <code>putchar</code>.

   <p><br>
<strong>Returns</strong><br>
See <code>putchar</code>.

   <p><br>
<strong>Portability</strong><br>
POSIX 1003.1 requires <code>putchar_unlocked</code>.  <code>putchar_unlocked</code> may
be implemented as a macro.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.
<br>

<div class="node">
<a name="puts"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putw">putw</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putchar_005funlocked">putchar_unlocked</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.48 <code>puts</code>&mdash;write a character string</h3>

<p><a name="index-puts-252"></a><a name="index-g_t_005fputs_005fr-253"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int puts(const char *<var>s</var>);

     int _puts_r(struct _reent *<var>reent</var>, const char *<var>s</var>);

</pre>
   <p><strong>Description</strong><br>
<code>puts</code> writes the string at <var>s</var> (followed by a newline, instead of
the trailing null) to the standard output stream.

   <p>The alternate function <code>_puts_r</code> is a reentrant version.  The extra
argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
If successful, the result is a nonnegative integer; otherwise, the
result is <code>EOF</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>puts</code>, but does not specify that the result on
success must be <code>0</code>; any non-negative value is permitted.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="putw"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#putwchar">putwchar</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#puts">puts</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.49 <code>putw</code>&mdash;write a word (int)</h3>

<p><a name="index-putw-254"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int putw(int <var>w</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>putw</code> is a function, defined in <code>stdio.h</code>.  You can use <code>putw</code>
to write a word to the file or stream identified by <var>fp</var>.  As a side
effect, <code>putw</code> advances the file's current position indicator.

   <p><br>
<strong>Returns</strong><br>
Zero on success, <code>EOF</code> on failure.

   <p><br>
<strong>Portability</strong><br>
<code>putw</code> is a remnant of K&amp;R C; it is not part of any ISO C Standard.
<code>fwrite</code> should be used instead.  In fact, this implementation of
<code>putw</code> is based upon <code>fwrite</code>.

   <p>Supporting OS subroutines required: <code>fwrite</code>.

   <p><br>

<div class="node">
<a name="putwchar"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#remove">remove</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putw">putw</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.50 <code>putwchar</code>&mdash;write a wide character to standard output</h3>

<p><a name="index-putwchar-255"></a><a name="index-g_t_005fputwchar_005fr-256"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wint_t putwchar(wchar_t <var>wc</var>);

     wint_t _putwchar_r(struct _reent *<var>reent</var>, wchar_t <var>wc</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>putwchar</code> function or macro is the wide-character equivalent of
the <code>putchar</code> function. It writes the wide character wc to stdout.

   <p>The alternate function <code>_putwchar_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
If successful, <code>putwchar</code> returns its argument <var>wc</var>.  If an error
intervenes, the result is <code>EOF</code>.  You can use `<code>ferror(stdin)</code>' to
query for errors.

   <p><br>
<strong>Portability</strong><br>
C99

   <p><br>

<div class="node">
<a name="remove"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#rename">rename</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#putwchar">putwchar</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.51 <code>remove</code>&mdash;delete a file's name</h3>

<p><a name="index-remove-257"></a><a name="index-g_t_005fremove_005fr-258"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int remove(char *<var>filename</var>);

     int _remove_r(struct _reent *<var>reent</var>, char *<var>filename</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>remove</code> to dissolve the association between a particular
filename (the string at <var>filename</var>) and the file it represents.
After calling <code>remove</code> with a particular filename, you will no
longer be able to open the file by that name.

   <p>In this implementation, you may use <code>remove</code> on an open file without
error; existing file descriptors for the file will continue to access
the file's data until the program using them closes the file.

   <p>The alternate function <code>_remove_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>remove</code> returns <code>0</code> if it succeeds, <code>-1</code> if it fails.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>remove</code>, but only specifies that the result on
failure be nonzero.  The behavior of <code>remove</code> when you call it on an
open file may vary among implementations.

   <p>Supporting OS subroutine required: <code>unlink</code>.

   <p><br>

<div class="node">
<a name="rename"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#rewind">rewind</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#remove">remove</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.52 <code>rename</code>&mdash;rename a file</h3>

<p><a name="index-rename-259"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int rename(const char *<var>old</var>, const char *<var>new</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>rename</code> to establish a new name (the string at <var>new</var>) for a
file now known by the string at <var>old</var>.  After a successful
<code>rename</code>, the file is no longer accessible by the string at <var>old</var>.

   <p>If <code>rename</code> fails, the file named <code>*</code><var>old</var> is unaffected.  The
conditions for failure depend on the host operating system.

   <p><br>
<strong>Returns</strong><br>
The result is either <code>0</code> (when successful) or <code>-1</code> (when the file
could not be renamed).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>rename</code>, but only specifies that the result on
failure be nonzero.  The effects of using the name of an existing file
as <code>*</code><var>new</var> may vary from one implementation to another.

   <p>Supporting OS subroutines required: <code>link</code>, <code>unlink</code>, or <code>rename</code>.

   <p><br>

<div class="node">
<a name="rewind"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#setbuf">setbuf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#rename">rename</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.53 <code>rewind</code>&mdash;reinitialize a file or stream</h3>

<p><a name="index-rewind-260"></a><a name="index-g_t_005frewind_005fr-261"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void rewind(FILE *<var>fp</var>);
     void _rewind_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>rewind</code> returns the file position indicator (if any) for the file
or stream identified by <var>fp</var> to the beginning of the file.  It also
clears any error indicator and flushes any pending output.

   <p><br>
<strong>Returns</strong><br>
<code>rewind</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>rewind</code>.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="setbuf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#setbuffer">setbuffer</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#rewind">rewind</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.54 <code>setbuf</code>&mdash;specify full buffering for a file or stream</h3>

<p><a name="index-setbuf-262"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void setbuf(FILE *<var>fp</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
<code>setbuf</code> specifies that output to the file or stream identified by <var>fp</var>
should be fully buffered.  All output for this file will go to a
buffer (of size <code>BUFSIZ</code>, specified in `<code>stdio.h</code>').  Output will
be passed on to the host system only when the buffer is full, or when
an input operation intervenes.

   <p>You may, if you wish, supply your own buffer by passing a pointer to
it as the argument <var>buf</var>.  It must have size <code>BUFSIZ</code>.  You can
also use <code>NULL</code> as the value of <var>buf</var>, to signal that the
<code>setbuf</code> function is to allocate the buffer.

   <p><br>
<strong>Warnings</strong><br>
You may only use <code>setbuf</code> before performing any file operation other
than opening the file.

   <p>If you supply a non-null <var>buf</var>, you must ensure that the associated
storage continues to be available until you close the stream
identified by <var>fp</var>.

   <p><br>
<strong>Returns</strong><br>
<code>setbuf</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
Both ANSI C and the System V Interface Definition (Issue 2) require
<code>setbuf</code>.  However, they differ on the meaning of a <code>NULL</code> buffer
pointer: the SVID issue 2 specification says that a <code>NULL</code> buffer
pointer requests unbuffered output.  For maximum portability, avoid
<code>NULL</code> buffer pointers.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="setbuffer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#setlinebuf">setlinebuf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#setbuf">setbuf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.55 <code>setbuffer</code>&mdash;specify full buffering for a file or stream with size</h3>

<p><a name="index-setbuffer-263"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void setbuffer(FILE *<var>fp</var>, char *<var>buf</var>, int <var>size</var>);

</pre>
   <p><strong>Description</strong><br>
<code>setbuffer</code> specifies that output to the file or stream identified by
<var>fp</var> should be fully buffered.  All output for this file will go to a
buffer (of size <var>size</var>).  Output will be passed on to the host system
only when the buffer is full, or when an input operation intervenes.

   <p>You may, if you wish, supply your own buffer by passing a pointer to
it as the argument <var>buf</var>.  It must have size <var>size</var>.  You can
also use <code>NULL</code> as the value of <var>buf</var>, to signal that the
<code>setbuffer</code> function is to allocate the buffer.

   <p><br>
<strong>Warnings</strong><br>
You may only use <code>setbuffer</code> before performing any file operation
other than opening the file.

   <p>If you supply a non-null <var>buf</var>, you must ensure that the associated
storage continues to be available until you close the stream
identified by <var>fp</var>.

   <p><br>
<strong>Returns</strong><br>
<code>setbuffer</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
This function comes from BSD not ANSI or POSIX.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="setlinebuf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#setvbuf">setvbuf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#setbuffer">setbuffer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.56 <code>setlinebuf</code>&mdash;specify line buffering for a file or stream</h3>

<p><a name="index-setlinebuf-264"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     void setlinebuf(FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>setlinebuf</code> specifies that output to the file or stream identified by
<var>fp</var> should be line buffered.  This causes the file or stream to pass
on output to the host system at every newline, as well as when the
buffer is full, or when an input operation intervenes.

   <p><br>
<strong>Warnings</strong><br>
You may only use <code>setlinebuf</code> before performing any file operation
other than opening the file.

   <p><br>
<strong>Returns</strong><br>
<code>setlinebuf</code> returns as per setvbuf.

   <p><br>
<strong>Portability</strong><br>
This function comes from BSD not ANSI or POSIX.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="setvbuf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#siprintf">siprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#setlinebuf">setlinebuf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.57 <code>setvbuf</code>&mdash;specify file or stream buffering</h3>

<p><a name="index-setvbuf-265"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int setvbuf(FILE *<var>fp</var>, char *<var>buf</var>,
         int <var>mode</var>, size_t <var>size</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>setvbuf</code> to specify what kind of buffering you want for the
file or stream identified by <var>fp</var>, by using one of the following
values (from <code>stdio.h</code>) as the <var>mode</var> argument:

     <dl>
<dt><code>_IONBF</code><dd>Do not use a buffer: send output directly to the host system for the
file or stream identified by <var>fp</var>.

     <br><dt><code>_IOFBF</code><dd>Use full output buffering: output will be passed on to the host system
only when the buffer is full, or when an input operation intervenes.

     <br><dt><code>_IOLBF</code><dd>Use line buffering: pass on output to the host system at every
newline, as well as when the buffer is full, or when an input
operation intervenes.
</dl>

   <p>Use the <var>size</var> argument to specify how large a buffer you wish.  You
can supply the buffer itself, if you wish, by passing a pointer to a
suitable area of memory as <var>buf</var>.  Otherwise, you may pass <code>NULL</code>
as the <var>buf</var> argument, and <code>setvbuf</code> will allocate the buffer.

   <p><br>
<strong>Warnings</strong><br>
You may only use <code>setvbuf</code> before performing any file operation other
than opening the file.

   <p>If you supply a non-null <var>buf</var>, you must ensure that the associated
storage continues to be available until you close the stream
identified by <var>fp</var>.

   <p><br>
<strong>Returns</strong><br>
A <code>0</code> result indicates success, <code>EOF</code> failure (invalid <var>mode</var> or
<var>size</var> can cause failure).

   <p><br>
<strong>Portability</strong><br>
Both ANSI C and the System V Interface Definition (Issue 2) require
<code>setvbuf</code>. However, they differ on the meaning of a <code>NULL</code> buffer
pointer: the SVID issue 2 specification says that a <code>NULL</code> buffer
pointer requests unbuffered output.  For maximum portability, avoid
<code>NULL</code> buffer pointers.

   <p>Both specifications describe the result on failure only as a
nonzero value.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="siprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#siscanf">siscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#setvbuf">setvbuf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.58 <code>siprintf</code>, <code>fiprintf</code>, <code>iprintf</code>, <code>sniprintf</code>, <code>asiprintf</code>, <code>asniprintf</code>&mdash;format output (integer only)</h3>

<p><a name="index-fiprintf-266"></a><a name="index-g_t_005ffiprintf_005fr-267"></a><a name="index-iprintf-268"></a><a name="index-g_t_005fiprintf_005fr-269"></a><a name="index-siprintf-270"></a><a name="index-g_t_005fsiprintf_005fr-271"></a><a name="index-sniprintf-272"></a><a name="index-g_t_005fsniprintf_005fr-273"></a><a name="index-asiprintf-274"></a><a name="index-g_t_005fasiprintf_005fr-275"></a><a name="index-asniprintf-276"></a><a name="index-g_t_005fasniprintf_005fr-277"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     int iprintf(const char *<var>format</var>, ...);
     int fiprintf(FILE *<var>fd</var>, const char *<var>format</var> , ...);
     int siprintf(char *<var>str</var>, const char *<var>format</var>, ...);
     int sniprintf(char *<var>str</var>, size_t <var>size</var>, const char *<var>format</var>,
         ...);
     int asiprintf(char **<var>strp</var>, const char *<var>format</var>, ...);
     char *asniprintf(char *<var>str</var>, size_t *<var>size</var>,
         const char *<var>format</var>, ...);

     int _iprintf_r(struct _reent *<var>ptr</var>, const char *<var>format</var>, ...);
     int _fiprintf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const char *<var>format</var>, ...);
     int _siprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>,
         const char *<var>format</var>, ...);
     int _sniprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>, size_t <var>size</var>,
         const char *<var>format</var>, ...);
     int _asiprintf_r(struct _reent *<var>ptr</var>, char **<var>strp</var>,
         const char *<var>format</var>, ...);
     char *_asniprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>,
         size_t *<var>size</var>, const char *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>iprintf</code>, <code>fiprintf</code>, <code>siprintf</code>, <code>sniprintf</code>,
<code>asiprintf</code>, and <code>asniprintf</code> are the same as <code>printf</code>,
<code>fprintf</code>, <code>sprintf</code>, <code>snprintf</code>, <code>asprintf</code>, and
<code>asnprintf</code>, respectively, except that they restrict usage
to non-floating-point format specifiers.

   <p><code>_iprintf_r</code>, <code>_fiprintf_r</code>, <code>_asiprintf_r</code>,
<code>_siprintf_r</code>, <code>_sniprintf_r</code>, <code>_asniprintf_r</code> are
simply reentrant versions of the functions above.

   <p><br>
<strong>Returns</strong><br>
Similar to <code>printf</code>, <code>fprintf</code>, <code>sprintf</code>, <code>snprintf</code>, <code>asprintf</code>,
and <code>asnprintf</code>.

   <p><br>
<strong>Portability</strong><br>
<code>iprintf</code>, <code>fiprintf</code>, <code>siprintf</code>, <code>sniprintf</code>, <code>asiprintf</code>,
and <code>asniprintf</code> are newlib extensions.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="siscanf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#sprintf">sprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#siprintf">siprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.59 <code>siscanf</code>, <code>fiscanf</code>, <code>iscanf</code>&mdash;scan and format non-floating input</h3>

<p><a name="index-iscanf-278"></a><a name="index-g_t_005fiscanf_005fr-279"></a><a name="index-fiscanf-280"></a><a name="index-g_t_005ffiscanf_005fr-281"></a><a name="index-siscanf-282"></a><a name="index-g_t_005fsiscanf_005fr-283"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     int iscanf(const char *<var>format</var>, ...);
     int fiscanf(FILE *<var>fd</var>, const char *<var>format</var>, ...);
     int siscanf(const char *<var>str</var>, const char *<var>format</var>, ...);

     int _iscanf_r(struct _reent *<var>ptr</var>, const char *<var>format</var>, ...);
     int _fiscanf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const char *<var>format</var>, ...);
     int _siscanf_r(struct _reent *<var>ptr</var>, const char *<var>str</var>,
         const char *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>iscanf</code>, <code>fiscanf</code>, and <code>siscanf</code> are the same as
<code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code> respectively, only that
they restrict the available formats to non-floating-point
format specifiers.

   <p>The routines <code>_iscanf_r</code>, <code>_fiscanf_r</code>, and <code>_siscanf_r</code> are reentrant
versions of <code>iscanf</code>, <code>fiscanf</code>, and <code>siscanf</code> that take an additional
first argument pointing to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>iscanf</code> returns the number of input fields successfully
scanned, converted and stored; the return value does
not include scanned fields which were not stored.

   <p>If <code>iscanf</code> attempts to read at end-of-file, the return
value is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p><br>
<strong>Portability</strong><br>
<code>iscanf</code>, <code>fiscanf</code>, and <code>siscanf</code> are newlib extensions.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="sprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#sscanf">sscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#siscanf">siscanf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.60 <code>sprintf</code>, <code>fprintf</code>, <code>printf</code>, <code>snprintf</code>, <code>asprintf</code>, <code>asnprintf</code>&mdash;format output</h3>

<p><a name="index-fprintf-284"></a><a name="index-g_t_005ffprintf_005fr-285"></a><a name="index-printf-286"></a><a name="index-g_t_005fprintf_005fr-287"></a><a name="index-asprintf-288"></a><a name="index-g_t_005fasprintf_005fr-289"></a><a name="index-sprintf-290"></a><a name="index-g_t_005fsprintf_005fr-291"></a><a name="index-snprintf-292"></a><a name="index-g_t_005fsnprintf_005fr-293"></a><a name="index-asnprintf-294"></a><a name="index-g_t_005fasnprintf_005fr-295"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     int printf(const char *<var>format</var>, ...);
     int fprintf(FILE *<var>fd</var>, const char *<var>format</var>, ...);
     int sprintf(char *<var>str</var>, const char *<var>format</var>, ...);
     int snprintf(char *<var>str</var>, size_t <var>size</var>, const char *<var>format</var>,
         ...);
     int asprintf(char **<var>strp</var>, const char *<var>format</var>, ...);
     char *asnprintf(char *<var>str</var>, size_t *<var>size</var>, const char *<var>format</var>,
         ...);

     int _printf_r(struct _reent *<var>ptr</var>, const char *<var>format</var>, ...);
     int _fprintf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const char *<var>format</var>, ...);
     int _sprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>,
         const char *<var>format</var>, ...);
     int _snprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>, size_t <var>size</var>,
         const char *<var>format</var>, ...);
     int _asprintf_r(struct _reent *<var>ptr</var>, char **<var>strp</var>,
         const char *<var>format</var>, ...);
     char *_asnprintf_r(struct _reent *<var>ptr</var>, char *<var>str</var>,
         size_t *<var>size</var>, const char *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>printf</code> accepts a series of arguments, applies to each a
format specifier from <code>*</code><var>format</var>, and writes the
formatted data to <code>stdout</code>, without a terminating NUL
character.  The behavior of <code>printf</code> is undefined if there
are not enough arguments for the format.  <code>printf</code> returns
when it reaches the end of the format string.  If there are
more arguments than the format requires, excess arguments are
ignored.

   <p><code>fprintf</code> is like <code>printf</code>, except that output is directed
to the stream <var>fd</var> rather than <code>stdout</code>.

   <p><code>sprintf</code> is like <code>printf</code>, except that output is directed
to the buffer <var>str</var>, and a terminating NUL is output.
Behavior is undefined if more output is generated than the
buffer can hold.

   <p><code>snprintf</code> is like <code>sprintf</code>, except that output is
limited to at most <var>size</var> bytes, including the terminating
<code>NUL</code>.  As a special case, if <var>size</var> is 0, <var>str</var> can be
NULL, and <code>snprintf</code> merely calculates how many bytes would
be printed.

   <p><code>asprintf</code> is like <code>sprintf</code>, except that the output is
stored in a dynamically allocated buffer, <var>pstr</var>, which
should be freed later with <code>free</code>.

   <p><code>asnprintf</code> is like <code>sprintf</code>, except that the return type
is either the original <var>str</var> if it was large enough, or a
dynamically allocated string if the output exceeds *<var>size</var>;
the length of the result is returned in *<var>size</var>.  When
dynamic allocation occurs, the contents of the original
<var>str</var> may have been modified.

   <p>For <code>sprintf</code>, <code>snprintf</code>, and <code>asnprintf</code>, the behavior
is undefined if the output <code>*</code><var>str</var> overlaps with one of
the arguments.  Behavior is also undefined if the argument for
<code>%n</code> within <code>*</code><var>format</var> overlaps another argument.

   <p><var>format</var> is a pointer to a character string containing two
types of objects: ordinary characters (other than <code>%</code>),
which are copied unchanged to the output, and conversion
specifications, each of which is introduced by <code>%</code>. (To
include <code>%</code> in the output, use <code>%%</code> in the format string.)
A conversion specification has the following form:

<pre class="smallexample">            %[<var>pos</var>][<var>flags</var>][<var>width</var>][.<var>prec</var>][<var>size</var>]<var>type</var>
</pre>
   <p>The fields of the conversion specification have the following
meanings:

     <ul>
<li><var>pos</var>

     <p>Conversions normally consume arguments in the order that they
are presented.  However, it is possible to consume arguments
out of order, and reuse an argument for more than one
conversion specification (although the behavior is undefined
if the same argument is requested with different types), by
specifying <var>pos</var>, which is a decimal integer followed by
'$'.  The integer must be between 1 and &lt;NL_ARGMAX&gt; from
limits.h, and if argument <code>%n$</code> is requested, all earlier
arguments must be requested somewhere within <var>format</var>.  If
positional parameters are used, then all conversion
specifications except for <code>%%</code> must specify a position.
This positional parameters method is a POSIX extension to the C
standard definition for the functions.

     <li><var>flags</var>

     <p><var>flags</var> is an optional sequence of characters which control
output justification, numeric signs, decimal points, trailing
zeros, and octal and hex prefixes.  The flag characters are
minus (<code>-</code>), plus (<code>+</code>), space ( ), zero (<code>0</code>), sharp
(<code>#</code>), and quote (<code>'</code>).  They can appear in any
combination, although not all flags can be used for all
conversion specification types.

          <dl>
<dt><code>'</code><dd>A POSIX extension to the C standard.  However, this
implementation presently treats it as a no-op, which
is the default behavior for the C locale, anyway.  (If
it did what it is supposed to, when <var>type</var> were <code>i</code>,
<code>d</code>, <code>u</code>, <code>f</code>, <code>F</code>, <code>g</code>, or <code>G</code>, the
integer portion of the conversion would be formatted
with thousands' grouping wide characters.)

          <br><dt><code>-</code><dd>The result of the conversion is left
justified, and the right is padded with
blanks.  If you do not use this flag, the
result is right justified, and padded on the
left.

          <br><dt><code>+</code><dd>The result of a signed conversion (as
determined by <var>type</var> of <code>d</code>, <code>i</code>, <code>a</code>,
<code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, or
<code>G</code>) will always begin with a plus or minus
sign.  (If you do not use this flag, positive
values do not begin with a plus sign.)

          <br><dt><code>" " (space)</code><dd>If the first character of a signed conversion
specification is not a sign, or if a signed
conversion results in no characters, the
result will begin with a space.  If the space
( ) flag and the plus (<code>+</code>) flag both
appear, the space flag is ignored.

          <br><dt><code>0</code><dd>If the <var>type</var> character is <code>d</code>, <code>i</code>,
<code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>, <code>a</code>, <code>A</code>,
<code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, or <code>G</code>:  leading
zeros are used to pad the field width
(following any indication of sign or base); no
spaces are used for padding.  If the zero
(<code>0</code>) and minus (<code>-</code>) flags both appear,
the zero (<code>0</code>) flag will be ignored.  For
<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, and <code>X</code>
conversions, if a precision <var>prec</var> is
specified, the zero (<code>0</code>) flag is ignored.

          <p>Note that <code>0</code> is interpreted as a flag, not
as the beginning of a field width.

          <br><dt><code>#</code><dd>The result is to be converted to an
alternative form, according to the <var>type</var>
character:

               <dl>
<dt><code>o</code><dd>Increases precision to force the first
digit of the result to be a zero.

               <br><dt><code>x</code><dd>A non-zero result will have a <code>0x</code>
prefix.

               <br><dt><code>X</code><dd>A non-zero result will have a <code>0X</code>
prefix.

               <br><dt><code>a, A, e, E, f, or F</code><dd>The result will always contain a
decimal point even if no digits follow
the point.  (Normally, a decimal point
appears only if a digit follows it.)
Trailing zeros are removed.

               <br><dt><code>g or G</code><dd>The result will always contain a
decimal point even if no digits follow
the point.  Trailing zeros are not
removed.

               <br><dt><code>all others</code><dd>Undefined.

          </dl>

     </dl>

     <li><var>width</var>

     <p><var>width</var> is an optional minimum field width.  You can
either specify it directly as a decimal integer, or
indirectly by using instead an asterisk (<code>*</code>), in
which case an <code>int</code> argument is used as the field
width.  If positional arguments are used, then the
width must also be specified positionally as <code>*m$</code>,
with m as a decimal integer.  Negative field widths
are treated as specifying the minus (<code>-</code>) flag for
left justfication, along with a positive field width.
The resulting format may be wider than the specified
width.

     <li><var>prec</var>

     <p><var>prec</var> is an optional field; if present, it is
introduced with `<code>.</code>' (a period). You can specify
the precision either directly as a decimal integer or
indirectly by using an asterisk (<code>*</code>), in which case
an <code>int</code> argument is used as the precision.  If
positional arguments are used, then the precision must
also be specified positionally as <code>*m$</code>, with m as a
decimal integer.  Supplying a negative precision is
equivalent to omitting the precision.  If only a
period is specified the precision is zero. The effect
depends on the conversion <var>type</var>.

          <dl>
<dt><code>d, i, o, u, x, or X</code><dd>Minimum number of digits to appear.  If no
precision is given, defaults to 1.

          <br><dt><code>a or A</code><dd>Number of digits to appear after the decimal
point.  If no precision is given, the
precision defaults to the minimum needed for
an exact representation.

          <br><dt><code>e, E, f or F</code><dd>Number of digits to appear after the decimal
point.  If no precision is given, the
precision defaults to 6.

          <br><dt><code>g or G</code><dd>Maximum number of significant digits.  A
precision of 0 is treated the same as a
precision of 1.  If no precision is given, the
precision defaults to 6.

          <br><dt><code>s or S</code><dd>Maximum number of characters to print from the
string.  If no precision is given, the entire
string is printed.

          <br><dt><code>all others</code><dd>undefined.

     </dl>

     <li><var>size</var>

     <p><var>size</var> is an optional modifier that changes the data
type that the corresponding argument has.  Behavior is
unspecified if a size is given that does not match the
<var>type</var>.

          <dl>
<dt><code>hh</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument should be
converted to a <code>signed char</code> or <code>unsigned
char</code> before printing.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>signed char</code>.

          <br><dt><code>h</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument should be
converted to a <code>short</code> or <code>unsigned short</code>
before printing.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>short</code>.

          <br><dt><code>l</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>long</code> or <code>unsigned long</code>.

          <p>With <code>c</code>, specifies that the argument has
type <code>wint_t</code>.

          <p>With <code>s</code>, specifies that the argument is a
pointer to <code>wchar_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>long</code>.

          <p>With <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>,
<code>g</code>, or <code>G</code>, has no effect (because of
vararg promotion rules, there is no need to
distinguish between <code>float</code> and <code>double</code>).

          <br><dt><code>ll</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>long long</code> or <code>unsigned long long</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>long long</code>.

          <br><dt><code>j</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is an
<code>intmax_t</code> or <code>uintmax_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to an <code>intmax_t</code>.

          <br><dt><code>z</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a <code>size_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>size_t</code>.

          <br><dt><code>t</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>ptrdiff_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>ptrdiff_t</code>.

          <br><dt><code>L</code><dd>With <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>,
<code>g</code>, or <code>G</code>, specifies that the argument
is a <code>long double</code>.

     </dl>

     <li><var>type</var>

     <p><var>type</var> specifies what kind of conversion <code>printf</code>
performs.  Here is a table of these:

          <dl>
<dt><code>%</code><dd>Prints the percent character (<code>%</code>).

          <br><dt><code>c</code><dd>Prints <var>arg</var> as single character.  If the
<code>l</code> size specifier is in effect, a multibyte
character is printed.

          <br><dt><code>C</code><dd>Short for <code>%lc</code>.  A POSIX extension to the C standard.

          <br><dt><code>s</code><dd>Prints the elements of a pointer to <code>char</code>
until the precision or a null character is
reached.  If the <code>l</code> size specifier is in
effect, the pointer is to an array of
<code>wchar_t</code>, and the string is converted to
multibyte characters before printing.

          <br><dt><code>S</code><dd>Short for <code>%ls</code>.  A POSIX extension to the C standard.

          <br><dt><code>d or i</code><dd>Prints a signed decimal integer; takes an
<code>int</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>D</code><dd>Newlib extension, short for <code>%ld</code>.

          <br><dt><code>o</code><dd>Prints an unsigned octal integer; takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>O</code><dd>Newlib extension, short for <code>%lo</code>.

          <br><dt><code>u</code><dd>Prints an unsigned decimal integer; takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>U</code><dd>Newlib extension, short for <code>%lu</code>.

          <br><dt><code>x</code><dd>Prints an unsigned hexadecimal integer (using
<code>abcdef</code> as digits beyond <code>9</code>); takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>X</code><dd>Like <code>x</code>, but uses <code>ABCDEF</code> as digits
beyond <code>9</code>.

          <br><dt><code>f</code><dd>Prints a signed value of the form
<code>[-]9999.9999</code>, with the precision
determining how many digits follow the decimal
point; takes a <code>double</code> (remember that
<code>float</code> promotes to <code>double</code> as a vararg).
The low order digit is rounded to even.  If
the precision results in at most DECIMAL_DIG
digits, the result is rounded correctly; if
more than DECIMAL_DIG digits are printed, the
result is only guaranteed to round back to the
original value.

          <p>If the value is infinite, the result is
<code>inf</code>, and no zero padding is performed.  If
the value is not a number, the result is
<code>nan</code>, and no zero padding is performed.

          <br><dt><code>F</code><dd>Like <code>f</code>, but uses <code>INF</code> and <code>NAN</code> for
non-finite numbers.

          <br><dt><code>e</code><dd>Prints a signed value of the form
<code>[-]9.9999e[+|-]999</code>; takes a <code>double</code>.
The digit before the decimal point is non-zero
if the value is non-zero.  The precision
determines how many digits appear between
<code>.</code> and <code>e</code>, and the exponent always
contains at least two digits.  The value zero
has an exponent of zero.  If the value is not
finite, it is printed like <code>f</code>.

          <br><dt><code>E</code><dd>Like <code>e</code>, but using <code>E</code> to introduce the
exponent, and like <code>F</code> for non-finite
values.

          <br><dt><code>g</code><dd>Prints a signed value in either <code>f</code> or <code>e</code>
form, based on the given value and
precision&mdash;an exponent less than -4 or
greater than the precision selects the <code>e</code>
form.  Trailing zeros and the decimal point
are printed only if necessary; takes a
<code>double</code>.

          <br><dt><code>G</code><dd>Like <code>g</code>, except use <code>F</code> or <code>E</code> form.

          <br><dt><code>a</code><dd>Prints a signed value of the form
<code>[-]0x1.ffffp[+|-]9</code>; takes a <code>double</code>.
The letters <code>abcdef</code> are used for digits
beyond <code>9</code>.  The precision determines how
many digits appear after the decimal point.
The exponent contains at least one digit, and
is a decimal value representing the power of
2; a value of 0 has an exponent of 0.
Non-finite values are printed like <code>f</code>.

          <br><dt><code>A</code><dd>Like <code>a</code>, except uses <code>X</code>, <code>P</code>, and
<code>ABCDEF</code> instead of lower case.

          <br><dt><code>n</code><dd>Takes a pointer to <code>int</code>, and stores a count
of the number of bytes written so far.  No
output is created.

          <br><dt><code>p</code><dd>Takes a pointer to <code>void</code>, and prints it in
an implementation-defined format.  This
implementation is similar to <code>%#tx</code>), except
that <code>0x</code> appears even for the NULL pointer.

     </dl>

   </ul>

   <p><code>_printf_r</code>, <code>_fprintf_r</code>, <code>_asprintf_r</code>,
<code>_sprintf_r</code>, <code>_snprintf_r</code>, <code>_asnprintf_r</code> are simply
reentrant versions of the functions above.

   <p><br>
<strong>Returns</strong><br>
On success, <code>sprintf</code> and <code>asprintf</code> return the number of bytes in
the output string, except the concluding <code>NUL</code> is not counted.
<code>snprintf</code> returns the number of bytes that would be in the output
string, except the concluding <code>NUL</code> is not counted.  <code>printf</code> and
<code>fprintf</code> return the number of characters transmitted.
<code>asnprintf</code> returns the original <var>str</var> if there was enough room,
otherwise it returns an allocated string.

   <p>If an error occurs, the result of <code>printf</code>, <code>fprintf</code>,
<code>snprintf</code>, and <code>asprintf</code> is a negative value, and the result of
<code>asnprintf</code> is NULL.  No error returns occur for <code>sprintf</code>.  For
<code>printf</code> and <code>fprintf</code>, <code>errno</code> may be set according to
<code>fputc</code>.  For <code>asprintf</code> and <code>asnprintf</code>, <code>errno</code> may be set
to ENOMEM if allocation fails, and for <code>snprintf</code>, <code>errno</code> may be
set to EOVERFLOW if <var>size</var> or the output length exceeds INT_MAX.

   <p><br>
<strong>Bugs</strong><br>
The &ldquo;&rdquo;' (quote) flag does not work when locale's thousands_sep is not empty.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>printf</code>, <code>fprintf</code>, <code>sprintf</code>, and
<code>snprintf</code>.  <code>asprintf</code> and <code>asnprintf</code> are newlib extensions.

   <p>The ANSI C standard specifies that implementations must support at
least formatted output of up to 509 characters.  This implementation
has no inherent limit.

   <p>Depending on how newlib was configured, not all format specifiers are
supported.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="sscanf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#swprintf">swprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#sprintf">sprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.61 <code>sscanf</code>, <code>fscanf</code>, <code>scanf</code>&mdash;scan and format input</h3>

<p><a name="index-scanf-296"></a><a name="index-g_t_005fscanf_005fr-297"></a><a name="index-fscanf-298"></a><a name="index-g_t_005ffscanf_005fr-299"></a><a name="index-sscanf-300"></a><a name="index-g_t_005fsscanf_005fr-301"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     int scanf(const char *<var>format</var>, ...);
     int fscanf(FILE *<var>fd</var>, const char *<var>format</var>, ...);
     int sscanf(const char *<var>str</var>, const char *<var>format</var>, ...);

     int _scanf_r(struct _reent *<var>ptr</var>, const char *<var>format</var>, ...);
     int _fscanf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const char *<var>format</var>, ...);
     int _sscanf_r(struct _reent *<var>ptr</var>, const char *<var>str</var>,
         const char *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>scanf</code> scans a series of input fields from standard input,
one character at a time.  Each field is interpreted according to
a format specifier passed to <code>scanf</code> in the format string at
<code>*</code><var>format</var>.  <code>scanf</code> stores the interpreted input from
each field at the address passed to it as the corresponding argument
following <var>format</var>.  You must supply the same number of
format specifiers and address arguments as there are input fields.

   <p>There must be sufficient address arguments for the given format
specifiers; if not the results are unpredictable and likely
disasterous.  Excess address arguments are merely ignored.

   <p><code>scanf</code> often produces unexpected results if the input diverges from
an expected pattern. Since the combination of <code>gets</code> or <code>fgets</code>
followed by <code>sscanf</code> is safe and easy, that is the preferred way
to be certain that a program is synchronized with input at the end
of a line.

   <p><code>fscanf</code> and <code>sscanf</code> are identical to <code>scanf</code>, other than the
source of input: <code>fscanf</code> reads from a file, and <code>sscanf</code>
from a string.

   <p>The routines <code>_scanf_r</code>, <code>_fscanf_r</code>, and <code>_sscanf_r</code> are reentrant
versions of <code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code> that take an additional
first argument pointing to a reentrancy structure.

   <p>The string at <code>*</code><var>format</var> is a character sequence composed
of zero or more directives. Directives are composed of
one or more whitespace characters, non-whitespace characters,
and format specifications.

   <p>Whitespace characters are blank ( ), tab (<code>\t</code>), or
newline (<code>\n</code>).
When <code>scanf</code> encounters a whitespace character in the format string
it will read (but not store) all consecutive whitespace characters
up to the next non-whitespace character in the input.

   <p>Non-whitespace characters are all other ASCII characters except the
percent sign (<code>%</code>).  When <code>scanf</code> encounters a non-whitespace
character in the format string it will read, but not store
a matching non-whitespace character.

   <p>Format specifications tell <code>scanf</code> to read and convert characters
from the input field into specific types of values, and store then
in the locations specified by the address arguments.

   <p>Trailing whitespace is left unread unless explicitly
matched in the format string.

   <p>The format specifiers must begin with a percent sign (<code>%</code>)
and have the following form:

<pre class="smallexample">            %[*][<var>width</var>][<var>size</var>]<var>type</var>
</pre>
   <p>Each format specification begins with the percent character (<code>%</code>).
The other fields are:
     <dl>
<dt><code>*</code><dd>an optional marker; if present, it suppresses interpretation and
assignment of this input field.

     <br><dt><var>width</var><dd>an optional maximum field width: a decimal integer,
which controls the maximum number of characters that
will be read before converting the current input field.  If the
input field has fewer than <var>width</var> characters, <code>scanf</code>
reads all the characters in the field, and then
proceeds with the next field and its format specification.

     <p>If a whitespace or a non-convertable character occurs
before <var>width</var> character are read, the characters up
to that character are read, converted, and stored.
Then <code>scanf</code> proceeds to the next format specification.

     <br><dt><code>size</code><dd><code>h</code>, <code>j</code>, <code>l</code>, <code>L</code>, <code>t</code>, and <code>z</code> are optional size
characters which override the default way that <code>scanf</code>
interprets the data type of the corresponding argument.

     <pre class="smallexample">          Modifier   Type(s)
             hh      d, i, o, u, x, n  convert input to char,
                                       store in char object

             h       d, i, o, u, x, n  convert input to short,
                                       store in short object

             h       D, I, O, U, X     no effect
                     e, f, c, s, p

             j       d, i, o, u, x, n  convert input to intmax_t,
                                       store in intmax_t object

             j       all others        no effect

             l       d, i, o, u, x, n  convert input to long,
                                       store in long object

             l       e, f, g           convert input to double
                                       store in a double object

             l       D, I, O, U, X     no effect
                     c, s, p

             ll      d, i, o, u, x, n  convert to long long,
                                       store in long long

             L       d, i, o, u, x, n  convert to long long,
                                       store in long long

             L       e, f, g, E, G     convert to long double,
                                       store in long double

             L       all others        no effect

             t       d, i, o, u, x, n  convert input to ptrdiff_t,
                                       store in ptrdiff_t object

             t       all others        no effect

             z       d, i, o, u, x, n  convert input to size_t,
                                       store in size_t object

             z       all others        no effect

</pre>
     <br><dt><var>type</var><dd>
A character to specify what kind of conversion
<code>scanf</code> performs.  Here is a table of the conversion
characters:

          <dl>
<dt><code>%</code><dd>No conversion is done; the percent character (<code>%</code>) is stored.

          <br><dt><code>c</code><dd>Scans one character.  Corresponding <var>arg</var>: <code>(char *arg)</code>.

          <br><dt><code>s</code><dd>Reads a character string into the array supplied.
Corresponding <var>arg</var>: <code>(char arg[])</code>.

          <br><dt><code>[</code><var>pattern</var><code>]</code><dd>Reads a non-empty character string into memory
starting at <var>arg</var>.  This area must be large
enough to accept the sequence and a
terminating null character which will be added
automatically.  (<var>pattern</var> is discussed in the paragraph following
this table). Corresponding <var>arg</var>: <code>(char *arg)</code>.

          <br><dt><code>d</code><dd>Reads a decimal integer into the corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>D</code><dd>Reads a decimal integer into the corresponding
<var>arg</var>: <code>(long *arg)</code>.

          <br><dt><code>o</code><dd>Reads an octal integer into the corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>O</code><dd>Reads an octal integer into the corresponding <var>arg</var>: <code>(long *arg)</code>.

          <br><dt><code>u</code><dd>Reads an unsigned decimal integer into the corresponding
<var>arg</var>: <code>(unsigned int *arg)</code>.
<br><dt><code>U</code><dd>Reads an unsigned decimal integer into the corresponding <var>arg</var>:
<code>(unsigned long *arg)</code>.

          <br><dt><code>x,X</code><dd>Read a hexadecimal integer into the corresponding <var>arg</var>:
<code>(int *arg)</code>.

          <br><dt><code>e, f, g</code><dd>Read a floating-point number into the corresponding <var>arg</var>:
<code>(float *arg)</code>.

          <br><dt><code>E, F, G</code><dd>Read a floating-point number into the corresponding <var>arg</var>:
<code>(double *arg)</code>.

          <br><dt><code>i</code><dd>Reads a decimal, octal or hexadecimal integer into the
corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>I</code><dd>Reads a decimal, octal or hexadecimal integer into the
corresponding <var>arg</var>: <code>(long *arg)</code>.

          <br><dt><code>n</code><dd>Stores the number of characters read in the corresponding
<var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>p</code><dd>Stores a scanned pointer.  ANSI C leaves the details
to each implementation; this implementation treats
<code>%p</code> exactly the same as <code>%U</code>.  Corresponding
<var>arg</var>: <code>(void **arg)</code>.
</dl>

     <p>A <var>pattern</var> of characters surrounded by square brackets can be used
instead of the <code>s</code> type character.  <var>pattern</var> is a set of
characters which define a search set of possible characters making up
the <code>scanf</code> input field.  If the first character in the brackets is a
caret (<code>^</code>), the search set is inverted to include all ASCII characters
except those between the brackets.  There is also a range facility
which you can use as a shortcut. <code>%[0-9] </code> matches all decimal digits.
The hyphen must not be the first or last character in the set.
The character prior to the hyphen must be lexically less than the
character after it.

     <p>Here are some <var>pattern</var> examples:
          <dl>
<dt><code>%[abcd]</code><dd>matches strings containing only <code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>.

          <br><dt><code>%[^abcd]</code><dd>matches strings containing any characters except <code>a</code>, <code>b</code>,
<code>c</code>, or <code>d</code>

          <br><dt><code>%[A-DW-Z]</code><dd>matches strings containing <code>A</code>, <code>B</code>, <code>C</code>, <code>D</code>, <code>W</code>,
<code>X</code>, <code>Y</code>, <code>Z</code>

          <br><dt><code>%[z-a]</code><dd>matches the characters  <code>z</code>, <code>-</code>, and <code>a</code>
</dl>

     <p>Floating point numbers (for field types <code>e</code>, <code>f</code>, <code>g</code>, <code>E</code>,
<code>F</code>, <code>G</code>) must correspond to the following general form:

     <pre class="smallexample">          		[+/-] ddddd[.]ddd [E|e[+|-]ddd]
</pre>
     <p>where objects inclosed in square brackets are optional, and <code>ddd</code>
represents decimal, octal, or hexadecimal digits.
</dl>

   <p><br>
<strong>Returns</strong><br>
<code>scanf</code> returns the number of input fields successfully
scanned, converted and stored; the return value does
not include scanned fields which were not stored.

   <p>If <code>scanf</code> attempts to read at end-of-file, the return
value is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p><code>scanf</code> might stop scanning a particular field before
reaching the normal field end character, or may
terminate entirely.

   <p><code>scanf</code> stops scanning and storing the current field
and moves to the next input field (if any)
in any of the following situations:

     <ul>
<li>The assignment suppressing character (<code>*</code>) appears
after the <code>%</code> in the format specification; the current
input field is scanned but not stored.

     <li><var>width</var> characters have been read (<var>width</var> is a
width specification, a positive decimal integer).

     <li>The next character read cannot be converted
under the the current format (for example,
if a <code>Z</code> is read when the format is decimal).

     <li>The next character in the input field does not appear
in the search set (or does appear in the inverted search set).
</ul>

   <p>When <code>scanf</code> stops scanning the current input field for one of
these reasons, the next character is considered unread and
used as the first character of the following input field, or the
first character in a subsequent read operation on the input.

   <p><code>scanf</code> will terminate under the following circumstances:

     <ul>
<li>The next character in the input field conflicts
with a corresponding non-whitespace character in the
format string.

     <li>The next character in the input field is <code>EOF</code>.

     <li>The format string has been exhausted.
</ul>

   <p>When the format string contains a character sequence that is
not part of a format specification, the same character
sequence must appear in the input; <code>scanf</code> will
scan but not store the matched characters.  If a
conflict occurs, the first conflicting character remains in the input
as if it had never been read.

   <p><br>
<strong>Portability</strong><br>
<code>scanf</code> is ANSI C.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="swprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#swscanf">swscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#sscanf">sscanf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.62 <code>swprintf</code>, <code>fwprintf</code>, <code>wprintf</code>&mdash;wide character format output</h3>

<p><a name="index-fwprintf-302"></a><a name="index-g_t_005ffwprintf_005fr-303"></a><a name="index-wprintf-304"></a><a name="index-g_t_005fwprintf_005fr-305"></a><a name="index-swprintf-306"></a><a name="index-g_t_005fswprintf_005fr-307"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;

     int wprintf(const wchar_t *<var>format</var>, ...);
     int fwprintf(FILE *<var>fd</var>, const wchar_t *<var>format</var>, ...);
     int swprintf(wchar_t *<var>str</var>, size_t <var>size</var>,
         const wchar_t *<var>format</var>, ...);

     int _wprintf_r(struct _reent *<var>ptr</var>, const wchar_t *<var>format</var>, ...);
     int _fwprintf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const wchar_t *<var>format</var>, ...);
     int _swprintf_r(struct _reent *<var>ptr</var>, wchar_t *<var>str</var>,
         size_t <var>size</var>, const wchar_t *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>wprintf</code> accepts a series of arguments, applies to each a
format specifier from <code>*</code><var>format</var>, and writes the
formatted data to <code>stdout</code>, without a terminating NUL
wide character.  The behavior of <code>wprintf</code> is undefined if there
are not enough arguments for the format or if any argument is not the
right type for the corresponding conversion specifier.  <code>wprintf</code>
returns when it reaches the end of the format string.  If there are
more arguments than the format requires, excess arguments are
ignored.

   <p><code>fwprintf</code> is like <code>wprintf</code>, except that output is directed
to the stream <var>fd</var> rather than <code>stdout</code>.

   <p><code>swprintf</code> is like <code>wprintf</code>, except that output is directed
to the buffer <var>str</var> with a terminating wide <code>NUL</code>, and the
resulting string length is limited to at most <var>size</var> wide characters,
including the terminating <code>NUL</code>.  It is considered an error if the
output (including the terminating wide-<code>NULL</code>) does not fit into
<var>size</var> wide characters.  (This error behavior is not the same as for
<code>snprintf</code>, which <code>swprintf</code> is otherwise completely analogous to.
While <code>snprintf</code> allows the needed size to be known simply by giving
<var>size</var>=0, <code>swprintf</code> does not, giving an error instead.)

   <p>For <code>swprintf</code> the behavior is undefined if the output
<code>*</code><var>str</var> overlaps with one of the arguments.  Behavior is also
undefined if the argument for <code>%n</code> within <code>*</code><var>format</var>
overlaps another argument.

   <p><var>format</var> is a pointer to a wide character string containing two
types of objects: ordinary characters (other than <code>%</code>),
which are copied unchanged to the output, and conversion
specifications, each of which is introduced by <code>%</code>. (To
include <code>%</code> in the output, use <code>%%</code> in the format string.)
A conversion specification has the following form:

<pre class="smallexample">            %[<var>pos</var>][<var>flags</var>][<var>width</var>][.<var>prec</var>][<var>size</var>]<var>type</var>
</pre>
   <p>The fields of the conversion specification have the following
meanings:

     <ul>
<li><var>pos</var>

     <p>Conversions normally consume arguments in the order that they
are presented.  However, it is possible to consume arguments
out of order, and reuse an argument for more than one
conversion specification (although the behavior is undefined
if the same argument is requested with different types), by
specifying <var>pos</var>, which is a decimal integer followed by
'$'.  The integer must be between 1 and &lt;NL_ARGMAX&gt; from
limits.h, and if argument <code>%n$</code> is requested, all earlier
arguments must be requested somewhere within <var>format</var>.  If
positional parameters are used, then all conversion
specifications except for <code>%%</code> must specify a position.
This positional parameters method is a POSIX extension to the C
standard definition for the functions.

     <li><var>flags</var>

     <p><var>flags</var> is an optional sequence of characters which control
output justification, numeric signs, decimal points, trailing
zeros, and octal and hex prefixes.  The flag characters are
minus (<code>-</code>), plus (<code>+</code>), space ( ), zero (<code>0</code>), sharp
(<code>#</code>), and quote (<code>'</code>).  They can appear in any
combination, although not all flags can be used for all
conversion specification types.

          <dl>
<dt><code>'</code><dd>A POSIX extension to the C standard.  However, this
implementation presently treats it as a no-op, which
is the default behavior for the C locale, anyway.  (If
it did what it is supposed to, when <var>type</var> were <code>i</code>,
<code>d</code>, <code>u</code>, <code>f</code>, <code>F</code>, <code>g</code>, or <code>G</code>, the
integer portion of the conversion would be formatted
with thousands' grouping wide characters.)

          <br><dt><code>-</code><dd>The result of the conversion is left
justified, and the right is padded with
blanks.  If you do not use this flag, the
result is right justified, and padded on the
left.

          <br><dt><code>+</code><dd>The result of a signed conversion (as
determined by <var>type</var> of <code>d</code>, <code>i</code>, <code>a</code>,
<code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, or
<code>G</code>) will always begin with a plus or minus
sign.  (If you do not use this flag, positive
values do not begin with a plus sign.)

          <br><dt><code>" " (space)</code><dd>If the first character of a signed conversion
specification is not a sign, or if a signed
conversion results in no characters, the
result will begin with a space.  If the space
( ) flag and the plus (<code>+</code>) flag both
appear, the space flag is ignored.

          <br><dt><code>0</code><dd>If the <var>type</var> character is <code>d</code>, <code>i</code>,
<code>o</code>, <code>u</code>, <code>x</code>, <code>X</code>, <code>a</code>, <code>A</code>,
<code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>, <code>g</code>, or <code>G</code>:  leading
zeros are used to pad the field width
(following any indication of sign or base); no
spaces are used for padding.  If the zero
(<code>0</code>) and minus (<code>-</code>) flags both appear,
the zero (<code>0</code>) flag will be ignored.  For
<code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, and <code>X</code>
conversions, if a precision <var>prec</var> is
specified, the zero (<code>0</code>) flag is ignored.

          <p>Note that <code>0</code> is interpreted as a flag, not
as the beginning of a field width.

          <br><dt><code>#</code><dd>The result is to be converted to an
alternative form, according to the <var>type</var>
character:

               <dl>
<dt><code>o</code><dd>Increases precision to force the first
digit of the result to be a zero.

               <br><dt><code>x</code><dd>A non-zero result will have a <code>0x</code>
prefix.

               <br><dt><code>X</code><dd>A non-zero result will have a <code>0X</code>
prefix.

               <br><dt><code>a, A, e, E, f, or F</code><dd>The result will always contain a
decimal point even if no digits follow
the point.  (Normally, a decimal point
appears only if a digit follows it.)
Trailing zeros are removed.

               <br><dt><code>g or G</code><dd>The result will always contain a
decimal point even if no digits follow
the point.  Trailing zeros are not
removed.

               <br><dt><code>all others</code><dd>Undefined.

          </dl>

     </dl>

     <li><var>width</var>

     <p><var>width</var> is an optional minimum field width.  You can
either specify it directly as a decimal integer, or
indirectly by using instead an asterisk (<code>*</code>), in
which case an <code>int</code> argument is used as the field
width.  If positional arguments are used, then the
width must also be specified positionally as <code>*m$</code>,
with m as a decimal integer.  Negative field widths
are treated as specifying the minus (<code>-</code>) flag for
left justfication, along with a positive field width.
The resulting format may be wider than the specified
width.

     <li><var>prec</var>

     <p><var>prec</var> is an optional field; if present, it is
introduced with `<code>.</code>' (a period). You can specify
the precision either directly as a decimal integer or
indirectly by using an asterisk (<code>*</code>), in which case
an <code>int</code> argument is used as the precision.  If
positional arguments are used, then the precision must
also be specified positionally as <code>*m$</code>, with m as a
decimal integer.  Supplying a negative precision is
equivalent to omitting the precision.  If only a
period is specified the precision is zero. The effect
depends on the conversion <var>type</var>.

          <dl>
<dt><code>d, i, o, u, x, or X</code><dd>Minimum number of digits to appear.  If no
precision is given, defaults to 1.

          <br><dt><code>a or A</code><dd>Number of digits to appear after the decimal
point.  If no precision is given, the
precision defaults to the minimum needed for
an exact representation.

          <br><dt><code>e, E, f or F</code><dd>Number of digits to appear after the decimal
point.  If no precision is given, the
precision defaults to 6.

          <br><dt><code>g or G</code><dd>Maximum number of significant digits.  A
precision of 0 is treated the same as a
precision of 1.  If no precision is given, the
precision defaults to 6.

          <br><dt><code>s or S</code><dd>Maximum number of characters to print from the
string.  If no precision is given, the entire
string is printed.

          <br><dt><code>all others</code><dd>undefined.

     </dl>

     <li><var>size</var>

     <p><var>size</var> is an optional modifier that changes the data
type that the corresponding argument has.  Behavior is
unspecified if a size is given that does not match the
<var>type</var>.

          <dl>
<dt><code>hh</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument should be
converted to a <code>signed char</code> or <code>unsigned
char</code> before printing.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>signed char</code>.

          <br><dt><code>h</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument should be
converted to a <code>short</code> or <code>unsigned short</code>
before printing.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>short</code>.

          <br><dt><code>l</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>long</code> or <code>unsigned long</code>.

          <p>With <code>c</code>, specifies that the argument has
type <code>wint_t</code>.

          <p>With <code>s</code>, specifies that the argument is a
pointer to <code>wchar_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>long</code>.

          <p>With <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>,
<code>g</code>, or <code>G</code>, has no effect (because of
vararg promotion rules, there is no need to
distinguish between <code>float</code> and <code>double</code>).

          <br><dt><code>ll</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>long long</code> or <code>unsigned long long</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>long long</code>.

          <br><dt><code>j</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is an
<code>intmax_t</code> or <code>uintmax_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to an <code>intmax_t</code>.

          <br><dt><code>z</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a <code>size_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>size_t</code>.

          <br><dt><code>t</code><dd>With <code>d</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>x</code>, or
<code>X</code>, specifies that the argument is a
<code>ptrdiff_t</code>.

          <p>With <code>n</code>, specifies that the argument is a
pointer to a <code>ptrdiff_t</code>.

          <br><dt><code>L</code><dd>With <code>a</code>, <code>A</code>, <code>e</code>, <code>E</code>, <code>f</code>, <code>F</code>,
<code>g</code>, or <code>G</code>, specifies that the argument
is a <code>long double</code>.

     </dl>

     <li><var>type</var>

     <p><var>type</var> specifies what kind of conversion <code>wprintf</code>
performs.  Here is a table of these:

          <dl>
<dt><code>%</code><dd>Prints the percent character (<code>%</code>).

          <br><dt><code>c</code><dd>If no <code>l</code> qualifier is present, the int argument shall
be converted to a wide character as if by calling
the btowc() function and the resulting wide character
shall be written.  Otherwise, the wint_t argument
shall be converted to wchar_t, and written.

          <br><dt><code>C</code><dd>Short for <code>%lc</code>.  A POSIX extension to the C standard.

          <br><dt><code>s</code><dd>If no <code>l</code> qualifier is present, the application
shall ensure that the argument is a pointer to a
character array containing a character sequence
beginning in the initial shift state.  Characters
from the array shall be converted as if by repeated
calls to the mbrtowc() function, with the conversion
state described by an mbstate_t object initialized to
zero before the first character is converted, and
written up to (but not including) the terminating
null wide character. If the precision is specified,
no more than that many wide characters shall be
written.  If the precision is not specified, or is
greater than the size of the array, the application
shall ensure that the array contains a null wide
character.

          <p>If an <code>l</code> qualifier is present, the application
shall ensure that the argument is a pointer to an
array of type wchar_t. Wide characters from the array
shall be written up to (but not including) a
terminating null wide character. If no precision is
specified, or is greater than the size of the array,
the application shall ensure that the array contains
a null wide character. If a precision is specified,
no more than that many wide characters shall be
written.

          <br><dt><code>S</code><dd>Short for <code>%ls</code>.  A POSIX extension to the C standard.

          <br><dt><code>d or i</code><dd>Prints a signed decimal integer; takes an
<code>int</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>o</code><dd>Prints an unsigned octal integer; takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>u</code><dd>Prints an unsigned decimal integer; takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>x</code><dd>Prints an unsigned hexadecimal integer (using
<code>abcdef</code> as digits beyond <code>9</code>); takes an
<code>unsigned</code>.  Leading zeros are inserted as
necessary to reach the precision.  A value of 0 with
a precision of 0 produces an empty string.

          <br><dt><code>X</code><dd>Like <code>x</code>, but uses <code>ABCDEF</code> as digits
beyond <code>9</code>.

          <br><dt><code>f</code><dd>Prints a signed value of the form
<code>[-]9999.9999</code>, with the precision
determining how many digits follow the decimal
point; takes a <code>double</code> (remember that
<code>float</code> promotes to <code>double</code> as a vararg).
The low order digit is rounded to even.  If
the precision results in at most DECIMAL_DIG
digits, the result is rounded correctly; if
more than DECIMAL_DIG digits are printed, the
result is only guaranteed to round back to the
original value.

          <p>If the value is infinite, the result is
<code>inf</code>, and no zero padding is performed.  If
the value is not a number, the result is
<code>nan</code>, and no zero padding is performed.

          <br><dt><code>F</code><dd>Like <code>f</code>, but uses <code>INF</code> and <code>NAN</code> for
non-finite numbers.

          <br><dt><code>e</code><dd>Prints a signed value of the form
<code>[-]9.9999e[+|-]999</code>; takes a <code>double</code>.
The digit before the decimal point is non-zero
if the value is non-zero.  The precision
determines how many digits appear between
<code>.</code> and <code>e</code>, and the exponent always
contains at least two digits.  The value zero
has an exponent of zero.  If the value is not
finite, it is printed like <code>f</code>.

          <br><dt><code>E</code><dd>Like <code>e</code>, but using <code>E</code> to introduce the
exponent, and like <code>F</code> for non-finite
values.

          <br><dt><code>g</code><dd>Prints a signed value in either <code>f</code> or <code>e</code>
form, based on the given value and
precision&mdash;an exponent less than -4 or
greater than the precision selects the <code>e</code>
form.  Trailing zeros and the decimal point
are printed only if necessary; takes a
<code>double</code>.

          <br><dt><code>G</code><dd>Like <code>g</code>, except use <code>F</code> or <code>E</code> form.

          <br><dt><code>a</code><dd>Prints a signed value of the form
<code>[-]0x1.ffffp[+|-]9</code>; takes a <code>double</code>.
The letters <code>abcdef</code> are used for digits
beyond <code>9</code>.  The precision determines how
many digits appear after the decimal point.
The exponent contains at least one digit, and
is a decimal value representing the power of
2; a value of 0 has an exponent of 0.
Non-finite values are printed like <code>f</code>.

          <br><dt><code>A</code><dd>Like <code>a</code>, except uses <code>X</code>, <code>P</code>, and
<code>ABCDEF</code> instead of lower case.

          <br><dt><code>n</code><dd>Takes a pointer to <code>int</code>, and stores a count
of the number of bytes written so far.  No
output is created.

          <br><dt><code>p</code><dd>Takes a pointer to <code>void</code>, and prints it in
an implementation-defined format.  This
implementation is similar to <code>%#tx</code>), except
that <code>0x</code> appears even for the NULL pointer.

     </dl>

   </ul>

   <p><code>_wprintf_r</code>, <code>_fwprintf_r</code>, <code>_swprintf_r</code>, are simply
reentrant versions of the functions above.

   <p><br>
<strong>Returns</strong><br>
On success, <code>swprintf</code> return the number of wide characters in
the output string, except the concluding <code>NUL</code> is not counted.
<code>wprintf</code> and <code>fwprintf</code> return the number of characters transmitted.

   <p>If an error occurs, the result of <code>wprintf</code>, <code>fwprintf</code>, and
<code>swprintf</code> is a negative value.  For <code>wprintf</code> and <code>fwprintf</code>,
<code>errno</code> may be set according to <code>fputwc</code>.  For <code>swprintf</code>, <code>errno</code>
may be set to EOVERFLOW if <var>size</var> is greater than INT_MAX / sizeof (wchar_t),
or when the output does not fit into <var>size</var> wide characters (including the
terminating wide <code>NULL</code>).

   <p><br>
<strong>Bugs</strong><br>
The &ldquo;&rdquo;' (quote) flag does not work when locale's thousands_sep is not empty.

   <p><br>
<strong>Portability</strong><br>
POSIX-1.2008 with extensions; C99 (compliant except for POSIX extensions).

   <p>Depending on how newlib was configured, not all format specifiers are
supported.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="swscanf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tmpfile">tmpfile</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#swprintf">swprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.63 <code>swscanf</code>, <code>fwscanf</code>, <code>wscanf</code>&mdash;scan and format wide character input</h3>

<p><a name="index-wscanf-308"></a><a name="index-g_t_005fwscanf_005fr-309"></a><a name="index-fwscanf-310"></a><a name="index-g_t_005ffwscanf_005fr-311"></a><a name="index-swscanf-312"></a><a name="index-g_t_005fswscanf_005fr-313"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;

     int wscanf(const wchar_t *<var>format</var>, ...);
     int fwscanf(FILE *<var>fd</var>, const wchar_t *<var>format</var>, ...);
     int swscanf(const wchar_t *<var>str</var>, const wchar_t *<var>format</var>, ...);

     int _wscanf_r(struct _reent *<var>ptr</var>, const wchar_t *<var>format</var>, ...);
     int _fwscanf_r(struct _reent *<var>ptr</var>, FILE *<var>fd</var>,
         const wchar_t *<var>format</var>, ...);
     int _swscanf_r(struct _reent *<var>ptr</var>, const wchar_t *<var>str</var>,
         const wchar_t *<var>format</var>, ...);

</pre>
   <p><strong>Description</strong><br>
<code>wscanf</code> scans a series of input fields from standard input,
one wide character at a time.  Each field is interpreted according to
a format specifier passed to <code>wscanf</code> in the format string at
<code>*</code><var>format</var>.  <code>wscanf</code> stores the interpreted input from
each field at the address passed to it as the corresponding argument
following <var>format</var>.  You must supply the same number of
format specifiers and address arguments as there are input fields.

   <p>There must be sufficient address arguments for the given format
specifiers; if not the results are unpredictable and likely
disasterous.  Excess address arguments are merely ignored.

   <p><code>wscanf</code> often produces unexpected results if the input diverges from
an expected pattern. Since the combination of <code>gets</code> or <code>fgets</code>
followed by <code>swscanf</code> is safe and easy, that is the preferred way
to be certain that a program is synchronized with input at the end
of a line.

   <p><code>fwscanf</code> and <code>swscanf</code> are identical to <code>wscanf</code>, other than the
source of input: <code>fwscanf</code> reads from a file, and <code>swscanf</code>
from a string.

   <p>The routines <code>_wscanf_r</code>, <code>_fwscanf_r</code>, and <code>_swscanf_r</code> are reentrant
versions of <code>wscanf</code>, <code>fwscanf</code>, and <code>swscanf</code> that take an additional
first argument pointing to a reentrancy structure.

   <p>The string at <code>*</code><var>format</var> is a wide character sequence composed
of zero or more directives. Directives are composed of
one or more whitespace characters, non-whitespace characters,
and format specifications.

   <p>Whitespace characters are blank ( ), tab (<code>\t</code>), or
newline (<code>\n</code>).
When <code>wscanf</code> encounters a whitespace character in the format string
it will read (but not store) all consecutive whitespace characters
up to the next non-whitespace character in the input.

   <p>Non-whitespace characters are all other ASCII characters except the
percent sign (<code>%</code>).  When <code>wscanf</code> encounters a non-whitespace
character in the format string it will read, but not store
a matching non-whitespace character.

   <p>Format specifications tell <code>wscanf</code> to read and convert characters
from the input field into specific types of values, and store then
in the locations specified by the address arguments.

   <p>Trailing whitespace is left unread unless explicitly
matched in the format string.

   <p>The format specifiers must begin with a percent sign (<code>%</code>)
and have the following form:

<pre class="smallexample">            %[*][<var>width</var>][<var>size</var>]<var>type</var>
</pre>
   <p>Each format specification begins with the percent character (<code>%</code>).
The other fields are:
     <dl>
<dt><code>*</code><dd>an optional marker; if present, it suppresses interpretation and
assignment of this input field.

     <br><dt><var>width</var><dd>an optional maximum field width: a decimal integer,
which controls the maximum number of characters that
will be read before converting the current input field.  If the
input field has fewer than <var>width</var> characters, <code>wscanf</code>
reads all the characters in the field, and then
proceeds with the next field and its format specification.

     <p>If a whitespace or a non-convertable wide character occurs
before <var>width</var> character are read, the characters up
to that character are read, converted, and stored.
Then <code>wscanf</code> proceeds to the next format specification.

     <br><dt><code>size</code><dd><code>h</code>, <code>j</code>, <code>l</code>, <code>L</code>, <code>t</code>, and <code>z</code> are optional size
characters which override the default way that <code>wscanf</code>
interprets the data type of the corresponding argument.

     <pre class="smallexample">          Modifier   Type(s)
             hh      d, i, o, u, x, n  convert input to char,
                                       store in char object

             h       d, i, o, u, x, n  convert input to short,
                                       store in short object

             h       e, f, c, s, p     no effect

             j       d, i, o, u, x, n  convert input to intmax_t,
                                       store in intmax_t object

             j       all others        no effect

             l       d, i, o, u, x, n  convert input to long,
                                       store in long object

             l       e, f, g           convert input to double
                                       store in a double object

             l       c, s, [           the input is stored in a wchar_t object

             l       p                 no effect

             ll      d, i, o, u, x, n  convert to long long,
                                       store in long long

             L       d, i, o, u, x, n  convert to long long,
                                       store in long long

             L       e, f, g, E, G     convert to long double,
                                       store in long double

             L       all others        no effect

             t       d, i, o, u, x, n  convert input to ptrdiff_t,
                                       store in ptrdiff_t object

             t       all others        no effect

             z       d, i, o, u, x, n  convert input to size_t,
                                       store in size_t object

             z       all others        no effect

</pre>
     <br><dt><var>type</var><dd>
A character to specify what kind of conversion
<code>wscanf</code> performs.  Here is a table of the conversion
characters:

          <dl>
<dt><code>%</code><dd>No conversion is done; the percent character (<code>%</code>) is stored.

          <br><dt><code>c</code><dd>Scans one wide character.  Corresponding <var>arg</var>: <code>(char *arg)</code>.
Otherwise, if an <code>l</code> specifier is present, the corresponding
<var>arg</var> is a <code>(wchar_t *arg)</code>.

          <br><dt><code>s</code><dd>Reads a character string into the array supplied.
Corresponding <var>arg</var>: <code>(char arg[])</code>.
If an <code>l</code> specifier is present, the corresponding <var>arg</var> is a <code>(wchar_t *arg)</code>.

          <br><dt><code>[</code><var>pattern</var><code>]</code><dd>Reads a non-empty character string into memory
starting at <var>arg</var>.  This area must be large
enough to accept the sequence and a
terminating null character which will be added
automatically.  (<var>pattern</var> is discussed in the paragraph following
this table).  Corresponding <var>arg</var>: <code>(char *arg)</code>.
If an <code>l</code> specifier is present, the corresponding <var>arg</var> is
a <code>(wchar_t *arg)</code>.

          <br><dt><code>d</code><dd>Reads a decimal integer into the corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>o</code><dd>Reads an octal integer into the corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>u</code><dd>Reads an unsigned decimal integer into the corresponding
<var>arg</var>: <code>(unsigned int *arg)</code>.
<br><dt><code>x,X</code><dd>Read a hexadecimal integer into the corresponding <var>arg</var>:
<code>(int *arg)</code>.

          <br><dt><code>e, f, g</code><dd>Read a floating-point number into the corresponding <var>arg</var>:
<code>(float *arg)</code>.

          <br><dt><code>E, F, G</code><dd>Read a floating-point number into the corresponding <var>arg</var>:
<code>(double *arg)</code>.

          <br><dt><code>i</code><dd>Reads a decimal, octal or hexadecimal integer into the
corresponding <var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>n</code><dd>Stores the number of characters read in the corresponding
<var>arg</var>: <code>(int *arg)</code>.

          <br><dt><code>p</code><dd>Stores a scanned pointer.  ANSI C leaves the details
to each implementation; this implementation treats
<code>%p</code> exactly the same as <code>%U</code>.  Corresponding
<var>arg</var>: <code>(void **arg)</code>.
</dl>

     <p>A <var>pattern</var> of characters surrounded by square brackets can be used
instead of the <code>s</code> type character.  <var>pattern</var> is a set of
characters which define a search set of possible characters making up
the <code>wscanf</code> input field.  If the first character in the brackets is a
caret (<code>^</code>), the search set is inverted to include all ASCII characters
except those between the brackets.  There is no range facility as is
defined in the corresponding non-wide character scanf functions.
Ranges are not part of the POSIX standard.

     <p>Here are some <var>pattern</var> examples:
          <dl>
<dt><code>%[abcd]</code><dd>matches wide character strings containing only
<code>a</code>, <code>b</code>, <code>c</code>, and <code>d</code>.

          <br><dt><code>%[^abcd]</code><dd>matches wide character strings containing any characters except
<code>a</code>, <code>b</code>, <code>c</code>, or <code>d</code>.

          <br><dt><code>%[A-DW-Z]</code><dd>Note: No wide character ranges, so this expression matches wide
character strings containing <code>A</code>, <code>-</code>, <code>D</code>, <code>W</code>, <code>Z</code>.
</dl>

     <p>Floating point numbers (for field types <code>e</code>, <code>f</code>, <code>g</code>, <code>E</code>,
<code>F</code>, <code>G</code>) must correspond to the following general form:

     <pre class="smallexample">          		[+/-] ddddd[.]ddd [E|e[+|-]ddd]
</pre>
     <p>where objects inclosed in square brackets are optional, and <code>ddd</code>
represents decimal, octal, or hexadecimal digits.
</dl>

   <p><br>
<strong>Returns</strong><br>
<code>wscanf</code> returns the number of input fields successfully
scanned, converted and stored; the return value does
not include scanned fields which were not stored.

   <p>If <code>wscanf</code> attempts to read at end-of-file, the return
value is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p><code>wscanf</code> might stop scanning a particular field before
reaching the normal field end character, or may
terminate entirely.

   <p><code>wscanf</code> stops scanning and storing the current field
and moves to the next input field (if any)
in any of the following situations:

     <ul>
<li>The assignment suppressing character (<code>*</code>) appears
after the <code>%</code> in the format specification; the current
input field is scanned but not stored.

     <li><var>width</var> characters have been read (<var>width</var> is a
width specification, a positive decimal integer).

     <li>The next wide character read cannot be converted
under the the current format (for example,
if a <code>Z</code> is read when the format is decimal).

     <li>The next wide character in the input field does not appear
in the search set (or does appear in the inverted search set).
</ul>

   <p>When <code>wscanf</code> stops scanning the current input field for one of
these reasons, the next character is considered unread and
used as the first character of the following input field, or the
first character in a subsequent read operation on the input.

   <p><code>wscanf</code> will terminate under the following circumstances:

     <ul>
<li>The next wide character in the input field conflicts
with a corresponding non-whitespace character in the
format string.

     <li>The next wide character in the input field is <code>WEOF</code>.

     <li>The format string has been exhausted.
</ul>

   <p>When the format string contains a wide character sequence that is
not part of a format specification, the same wide character
sequence must appear in the input; <code>wscanf</code> will
scan but not store the matched characters.  If a
conflict occurs, the first conflicting wide character remains in the
input as if it had never been read.

   <p><br>
<strong>Portability</strong><br>
<code>wscanf</code> is C99, POSIX-1.2008.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="tmpfile"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tmpnam">tmpnam</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#swscanf">swscanf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.64 <code>tmpfile</code>&mdash;create a temporary file</h3>

<p><a name="index-tmpfile-314"></a><a name="index-g_t_005ftmpfile_005fr-315"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *tmpfile(void);

     FILE *_tmpfile_r(struct _reent *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
Create a temporary file (a file which will be deleted automatically),
using a name generated by <code>tmpnam</code>.  The temporary file is opened with
the mode <code>"wb+"</code>, permitting you to read and write anywhere in it
as a binary file (without any data transformations the host system may
perform for text files).

   <p>The alternate function <code>_tmpfile_r</code> is a reentrant version.  The
argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
<code>tmpfile</code> normally returns a pointer to the temporary file.  If no
temporary file could be created, the result is NULL, and <code>errno</code>
records the reason for failure.

   <p><br>
<strong>Portability</strong><br>
Both ANSI C and the System V Interface Definition (Issue 2) require
<code>tmpfile</code>.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>getpid</code>,
<code>isatty</code>, <code>lseek</code>, <code>open</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><code>tmpfile</code> also requires the global pointer <code>environ</code>.

   <p><br>

<div class="node">
<a name="tmpnam"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ungetc">ungetc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tmpfile">tmpfile</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.65 <code>tmpnam</code>, <code>tempnam</code>&mdash;name for a temporary file</h3>

<p><a name="index-tmpnam-316"></a><a name="index-tempnam-317"></a><a name="index-g_t_005ftmpnam_005fr-318"></a><a name="index-g_t_005ftempnam_005fr-319"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     char *tmpnam(char *<var>s</var>);
     char *tempnam(char *<var>dir</var>, char *<var>pfx</var>);
     char *_tmpnam_r(struct _reent *<var>reent</var>, char *<var>s</var>);
     char *_tempnam_r(struct _reent *<var>reent</var>, char *<var>dir</var>, char *<var>pfx</var>);

</pre>
   <p><strong>Description</strong><br>
Use either of these functions to generate a name for a temporary file.
The generated name is guaranteed to avoid collision with other files
(for up to <code>TMP_MAX</code> calls of either function).

   <p><code>tmpnam</code> generates file names with the value of <code>P_tmpdir</code>
(defined in `<code>stdio.h</code>') as the leading directory component of the path.

   <p>You can use the <code>tmpnam</code> argument <var>s</var> to specify a suitable area
of memory for the generated filename; otherwise, you can call
<code>tmpnam(NULL)</code> to use an internal static buffer.

   <p><code>tempnam</code> allows you more control over the generated filename: you
can use the argument <var>dir</var> to specify the path to a directory for
temporary files, and you can use the argument <var>pfx</var> to specify a
prefix for the base filename.

   <p>If <var>dir</var> is <code>NULL</code>, <code>tempnam</code> will attempt to use the value of
environment variable <code>TMPDIR</code> instead; if there is no such value,
<code>tempnam</code> uses the value of <code>P_tmpdir</code> (defined in `<code>stdio.h</code>').

   <p>If you don't need any particular prefix to the basename of temporary
files, you can pass <code>NULL</code> as the <var>pfx</var> argument to <code>tempnam</code>.

   <p><code>_tmpnam_r</code> and <code>_tempnam_r</code> are reentrant versions of <code>tmpnam</code>
and <code>tempnam</code> respectively.  The extra argument <var>reent</var> is a
pointer to a reentrancy structure.

   <p><br>
<strong>Warnings</strong><br>
The generated filenames are suitable for temporary files, but do not
in themselves make files temporary.  Files with these names must still
be explicitly removed when you no longer want them.

   <p>If you supply your own data area <var>s</var> for <code>tmpnam</code>, you must ensure
that it has room for at least <code>L_tmpnam</code> elements of type <code>char</code>.

   <p><br>
<strong>Returns</strong><br>
Both <code>tmpnam</code> and <code>tempnam</code> return a pointer to the newly
generated filename.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>tmpnam</code>, but does not specify the use of
<code>P_tmpdir</code>.  The System V Interface Definition (Issue 2) requires
both <code>tmpnam</code> and <code>tempnam</code>.

   <p>Supporting OS subroutines required: <code>close</code>,  <code>fstat</code>, <code>getpid</code>,
<code>isatty</code>, <code>lseek</code>, <code>open</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p>The global pointer <code>environ</code> is also required.

   <p><br>

<div class="node">
<a name="ungetc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ungetwc">ungetwc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#tmpnam">tmpnam</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.66 <code>ungetc</code>&mdash;push data back into a stream</h3>

<p><a name="index-ungetc-320"></a><a name="index-g_t_005fungetc_005fr-321"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int ungetc(int <var>c</var>, FILE *<var>stream</var>);

     int _ungetc_r(struct _reent *<var>reent</var>, int <var>c</var>, FILE *<var>stream</var>);

</pre>
   <p><strong>Description</strong><br>
<code>ungetc</code> is used to return bytes back to <var>stream</var> to be read again.
If <var>c</var> is EOF, the stream is unchanged.  Otherwise, the unsigned
char <var>c</var> is put back on the stream, and subsequent reads will see
the bytes pushed back in reverse order.  Pushed byes are lost if the
stream is repositioned, such as by <code>fseek</code>, <code>fsetpos</code>, or
<code>rewind</code>.

   <p>The underlying file is not changed, but it is possible to push back
something different than what was originally read.  Ungetting a
character will clear the end-of-stream marker, and decrement the file
position indicator.  Pushing back beyond the beginning of a file gives
unspecified behavior.

   <p>The alternate function <code>_ungetc_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The character pushed back, or <code>EOF</code> on error.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>ungetc</code>, but only requires a pushback buffer of one
byte; although this implementation can handle multiple bytes, not all
can.  Pushing back a signed char is a common application bug.

   <p>Supporting OS subroutines required: <code>sbrk</code>.

   <p><br>

<div class="node">
<a name="ungetwc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#vfprintf">vfprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ungetc">ungetc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.67 <code>ungetwc</code>&mdash;push wide character data back into a stream</h3>

<p><a name="index-ungetwc-322"></a><a name="index-g_t_005fungetwc_005fr-323"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;wchar.h&gt;
     wint_t ungetwc(wint_t <var>wc</var>, FILE *<var>stream</var>);

     wint_t _ungetwc_r(struct _reent *<var>reent</var>, wint_t <var>wc</var>, FILE *<var>stream</var>);

</pre>
   <p><strong>Description</strong><br>
<code>ungetwc</code> is used to return wide characters back to <var>stream</var> to be
read again.  If <var>wc</var> is WEOF, the stream is unchanged.  Otherwise, the
wide character <var>wc</var> is put back on the stream, and subsequent reads will see
the wide chars pushed back in reverse order.  Pushed wide chars are lost if the
stream is repositioned, such as by <code>fseek</code>, <code>fsetpos</code>, or
<code>rewind</code>.

   <p>The underlying file is not changed, but it is possible to push back
something different than what was originally read.  Ungetting a
character will clear the end-of-stream marker, and decrement the file
position indicator.  Pushing back beyond the beginning of a file gives
unspecified behavior.

   <p>The alternate function <code>_ungetwc_r</code> is a reentrant version.  The
extra argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The wide character pushed back, or <code>WEOF</code> on error.

   <p><br>
<strong>Portability</strong><br>
C99

   <p><br>

<div class="node">
<a name="vfprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#vfscanf">vfscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ungetwc">ungetwc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.68 <code>vfprintf</code>, <code>vprintf</code>, <code>vsprintf</code>, <code>vsnprintf</code>, <code>vasprintf</code>, <code>vasnprintf</code>&mdash;format argument list</h3>

<p><a name="index-vfprintf-324"></a><a name="index-g_t_005fvfprintf_005fr-325"></a><a name="index-vprintf-326"></a><a name="index-g_t_005fvprintf_005fr-327"></a><a name="index-vsprintf-328"></a><a name="index-g_t_005fvsprintf_005fr-329"></a><a name="index-vsnprintf-330"></a><a name="index-g_t_005fvsnprintf_005fr-331"></a><a name="index-vasprintf-332"></a><a name="index-g_t_005fvasprintf_005fr-333"></a><a name="index-vasnprintf-334"></a><a name="index-g_t_005fvasnprintf_005fr-335"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int vprintf(const char *<var>fmt</var>, va_list <var>list</var>);
     int vfprintf(FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsprintf(char *<var>str</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsnprintf(char *<var>str</var>, size_t <var>size</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int vasprintf(char **<var>strp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     char *vasnprintf(char *<var>str</var>, size_t *<var>size</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);

     int _vprintf_r(struct _reent *<var>reent</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfprintf_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     int _vsprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     int _vasprintf_r(struct _reent *<var>reent</var>, char **<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     int _vsnprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         size_t <var>size</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     char *_vasnprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         size_t *<var>size</var>, const char *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>vprintf</code>, <code>vfprintf</code>, <code>vasprintf</code>, <code>vsprintf</code>, <code>vsnprintf</code>,
and <code>vasnprintf</code> are (respectively) variants of <code>printf</code>,
<code>fprintf</code>, <code>asprintf</code>, <code>sprintf</code>, <code>snprintf</code>, and
<code>asnprintf</code>.  They differ only in allowing their caller to pass the
variable argument list as a <code>va_list</code> object (initialized by
<code>va_start</code>) rather than directly accepting a variable number of
arguments.  The caller is responsible for calling <code>va_end</code>.

   <p><code>_vprintf_r</code>, <code>_vfprintf_r</code>, <code>_vasprintf_r</code>, <code>_vsprintf_r</code>,
<code>_vsnprintf_r</code>, and <code>_vasnprintf_r</code> are reentrant versions of the
above.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>vprintf</code>, <code>vfprintf</code>, <code>vsprintf</code>, and
<code>vsnprintf</code>.  The remaining functions are newlib extensions.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="vfscanf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#vfwprintf">vfwprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#vfprintf">vfprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.69 <code>vfscanf</code>, <code>vscanf</code>, <code>vsscanf</code>&mdash;format argument list</h3>

<p><a name="index-vfscanf-336"></a><a name="index-g_t_005fvfscanf_005fr-337"></a><a name="index-vscanf-338"></a><a name="index-g_t_005fvscanf_005fr-339"></a><a name="index-vsscanf-340"></a><a name="index-g_t_005fvsscanf_005fr-341"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int vscanf(const char *<var>fmt</var>, va_list <var>list</var>);
     int vfscanf(FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsscanf(const char *<var>str</var>, const char *<var>fmt</var>, va_list <var>list</var>);

     int _vscanf_r(struct _reent *<var>reent</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfscanf_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vsscanf_r(struct _reent *<var>reent</var>, const char *<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>vscanf</code>, <code>vfscanf</code>, and <code>vsscanf</code> are (respectively) variants
of <code>scanf</code>, <code>fscanf</code>, and <code>sscanf</code>.  They differ only in
allowing their caller to pass the variable argument list as a
<code>va_list</code> object (initialized by <code>va_start</code>) rather than
directly accepting a variable number of arguments.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions:
<code>vscanf</code> returns the number of input fields successfully scanned,
converted, and stored; the return value does not include scanned
fields which were not stored.

   <p>If <code>vscanf</code> attempts to read at end-of-file, the return value
is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p>The routines <code>_vscanf_r</code>, <code>_vfscanf_f</code>, and <code>_vsscanf_r</code> are
reentrant versions which take an additional first parameter which points to the
reentrancy structure.

   <p><br>
<strong>Portability</strong><br>
These are GNU extensions.

   <p>Supporting OS subroutines required:

   <p><br>

<div class="node">
<a name="vfwprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#vfwscanf">vfwscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#vfscanf">vfscanf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.70 <code>vfwprintf</code>, <code>vwprintf</code>, <code>vswprintf</code>&mdash;wide character format argument list</h3>

<p><a name="index-vfwprintf-342"></a><a name="index-g_t_005fvfwprintf_005fr-343"></a><a name="index-vwprintf-344"></a><a name="index-g_t_005fvwprintf_005fr-345"></a><a name="index-vswprintf-346"></a><a name="index-g_t_005fvswprintf_005fr-347"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     #include &lt;wchar.h&gt;
     int vwprintf(const wchar_t *<var>fmt</var>, va_list <var>list</var>);
     int vfwprintf(FILE *<var>fp</var>, const wchar_t *<var>fmt</var>, va_list <var>list</var>);
     int vswprintf(wchar_t *<var>str</var>, size_t <var>size</var>, const wchar_t *<var>fmt</var>,
         va_list <var>list</var>);

     int _vwprintf_r(struct _reent *<var>reent</var>, const wchar_t *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfwprintf_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>,
         const wchar_t *<var>fmt</var>, va_list <var>list</var>);
     int _vswprintf_r(struct _reent *<var>reent</var>, wchar_t *<var>str</var>,
         size_t <var>size</var>, const wchar_t *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>vwprintf</code>, <code>vfwprintf</code> and <code>vswprintf</code> are (respectively) variants
of <code>wprintf</code>, <code>fwprintf</code> and <code>swprintf</code>.  They differ only in allowing
their caller to pass the variable argument list as a <code>va_list</code> object
(initialized by <code>va_start</code>) rather than directly accepting a variable
number of arguments.  The caller is responsible for calling <code>va_end</code>.

   <p><code>_vwprintf_r</code>, <code>_vfwprintf_r</code> and <code>_vswprintf_r</code> are reentrant
versions of the above.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions.

   <p><br>
<strong>Portability</strong><br>
POSIX-1.2008 with extensions; C99 (compliant except for POSIX extensions).

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>
<strong>See Also</strong><br>
<code>wprintf</code>, <code>fwprintf</code> and <code>swprintf</code>.

   <p><br>

<div class="node">
<a name="vfwscanf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#viprintf">viprintf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#vfwprintf">vfwprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.71 <code>vfwscanf</code>, <code>vwscanf</code>, <code>vswscanf</code>&mdash;scan and format argument list from wide character input</h3>

<p><a name="index-vfwscanf-348"></a><a name="index-g_t_005fvfwscanf-349"></a><a name="index-vwscanf-350"></a><a name="index-g_t_005fvwscanf-351"></a><a name="index-vswscanf-352"></a><a name="index-g_t_005fvswscanf-353"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int vwscanf(const wchar_t *<var>fmt</var>, va_list <var>list</var>);
     int vfwscanf(FILE *<var>fp</var>, const wchar_t *<var>fmt</var>, va_list <var>list</var>);
     int vswscanf(const wchar_t *<var>str</var>, const wchar_t *<var>fmt</var>, va_list <var>list</var>);

     int _vwscanf(struct _reent *<var>reent</var>, const wchar_t *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfwscanf(struct _reent *<var>reent</var>, FILE *<var>fp</var>, const wchar_t *<var>fmt</var>,
         va_list <var>list</var>);
     int _vswscanf(struct _reent *<var>reent</var>, const wchar_t *<var>str</var>,
         const wchar_t *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>vwscanf</code>, <code>vfwscanf</code>, and <code>vswscanf</code> are (respectively) variants
of <code>wscanf</code>, <code>fwscanf</code>, and <code>swscanf</code>.  They differ only in
allowing their caller to pass the variable argument list as a
<code>va_list</code> object (initialized by <code>va_start</code>) rather than
directly accepting a variable number of arguments.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions:
<code>vwscanf</code> returns the number of input fields successfully scanned,
converted, and stored; the return value does not include scanned
fields which were not stored.

   <p>If <code>vwscanf</code> attempts to read at end-of-file, the return value
is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p>The routines <code>_vwscanf</code>, <code>_vfwscanf</code>, and <code>_vswscanf</code> are
reentrant versions which take an additional first parameter which points
to the reentrancy structure.

   <p><br>
<strong>Portability</strong><br>
C99, POSIX-1.2008

   <p><br>

<div class="node">
<a name="viprintf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#viscanf">viscanf</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#vfwscanf">vfwscanf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.72 <code>viprintf</code>, <code>vfiprintf</code>, <code>vsiprintf</code>, <code>vsniprintf</code>, <code>vasiprintf</code>, <code>vasniprintf</code>&mdash;format argument list (integer only)</h3>

<p><a name="index-viprintf-354"></a><a name="index-g_t_005fviprintf_005fr-355"></a><a name="index-vfiprintf-356"></a><a name="index-g_t_005fvfiprintf_005fr-357"></a><a name="index-vsiprintf-358"></a><a name="index-g_t_005fvsiprintf_005fr-359"></a><a name="index-vsniprintf-360"></a><a name="index-g_t_005fvsniprintf_005fr-361"></a><a name="index-vasiprintf-362"></a><a name="index-g_t_005fvasiprintf_005fr-363"></a><a name="index-vasniprintf-364"></a><a name="index-g_t_005fvasniprintf_005fr-365"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int viprintf(const char *<var>fmt</var>, va_list <var>list</var>);
     int vfiprintf(FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsiprintf(char *<var>str</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsniprintf(char *<var>str</var>, size_t <var>size</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int vasiprintf(char **<var>strp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     char *vasniprintf(char *<var>str</var>, size_t *<var>size</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);

     int _viprintf_r(struct _reent *<var>reent</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfiprintf_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     int _vsiprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     int _vsniprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         size_t <var>size</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int _vasiprintf_r(struct _reent *<var>reent</var>, char **<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);
     char *_vasniprintf_r(struct _reent *<var>reent</var>, char *<var>str</var>,
         size_t *<var>size</var>, const char *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>viprintf</code>, <code>vfiprintf</code>, <code>vasiprintf</code>, <code>vsiprintf</code>,
<code>vsniprintf</code>, and <code>vasniprintf</code> are (respectively) variants of
<code>iprintf</code>, <code>fiprintf</code>, <code>asiprintf</code>, <code>siprintf</code>, <code>sniprintf</code>,
and <code>asniprintf</code>.  They differ only in allowing their caller to pass
the variable argument list as a <code>va_list</code> object (initialized by
<code>va_start</code>) rather than directly accepting a variable number of
arguments.  The caller is responsible for calling <code>va_end</code>.

   <p><code>_viprintf_r</code>, <code>_vfiprintf_r</code>, <code>_vasiprintf_r</code>,
<code>_vsiprintf_r</code>, <code>_vsniprintf_r</code>, and <code>_vasniprintf_r</code> are
reentrant versions of the above.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions:

   <p><br>
<strong>Portability</strong><br>
All of these functions are newlib extensions.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="viscanf"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#viprintf">viprintf</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio">Stdio</a>

</div>

<h3 class="section">4.73 <code>viscanf</code>, <code>vfiscanf</code>, <code>vsiscanf</code>&mdash;format argument list</h3>

<p><a name="index-viscanf-366"></a><a name="index-g_t_005fviscanf_005fr-367"></a><a name="index-vfiscanf-368"></a><a name="index-g_t_005fvfiscanf_005fr-369"></a><a name="index-vsiscanf-370"></a><a name="index-g_t_005fvsiscanf_005fr-371"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     #include &lt;stdarg.h&gt;
     int viscanf(const char *<var>fmt</var>, va_list <var>list</var>);
     int vfiscanf(FILE *<var>fp</var>, const char *<var>fmt</var>, va_list <var>list</var>);
     int vsiscanf(const char *<var>str</var>, const char *<var>fmt</var>, va_list <var>list</var>);

     int _viscanf_r(struct _reent *<var>reent</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vfiscanf_r(struct _reent *<var>reent</var>, FILE *<var>fp</var>, const char *<var>fmt</var>,
         va_list <var>list</var>);
     int _vsiscanf_r(struct _reent *<var>reent</var>, const char *<var>str</var>,
         const char *<var>fmt</var>, va_list <var>list</var>);

</pre>
   <p><strong>Description</strong><br>
<code>viscanf</code>, <code>vfiscanf</code>, and <code>vsiscanf</code> are (respectively) variants
of <code>iscanf</code>, <code>fiscanf</code>, and <code>siscanf</code>.  They differ only in
allowing their caller to pass the variable argument list as a
<code>va_list</code> object (initialized by <code>va_start</code>) rather than
directly accepting a variable number of arguments.

   <p><br>
<strong>Returns</strong><br>
The return values are consistent with the corresponding functions:
<code>viscanf</code> returns the number of input fields successfully scanned,
converted, and stored; the return value does not include scanned
fields which were not stored.

   <p>If <code>viscanf</code> attempts to read at end-of-file, the return value
is <code>EOF</code>.

   <p>If no fields were stored, the return value is <code>0</code>.

   <p>The routines <code>_viscanf_r</code>, <code>_vfiscanf_f</code>, and <code>_vsiscanf_r</code> are
reentrant versions which take an additional first parameter which points to the
reentrancy structure.

   <p><br>
<strong>Portability</strong><br>
These are newlib extensions.

   <p>Supporting OS subroutines required:

   <p><br>
<div class="node">
<a name="Stdio64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Strings">Strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stdio">Stdio</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Large File Input and Output (<samp><span class="file">stdio.h</span></samp>)</h2>

<p>This chapter comprises additional functions to manage large files which
are potentially larger than 2GB.

   <p>The underlying facilities for input and output depend on the host
system, but these functions provide a uniform interface.

   <p>The corresponding declarations are in <samp><span class="file">stdio.h</span></samp>.

<ul class="menu">
<li><a accesskey="1" href="#fopen64">fopen64</a>:      Open a large file
<li><a accesskey="2" href="#freopen64">freopen64</a>:    Open a large file using an existing file descriptor
<li><a accesskey="3" href="#fsetpos64">fsetpos64</a>:    Restore position of a large stream or file
<li><a accesskey="4" href="#fgetpos64">fgetpos64</a>:    Get position of a large stream or file
<li><a accesskey="5" href="#ftello64">ftello64</a>:     Return position in a large stream or file
<li><a accesskey="6" href="#fseeko64">fseeko64</a>:     Set large file position
<li><a accesskey="7" href="#tmpfile64">tmpfile64</a>:    Create a temporary large file
</ul>

<div class="node">
<a name="fopen64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#freopen64">freopen64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.1 <code>fopen64</code>&mdash;open a large file</h3>

<p><a name="index-fopen64-372"></a><a name="index-g_t_005ffopen64_005fr-373"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *fopen64(const char *<var>file</var>, const char *<var>mode</var>);
     FILE *_fopen64_r(void *<var>reent</var>,
         const char *<var>file</var>, const char *<var>mode</var>);

</pre>
   <p><strong>Description</strong><br>
<code>fopen64</code> is identical to <code>fopen</code> except it opens a large file that
is potentially &gt;2GB in size.  See <code>fopen</code> for further details.

   <p><br>
<strong>Returns</strong><br>
<code>fopen64</code> return a file pointer which you can use for other file
operations, unless the file you requested could not be opened; in that
situation, the result is <code>NULL</code>.  If the reason for failure was an
invalid string at <var>mode</var>, <code>errno</code> is set to <code>EINVAL</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fopen64</code> is a glibc extension.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat64</code>, <code>isatty</code>,
<code>lseek64</code>, <code>open64</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="freopen64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fsetpos64">fsetpos64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fopen64">fopen64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.2 <code>freopen64</code>&mdash;open a large file using an existing file descriptor</h3>

<p><a name="index-freopen64-374"></a><a name="index-g_t_005ffreopen64_005fr-375"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *freopen64(const char *<var>file</var>, const char *<var>mode</var>,
         FILE *<var>fp</var>);
     FILE *_freopen64_r(struct _reent *<var>ptr</var>, const char *<var>file</var>,
         const char *<var>mode</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Use this variant of <code>fopen64</code> if you wish to specify a particular file
descriptor <var>fp</var> (notably <code>stdin</code>, <code>stdout</code>, or <code>stderr</code>) for
the file.

   <p>If <var>fp</var> was associated with another file or stream, <code>freopen64</code>
closes that other file or stream (but ignores any errors while closing
it).

   <p><var>file</var> and <var>mode</var> are used just as in <code>fopen</code>.

   <p>If <var>file</var> is <code>NULL</code>, the underlying stream is modified rather than
closed.  The file cannot be given a more permissive access mode (for
example, a <var>mode</var> of "w" will fail on a read-only file descriptor),
but can change status such as append or binary mode.  If modification
is not possible, failure occurs.

   <p><br>
<strong>Returns</strong><br>
If successful, the result is the same as the argument <var>fp</var>.  If the
file cannot be opened as specified, the result is <code>NULL</code>.

   <p><br>
<strong>Portability</strong><br>
<code>freopen</code> is a glibc extension.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek64</code>, <code>open64</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="ftello64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fseeko64">fseeko64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fgetpos64">fgetpos64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.3 <code>ftello64</code>&mdash;return position in a stream or file</h3>

<p><a name="index-ftello64-376"></a><a name="index-g_t_005fftello64_005fr-377"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     _off64_t ftello64(FILE *<var>fp</var>);
     _off64_t _ftello64_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>The result of <code>ftello64</code> is the current position for a large file
identified by <var>fp</var>.  If you record this result, you can later
use it with <code>fseeko64</code> to return the file to this
position.  The difference between <code>ftello</code> and <code>ftello64</code> is that
<code>ftello</code> returns <code>off_t</code> and <code>ftello64</code> is designed to work
for large files (&gt;2GB) and returns <code>_off64_t</code>.

   <p>In the current implementation, <code>ftello64</code> simply uses a character
count to represent the file position; this is the same number that
would be recorded by <code>fgetpos64</code>.

   <p>The function exists only if the __LARGE64_FILES flag is defined.
An error occurs if the <var>fp</var> was not opened via <code>fopen64</code>.

   <p><br>
<strong>Returns</strong><br>
<code>ftello64</code> returns the file position, if possible.  If it cannot do
this, it returns <code>-1</code>.  Failure occurs on streams that do not support
positioning or not opened via <code>fopen64</code>; the global <code>errno</code> indicates
this condition with the value <code>ESPIPE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>ftello64</code> is a glibc extension.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fseeko64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tmpfile64">tmpfile64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ftello64">ftello64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.4 <code>fseeko64</code>&mdash;set file position for large file</h3>

<p><a name="index-fseeko64-378"></a><a name="index-g_t_005ffseeko64_005fr-379"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fseeko64(FILE *<var>fp</var>, _off64_t <var>offset</var>, int <var>whence</var>)
     int _fseeko64_r (struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         _off64_t <var>offset</var>, int <var>whence</var>)
</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fseeko64</code> to set the position for the file identified by
<var>fp</var> that was opened via <code>fopen64</code>.  The value of <var>offset</var> determines
the new position, in one of three ways selected by the value of <var>whence</var>
(defined as macros in `<code>stdio.h</code>'):

   <p><code>SEEK_SET</code>&mdash;<var>offset</var> is the absolute file position (an offset
from the beginning of the file) desired.  <var>offset</var> must be positive.

   <p><code>SEEK_CUR</code>&mdash;<var>offset</var> is relative to the current file position.
<var>offset</var> can meaningfully be either positive or negative.

   <p><code>SEEK_END</code>&mdash;<var>offset</var> is relative to the current end of file.
<var>offset</var> can meaningfully be either positive (to increase the size
of the file) or negative.

   <p>See <code>ftello64</code> to determine the current file position.

   <p><br>
<strong>Returns</strong><br>
<code>fseeko64</code> returns <code>0</code> when successful.  On failure, the
result is <code>EOF</code>.  The reason for failure is indicated in <code>errno</code>:
either <code>ESPIPE</code> (the stream identified by <var>fp</var> doesn't support
repositioning or wasn't opened via <code>fopen64</code>) or <code>EINVAL</code>
(invalid file position).

   <p><br>
<strong>Portability</strong><br>
<code>fseeko64</code> is a glibc extension.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat64</code>, <code>isatty</code>,
<code>lseek64</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="fgetpos64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ftello64">ftello64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fsetpos64">fsetpos64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.5 <code>fgetpos64</code>&mdash;record position in a large stream or file</h3>

<p><a name="index-fgetpos64-380"></a><a name="index-g_t_005ffgetpos64_005fr-381"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fgetpos64(FILE *<var>fp</var>, _fpos64_t *<var>pos</var>);
     int _fgetpos64_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         _fpos64_t *<var>pos</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fgetpos64</code> to report on the current position for a file
identified by <var>fp</var> that was opened by <code>fopen64</code>; <code>fgetpos</code> will write
a value representing that position at <code>*</code><var>pos</var>.  Later, you can
use this value with <code>fsetpos64</code> to return the file to this
position.

   <p>In the current implementation, <code>fgetpos64</code> simply uses a character
count to represent the file position; this is the same number that
would be returned by <code>ftello64</code>.

   <p><br>
<strong>Returns</strong><br>
<code>fgetpos64</code> returns <code>0</code> when successful.  If <code>fgetpos64</code> fails, the
result is <code>1</code>.  Failure occurs on streams that do not support
positioning or streams not opened via <code>fopen64</code>; the global <code>errno</code>
indicates these conditions with the value <code>ESPIPE</code>.

   <p><br>
<strong>Portability</strong><br>
<code>fgetpos64</code> is a glibc extension.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="fsetpos64"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#fgetpos64">fgetpos64</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#freopen64">freopen64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.6 <code>fsetpos64</code>&mdash;restore position of a large stream or file</h3>

<p><a name="index-fsetpos64-382"></a><a name="index-g_t_005ffsetpos64_005fr-383"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     int fsetpos64(FILE *<var>fp</var>, const _fpos64_t *<var>pos</var>);
     int _fsetpos64_r(struct _reent *<var>ptr</var>, FILE *<var>fp</var>,
         const _fpos64_t *<var>pos</var>);

</pre>
   <p><strong>Description</strong><br>
Objects of type <code>FILE</code> can have a &ldquo;position&rdquo; that records how much
of the file your program has already read.  Many of the <code>stdio</code> functions
depend on this position, and many change it as a side effect.

   <p>You can use <code>fsetpos64</code> to return the large file identified by <var>fp</var> to a
previous position <code>*</code><var>pos</var> (after first recording it with <code>fgetpos64</code>).

   <p>See <code>fseeko64</code> for a similar facility.

   <p><br>
<strong>Returns</strong><br>
<code>fgetpos64</code> returns <code>0</code> when successful.  If <code>fgetpos64</code> fails, the
result is <code>1</code>.  The reason for failure is indicated in <code>errno</code>:
either <code>ESPIPE</code> (the stream identified by <var>fp</var> doesn't support
64-bit repositioning) or <code>EINVAL</code> (invalid file position).

   <p><br>
<strong>Portability</strong><br>
<code>fsetpos64</code> is a glibc extension.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>isatty</code>,
<code>lseek64</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><br>

<div class="node">
<a name="tmpfile64"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#fseeko64">fseeko64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdio64">Stdio64</a>

</div>

<h3 class="section">5.7 <code>tmpfile64</code>&mdash;create a large temporary file</h3>

<p><a name="index-tmpfile64-384"></a><a name="index-g_t_005ftmpfile64_005fr-385"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *tmpfile64(void);

     FILE *_tmpfile64_r(void *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
Create a large temporary file (a file which will be deleted automatically),
using a name generated by <code>tmpnam</code>.  The temporary file is opened with
the mode <code>"wb+"</code>, permitting you to read and write anywhere in it
as a binary file (without any data transformations the host system may
perform for text files).  The file may be larger than 2GB.

   <p>The alternate function <code>_tmpfile64_r</code> is a reentrant version.  The
argument <var>reent</var> is a pointer to a reentrancy structure.

   <p>Both <code>tmpfile64</code> and <code>_tmpfile64_r</code> are only defined if __LARGE64_FILES
is defined.

   <p><br>
<strong>Returns</strong><br>
<code>tmpfile64</code> normally returns a pointer to the temporary file.  If no
temporary file could be created, the result is NULL, and <code>errno</code>
records the reason for failure.

   <p><br>
<strong>Portability</strong><br>
<code>tmpfile64</code> is a glibc extension.

   <p>Supporting OS subroutines required: <code>close</code>, <code>fstat</code>, <code>getpid</code>,
<code>isatty</code>, <code>lseek64</code>, <code>open64</code>, <code>read</code>, <code>sbrk</code>, <code>write</code>.

   <p><code>tmpfile64</code> also requires the global pointer <code>environ</code>.

   <p><br>

<div class="node">
<a name="Strings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Wchar-strings">Wchar strings</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stdio64">Stdio64</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">6 Strings and Memory (<samp><span class="file">string.h</span></samp>)</h2>

<p>This chapter describes string-handling functions and functions for
managing areas of memory.  The corresponding declarations are in
<samp><span class="file">string.h</span></samp>.

<ul class="menu">
<li><a accesskey="1" href="#bcmp">bcmp</a>:         Compare two memory areas
<li><a accesskey="2" href="#bcopy">bcopy</a>:        Copy memory regions
<li><a accesskey="3" href="#bzero">bzero</a>:        Initialize memory to zero
<li><a accesskey="4" href="#index">index</a>:        Search for character in string
<li><a accesskey="5" href="#memccpy">memccpy</a>:      Copy memory regions up to end-token
<li><a accesskey="6" href="#memchr">memchr</a>:       Find character in memory
<li><a accesskey="7" href="#memcmp">memcmp</a>:       Compare two memory areas
<li><a accesskey="8" href="#memcpy">memcpy</a>:       Copy memory regions
<li><a accesskey="9" href="#memmem">memmem</a>:       Find memory segment
<li><a href="#memmove">memmove</a>:      Move possibly overlapping memory
<li><a href="#mempcpy">mempcpy</a>: 	Copy memory regions and locate end
<li><a href="#memset">memset</a>:       Set an area of memory
<li><a href="#rindex">rindex</a>:       Reverse search for character in string
<li><a href="#stpcpy">stpcpy</a>:       Copy string returning a pointer to its end
<li><a href="#stpncpy">stpncpy</a>:      Counted copy string returning a pointer to its end
<li><a href="#strcasecmp">strcasecmp</a>: 	Compare strings ignoring case
<li><a href="#strcasestr">strcasestr</a>: 	Find string segment ignoring case
<li><a href="#strcat">strcat</a>:       Concatenate strings
<li><a href="#strchr">strchr</a>:       Search for character in string
<li><a href="#strcmp">strcmp</a>:       Character string compare
<li><a href="#strcoll">strcoll</a>:      Locale-specific character string compare
<li><a href="#strcpy">strcpy</a>:       Copy string
<li><a href="#strcspn">strcspn</a>:      Count chars not in string
<li><a href="#strerror">strerror</a>:     Convert error number to string
<li><a href="#strerror_005fr">strerror_r</a>:   Convert error number to string
<li><a href="#strlen">strlen</a>:       Character string length
<li><a href="#strlwr">strlwr</a>: 	Convert string to lowercase
<li><a href="#strncasecmp">strncasecmp</a>: 	Compare strings ignoring case
<li><a href="#strncat">strncat</a>:      Concatenate strings
<li><a href="#strncmp">strncmp</a>:      Character string compare
<li><a href="#strncpy">strncpy</a>:      Counted copy string
<li><a href="#strnlen">strnlen</a>:      Character string length
<li><a href="#strpbrk">strpbrk</a>:      Find chars in string
<li><a href="#strrchr">strrchr</a>:      Reverse search for character in string
<li><a href="#strsignal">strsignal</a>: 	Return signal message string
<li><a href="#strspn">strspn</a>:       Find initial match
<li><a href="#strstr">strstr</a>:       Find string segment
<li><a href="#strtok">strtok</a>:       Get next token from a string
<li><a href="#strupr">strupr</a>: 	Convert string to upper case
<li><a href="#strxfrm">strxfrm</a>:      Transform string
<li><a href="#swab">swab</a>:         Swap adjacent bytes
<li><a href="#wcscasecmp">wcscasecmp</a>:   Compare wide character strings ignoring case
<li><a href="#wcsdup">wcsdup</a>:       Wide character string duplicate
<li><a href="#wcsncasecmp">wcsncasecmp</a>:  Compare wide character strings ignoring case
</ul>

<div class="node">
<a name="bcmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#bcopy">bcopy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.1 <code>bcmp</code>&mdash;compare two memory areas</h3>

<p><a name="index-bcmp-386"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int bcmp(const void *<var>s1</var>, const void *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function compares not more than <var>n</var> bytes of the
object pointed to by <var>s1</var> with the object pointed to by <var>s2</var>.

   <p>This function is identical to <code>memcmp</code>.

   <p><br>
<strong>Returns</strong><br>
The function returns an integer greater than, equal to or
less than zero 	according to whether the object pointed to by
<var>s1</var> is greater than, equal to or less than the object
pointed to by <var>s2</var>.

   <p><br>
<strong>Portability</strong><br>
<code>bcmp</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="bcopy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#bzero">bzero</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#bcmp">bcmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.2 <code>bcopy</code>&mdash;copy memory regions</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void bcopy(const void *<var>in</var>, void *<var>out</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function copies <var>n</var> bytes from the memory region
pointed to by <var>in</var> to the memory region pointed to by
<var>out</var>.

   <p>This function is implemented in term of <code>memmove</code>.

   <p><br>
<strong>Portability</strong><br>
<code>bcopy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="bzero"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#index">index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#bcopy">bcopy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.3 <code>bzero</code>&mdash;initialize memory to zero</h3>

<p><a name="index-bzero-387"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void bzero(void *<var>b</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>bzero</code> initializes <var>length</var> bytes of memory, starting at address
<var>b</var>, to zero.

   <p><br>
<strong>Returns</strong><br>
<code>bzero</code> does not return a result.

   <p><br>
<strong>Portability</strong><br>
<code>bzero</code> is in the Berkeley Software Distribution.
Neither ANSI C nor the System V Interface Definition (Issue 2) require
<code>bzero</code>.

   <p><code>bzero</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="index"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memccpy">memccpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#bzero">bzero</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.4 <code>index</code>&mdash;search for character in string</h3>

<p><a name="index-index-388"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char * index(const char *<var>string</var>, int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
This function finds the first occurence of <var>c</var> (converted to
a char) in the string pointed to by <var>string</var> (including the
terminating null character).

   <p>This function is identical to <code>strchr</code>.

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located character, or a null pointer
if <var>c</var> does not occur in <var>string</var>.

   <p><br>
<strong>Portability</strong><br>
<code>index</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memccpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memchr">memchr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#index">index</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.5 <code>memccpy</code>&mdash;copy memory regions with end-token check</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void* memccpy(void *<var>out</var>, const void *<var>in</var>,
         int <var>endchar</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function copies up to <var>n</var> bytes from the memory region
pointed to by <var>in</var> to the memory region pointed to by
<var>out</var>.  If a byte matching the <var>endchar</var> is encountered,
the byte is copied and copying stops.

   <p>If the regions overlap, the behavior is undefined.

   <p><br>
<strong>Returns</strong><br>
<code>memccpy</code> returns a pointer to the first byte following the
<var>endchar</var> in the <var>out</var> region.  If no byte matching
<var>endchar</var> was copied, then <code>NULL</code> is returned.

   <p><br>
<strong>Portability</strong><br>
<code>memccpy</code> is a GNU extension.

   <p><code>memccpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memchr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memcmp">memcmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memccpy">memccpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.6 <code>memchr</code>&mdash;find character in memory</h3>

<p><a name="index-memchr-389"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void *memchr(const void *<var>src</var>, int <var>c</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
This function searches memory starting at <code>*</code><var>src</var> for the
character <var>c</var>.  The search only ends with the first
occurrence of <var>c</var>, or after <var>length</var> characters; in
particular, <code>NUL</code> does not terminate the search.

   <p><br>
<strong>Returns</strong><br>
If the character <var>c</var> is found within <var>length</var> characters
of <code>*</code><var>src</var>, a pointer to the character is returned. If
<var>c</var> is not found, then <code>NULL</code> is returned.

   <p><br>
<strong>Portability</strong><br>
<code>memchr</code> is ANSI C.

   <p><code>memchr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memcmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memcpy">memcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memchr">memchr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.7 <code>memcmp</code>&mdash;compare two memory areas</h3>

<p><a name="index-memcmp-390"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int memcmp(const void *<var>s1</var>, const void *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function compares not more than <var>n</var> characters of the
object pointed to by <var>s1</var> with the object pointed to by <var>s2</var>.

   <p><br>
<strong>Returns</strong><br>
The function returns an integer greater than, equal to or
less than zero 	according to whether the object pointed to by
<var>s1</var> is greater than, equal to or less than the object
pointed to by <var>s2</var>.

   <p><br>
<strong>Portability</strong><br>
<code>memcmp</code> is ANSI C.

   <p><code>memcmp</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memmem">memmem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memcmp">memcmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.8 <code>memcpy</code>&mdash;copy memory regions</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void* memcpy(void *<var>out</var>, const void *<var>in</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function copies <var>n</var> bytes from the memory region
pointed to by <var>in</var> to the memory region pointed to by
<var>out</var>.

   <p>If the regions overlap, the behavior is undefined.

   <p><br>
<strong>Returns</strong><br>
<code>memcpy</code> returns a pointer to the first byte of the <var>out</var>
region.

   <p><br>
<strong>Portability</strong><br>
<code>memcpy</code> is ANSI C.

   <p><code>memcpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memmem"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memmove">memmove</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memcpy">memcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.9 <code>memmem</code>&mdash;find memory segment</h3>

<p><a name="index-memmem-391"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *memmem(const void *<var>s1</var>, size_t <var>l1</var>, const void *<var>s2</var>,
         size_t <var>l2</var>);

</pre>
   <p><strong>Description</strong><br>

   <p>Locates the first occurrence in the memory region pointed to
by <var>s1</var> with length <var>l1</var> of the sequence of bytes pointed
to by <var>s2</var> of length <var>l2</var>.  If you already know the
lengths of your haystack and needle, <code>memmem</code> can be much
faster than <code>strstr</code>.

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located segment, or a null pointer if
<var>s2</var> is not found. If <var>l2</var> is 0, <var>s1</var> is returned.

   <p><br>
<strong>Portability</strong><br>
<code>memmem</code> is a newlib extension.

   <p><code>memmem</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memmove"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mempcpy">mempcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memmem">memmem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.10 <code>memmove</code>&mdash;move possibly overlapping memory</h3>

<p><a name="index-memmove-392"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void *memmove(void *<var>dst</var>, const void *<var>src</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
This function moves <var>length</var> characters from the block of
memory starting at <code>*</code><var>src</var> to the memory starting at
<code>*</code><var>dst</var>. <code>memmove</code> reproduces the characters correctly
at <code>*</code><var>dst</var> even if the two areas overlap.

   <p><br>
<strong>Returns</strong><br>
The function returns <var>dst</var> as passed.

   <p><br>
<strong>Portability</strong><br>
<code>memmove</code> is ANSI C.

   <p><code>memmove</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="mempcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#memset">memset</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memmove">memmove</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.11 <code>mempcpy</code>&mdash;copy memory regions and return end pointer</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void* mempcpy(void *<var>out</var>, const void *<var>in</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function copies <var>n</var> bytes from the memory region
pointed to by <var>in</var> to the memory region pointed to by
<var>out</var>.

   <p>If the regions overlap, the behavior is undefined.

   <p><br>
<strong>Returns</strong><br>
<code>mempcpy</code> returns a pointer to the byte following the
last byte copied to the <var>out</var> region.

   <p><br>
<strong>Portability</strong><br>
<code>mempcpy</code> is a GNU extension.

   <p><code>mempcpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="memset"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#rindex">rindex</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mempcpy">mempcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.12 <code>memset</code>&mdash;set an area of memory</h3>

<p><a name="index-memset-393"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     void *memset(void *<var>dst</var>, int <var>c</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
This function converts the argument <var>c</var> into an unsigned
char and fills the first <var>length</var> characters of the array
pointed to by <var>dst</var> to the value.

   <p><br>
<strong>Returns</strong><br>
<code>memset</code> returns the value of <var>dst</var>.

   <p><br>
<strong>Portability</strong><br>
<code>memset</code> is ANSI C.

   <p><code>memset</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="rindex"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#stpcpy">stpcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#memset">memset</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.13 <code>rindex</code>&mdash;reverse search for character in string</h3>

<p><a name="index-rindex-394"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char * rindex(const char *<var>string</var>, int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
This function finds the last occurence of <var>c</var> (converted to
a char) in the string pointed to by <var>string</var> (including the
terminating null character).

   <p>This function is identical to <code>strrchr</code>.

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located character, or a null pointer
if <var>c</var> does not occur in <var>string</var>.

   <p><br>
<strong>Portability</strong><br>
<code>rindex</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="stpcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#stpncpy">stpncpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#rindex">rindex</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.14 <code>stpcpy</code>&mdash;copy string returning a pointer to its end</h3>

<p><a name="index-stpcpy-395"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *stpcpy(char *<var>dst</var>, const char *<var>src</var>);

</pre>
   <p><strong>Description</strong><br>
<code>stpcpy</code> copies the string pointed to by <var>src</var>
(including the terminating null character) to the array
pointed to by <var>dst</var>.

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to the end of the destination string,
thus pointing to the trailing '\0'.

   <p><br>
<strong>Portability</strong><br>
<code>stpcpy</code> is a GNU extension, candidate for inclusion into POSIX/SUSv4.

   <p><code>stpcpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="stpncpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcasecmp">strcasecmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#stpcpy">stpcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.15 <code>stpncpy</code>&mdash;counted copy string returning a pointer to its end</h3>

<p><a name="index-stpncpy-396"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *stpncpy(char *<var>dst</var>, const char *<var>src</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>stpncpy</code> copies not more than <var>length</var> characters from the
the string pointed to by <var>src</var> (including the terminating
null character) to the array pointed to by <var>dst</var>.  If the
string pointed to by <var>src</var> is shorter than <var>length</var>
characters, null characters are appended to the destination
array until a total of <var>length</var> characters have been
written.

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to the end of the destination string,
thus pointing to the trailing '\0', or, if the destination string is
not null-terminated, pointing to dst + n.

   <p><br>
<strong>Portability</strong><br>
<code>stpncpy</code> is a GNU extension, candidate for inclusion into POSIX/SUSv4.

   <p><code>stpncpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strcasecmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcasestr">strcasestr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#stpncpy">stpncpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.16 <code>strcasecmp</code>&mdash;case-insensitive character string compare</h3>

<p><a name="index-strcasecmp-397"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int strcasecmp(const char *<var>a</var>, const char *<var>b</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcasecmp</code> compares the string at <var>a</var> to
the string at <var>b</var> in a case-insensitive manner.

   <p><br>
<strong>Returns</strong><br>

   <p>If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var> (after
both are converted to lowercase), <code>strcasecmp</code> returns a
number greater than zero.  If the two strings match,
<code>strcasecmp</code> returns zero.  If <code>*</code><var>a</var> sorts
lexicographically before <code>*</code><var>b</var>, <code>strcasecmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>strcasecmp</code> is in the Berkeley Software Distribution.

   <p><code>strcasecmp</code> requires no supporting OS subroutines. It uses
tolower() from elsewhere in this library.

   <p><br>

<div class="node">
<a name="strcasestr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcat">strcat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcasecmp">strcasecmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.17 <code>strcasestr</code>&mdash;case-insensitive character string search</h3>

<p><a name="index-strcasestr-398"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strcasestr(const char *<var>s</var>, const char *<var>find</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcasestr</code> searchs the string <var>s</var> for
the first occurrence of the sequence <var>find</var>.  <code>strcasestr</code>
is identical to <code>strstr</code> except the search is
case-insensitive.

   <p><br>
<strong>Returns</strong><br>

   <p>A pointer to the first case-insensitive occurrence of the sequence
<var>find</var> or <code>NULL</code> if no match was found.

   <p><br>
<strong>Portability</strong><br>
<code>strcasestr</code> is in the Berkeley Software Distribution.

   <p><code>strcasestr</code> requires no supporting OS subroutines. It uses
tolower() from elsewhere in this library.

   <p><br>

<div class="node">
<a name="strcat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strchr">strchr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcasestr">strcasestr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.18 <code>strcat</code>&mdash;concatenate strings</h3>

<p><a name="index-strcat-399"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strcat(char *<var>dst</var>, const char *<var>src</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcat</code> appends a copy of the string pointed to by <var>src</var>
(including the terminating null character) to the end of the
string pointed to by <var>dst</var>.  The initial character of
<var>src</var> overwrites the null character at the end of <var>dst</var>.

   <p><br>
<strong>Returns</strong><br>
This function returns the initial value of <var>dst</var>

   <p><br>
<strong>Portability</strong><br>
<code>strcat</code> is ANSI C.

   <p><code>strcat</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strchr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcmp">strcmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcat">strcat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.19 <code>strchr</code>&mdash;search for character in string</h3>

<p><a name="index-strchr-400"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char * strchr(const char *<var>string</var>, int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
This function finds the first occurence of <var>c</var> (converted to
a char) in the string pointed to by <var>string</var> (including the
terminating null character).

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located character, or a null pointer
if <var>c</var> does not occur in <var>string</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strchr</code> is ANSI C.

   <p><code>strchr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strcmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcoll">strcoll</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strchr">strchr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.20 <code>strcmp</code>&mdash;character string compare</h3>

<p><a name="index-strcmp-401"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int strcmp(const char *<var>a</var>, const char *<var>b</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcmp</code> compares the string at <var>a</var> to
the string at <var>b</var>.

   <p><br>
<strong>Returns</strong><br>
If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var>,
<code>strcmp</code> returns a number greater than zero.  If the two
strings match, <code>strcmp</code> returns zero.  If <code>*</code><var>a</var>
sorts lexicographically before <code>*</code><var>b</var>, <code>strcmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>strcmp</code> is ANSI C.

   <p><code>strcmp</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strcoll"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcpy">strcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcmp">strcmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.21 <code>strcoll</code>&mdash;locale-specific character string compare</h3>

<p><a name="index-strcoll-402"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int strcoll(const char *<var>stra</var>, const char * <var>strb</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcoll</code> compares the string pointed to by <var>stra</var> to
the string pointed to by <var>strb</var>, using an interpretation
appropriate to the current <code>LC_COLLATE</code> state.

   <p><br>
<strong>Returns</strong><br>
If the first string is greater than the second string,
<code>strcoll</code> returns a number greater than zero.  If the two
strings are equivalent, <code>strcoll</code> returns zero.  If the first
string is less than the second string, <code>strcoll</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>strcoll</code> is ANSI C.

   <p><code>strcoll</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strcspn">strcspn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcoll">strcoll</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.22 <code>strcpy</code>&mdash;copy string</h3>

<p><a name="index-strcpy-403"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strcpy(char *<var>dst</var>, const char *<var>src</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strcpy</code> copies the string pointed to by <var>src</var>
(including the terminating null character) to the array
pointed to by <var>dst</var>.

   <p><br>
<strong>Returns</strong><br>
This function returns the initial value of <var>dst</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strcpy</code> is ANSI C.

   <p><code>strcpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strcspn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strerror">strerror</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcpy">strcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.23 <code>strcspn</code>&mdash;count characters not in string</h3>

<p><a name="index-strcspn-404"></a><strong>Synopsis</strong>
<pre class="example">     size_t strcspn(const char *<var>s1</var>, const char *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
This function computes the length of the initial part of
the string pointed to by <var>s1</var> which consists entirely of
characters <var>NOT</var> from the string pointed to by <var>s2</var>
(excluding the terminating null character).

   <p><br>
<strong>Returns</strong><br>
<code>strcspn</code> returns the length of the substring found.

   <p><br>
<strong>Portability</strong><br>
<code>strcspn</code> is ANSI C.

   <p><code>strcspn</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strerror"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strerror_005fr">strerror_r</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strcspn">strcspn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.24 <code>strerror</code>&mdash;convert error number to string</h3>

<p><a name="index-strerror-405"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strerror(int <var>errnum</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strerror</code> converts the error number <var>errnum</var> into a
string.  The value of <var>errnum</var> is usually a copy of <code>errno</code>.
If <code>errnum</code> is not a known error number, the result points to an
empty string.

   <p>This implementation of <code>strerror</code> prints out the following strings
for each of the values defined in `<code>errno.h</code>':

     <dl>
<dt><code>E2BIG</code><dd>Arg list too long

     <br><dt><code>EACCES</code><dd>Permission denied

     <br><dt><code>EADDRINUSE</code><dd>Address already in use

     <br><dt><code>EADV</code><dd>Advertise error

     <br><dt><code>EAFNOSUPPORT</code><dd>Address family not supported by protocol family

     <br><dt><code>EAGAIN</code><dd>No more processes

     <br><dt><code>EALREADY</code><dd>Socket already connected

     <br><dt><code>EBADF</code><dd>Bad file number

     <br><dt><code>EBADMSG</code><dd>Bad message

     <br><dt><code>EBUSY</code><dd>Device or resource busy

     <br><dt><code>ECHILD</code><dd>No children

     <br><dt><code>ECOMM</code><dd>Communication error

     <br><dt><code>ECONNABORTED</code><dd>Software caused connection abort

     <br><dt><code>ECONNREFUSED</code><dd>Connection refused

     <br><dt><code>EDEADLK</code><dd>Deadlock

     <br><dt><code>EDESTADDRREQ</code><dd>Destination address required

     <br><dt><code>EEXIST</code><dd>File exists

     <br><dt><code>EDOM</code><dd>Math argument

     <br><dt><code>EFAULT</code><dd>Bad address

     <br><dt><code>EFBIG</code><dd>File too large

     <br><dt><code>EHOSTDOWN</code><dd>Host is down

     <br><dt><code>EHOSTUNREACH</code><dd>Host is unreachable

     <br><dt><code>EIDRM</code><dd>Identifier removed

     <br><dt><code>EINPROGRESS</code><dd>Connection already in progress

     <br><dt><code>EINTR</code><dd>Interrupted system call

     <br><dt><code>EINVAL</code><dd>Invalid argument

     <br><dt><code>EIO</code><dd>I/O error

     <br><dt><code>EISCONN</code><dd>Socket is already connected

     <br><dt><code>EISDIR</code><dd>Is a directory

     <br><dt><code>ELIBACC</code><dd>Cannot access a needed shared library

     <br><dt><code>ELIBBAD</code><dd>Accessing a corrupted shared library

     <br><dt><code>ELIBEXEC</code><dd>Cannot exec a shared library directly

     <br><dt><code>ELIBMAX</code><dd>Attempting to link in more shared libraries than system limit

     <br><dt><code>ELIBSCN</code><dd><code>.lib</code> section in a.out corrupted

     <br><dt><code>EMFILE</code><dd>Too many open files

     <br><dt><code>EMLINK</code><dd>Too many links

     <br><dt><code>EMSGSIZE</code><dd>Message too long

     <br><dt><code>EMULTIHOP</code><dd>Multihop attempted

     <br><dt><code>ENAMETOOLONG</code><dd>File or path name too long

     <br><dt><code>ENETDOWN</code><dd>Network interface not configured

     <br><dt><code>ENETUNREACH</code><dd>Network is unreachable

     <br><dt><code>ENFILE</code><dd>Too many open files in system

     <br><dt><code>ENODEV</code><dd>No such device

     <br><dt><code>ENOENT</code><dd>No such file or directory

     <br><dt><code>ENOEXEC</code><dd>Exec format error

     <br><dt><code>ENOLCK</code><dd>No lock

     <br><dt><code>ENOLINK</code><dd>Virtual circuit is gone

     <br><dt><code>ENOMEM</code><dd>Not enough space

     <br><dt><code>ENOMSG</code><dd>No message of desired type

     <br><dt><code>ENONET</code><dd>Machine is not on the network

     <br><dt><code>ENOPKG</code><dd>No package

     <br><dt><code>ENOPROTOOPT</code><dd>Protocol not available

     <br><dt><code>ENOSPC</code><dd>No space left on device

     <br><dt><code>ENOSR</code><dd>No stream resources

     <br><dt><code>ENOSTR</code><dd>Not a stream

     <br><dt><code>ENOSYS</code><dd>Function not implemented

     <br><dt><code>ENOTBLK</code><dd>Block device required

     <br><dt><code>ENOTCONN</code><dd>Socket is not connected

     <br><dt><code>ENOTDIR</code><dd>Not a directory

     <br><dt><code>ENOTEMPTY</code><dd>Directory not empty

     <br><dt><code>ENOTSOCK</code><dd>Socket operation on non-socket

     <br><dt><code>ENOTSUP</code><dd>Not supported

     <br><dt><code>ENOTTY</code><dd>Not a character device

     <br><dt><code>ENXIO</code><dd>No such device or address

     <br><dt><code>EPERM</code><dd>Not owner

     <br><dt><code>EPIPE</code><dd>Broken pipe

     <br><dt><code>EPROTO</code><dd>Protocol error

     <br><dt><code>EPROTOTYPE</code><dd>Protocol wrong type for socket

     <br><dt><code>EPROTONOSUPPORT</code><dd>Unknown protocol

     <br><dt><code>ERANGE</code><dd>Result too large

     <br><dt><code>EREMOTE</code><dd>Resource is remote

     <br><dt><code>EROFS</code><dd>Read-only file system

     <br><dt><code>ESHUTDOWN</code><dd>Can't send after socket shutdown

     <br><dt><code>ESOCKTNOSUPPORT</code><dd>Socket type not supported

     <br><dt><code>ESPIPE</code><dd>Illegal seek

     <br><dt><code>ESRCH</code><dd>No such process

     <br><dt><code>ESRMNT</code><dd>Srmount error

     <br><dt><code>ETIME</code><dd>Stream ioctl timeout

     <br><dt><code>ETIMEDOUT</code><dd>Connection timed out

     <br><dt><code>ETXTBSY</code><dd>Text file busy

     <br><dt><code>EXDEV</code><dd>Cross-device link

     <br><dt><code>ECANCELED</code><dd>Operation canceled

     <br><dt><code>ENOTRECOVERABLE</code><dd>State not recoverable

     <br><dt><code>EOWNERDEAD</code><dd>Previous owner died

     <br><dt><code>ESTRPIPE</code><dd>Strings pipe error

   </dl>

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to a string.  Your application must
not modify that string.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>strerror</code>, but does not specify the strings used
for each error number.

   <p>Although this implementation of <code>strerror</code> is reentrant, ANSI C
declares that subsequent calls to <code>strerror</code> may overwrite the
result string; therefore portable code cannot depend on the reentrancy
of this subroutine.

   <p>This implementation of <code>strerror</code> provides for user-defined
extensibility.  <code>errno.h</code> defines <var>__ELASTERROR</var>, which can be
used as a base for user-defined error values.  If the user supplies a
routine named <code>_user_strerror</code>, and <var>errnum</var> passed to
<code>strerror</code> does not match any of the supported values,
<code>_user_strerror</code> is called with <var>errnum</var> as its argument.

   <p><code>_user_strerror</code> takes one argument of type <var>int</var>, and returns a
character pointer.  If <var>errnum</var> is unknown to <code>_user_strerror</code>,
<code>_user_strerror</code> returns <var>NULL</var>.  The default <code>_user_strerror</code>
returns <var>NULL</var> for all input values.

   <p><code>strerror</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strerror_r"></a>
<a name="strerror_005fr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strlen">strlen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strerror">strerror</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.25 <code>strerror_r</code>&mdash;convert error number to string and copy to buffer</h3>

<p><a name="index-strerror_005fr-406"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strerror_r(int <var>errnum</var>, char *<var>buffer</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strerror_r</code> converts the error number <var>errnum</var> into a
string and copies the result into the supplied <var>buffer</var> for
a length up to <var>n</var>, including the NUL terminator. The value of
<var>errnum</var> is usually a copy of <code>errno</code>.  If <code>errnum</code> is not a known
error number, the result is the empty string.

   <p>See <code>strerror</code> for how strings are mapped to <code>errnum</code>.

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to a string.  Your application must
not modify that string.

   <p><br>
<strong>Portability</strong><br>
<code>strerror_r</code> is a GNU extension.

   <p><code>strerror_r</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strlen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strlwr">strlwr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strerror_005fr">strerror_r</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.26 <code>strlen</code>&mdash;character string length</h3>

<p><a name="index-strlen-407"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     size_t strlen(const char *<var>str</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>strlen</code> function works out the length of the string
starting at <code>*</code><var>str</var> by counting chararacters until it
reaches a <code>NULL</code> character.

   <p><br>
<strong>Returns</strong><br>
<code>strlen</code> returns the character count.

   <p><br>
<strong>Portability</strong><br>
<code>strlen</code> is ANSI C.

   <p><code>strlen</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strlwr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strncasecmp">strncasecmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strlen">strlen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.27 <code>strlwr</code>&mdash;force string to lowercase</h3>

<p><a name="index-strlwr-408"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strlwr(char *<var>a</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strlwr</code> converts each character in the string at <var>a</var> to
lowercase.

   <p><br>
<strong>Returns</strong><br>
<code>strlwr</code> returns its argument, <var>a</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strlwr</code> is not widely portable.

   <p><code>strlwr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strncasecmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strncat">strncat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strlwr">strlwr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.28 <code>strncasecmp</code>&mdash;case-insensitive character string compare</h3>

<p><a name="index-strncasecmp-409"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int strncasecmp(const char *<var>a</var>, const char * <var>b</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strncasecmp</code> compares up to <var>length</var> characters
from the string at <var>a</var> to the string at <var>b</var> in a
case-insensitive manner.

   <p><br>
<strong>Returns</strong><br>

   <p>If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var> (after
both are converted to lowercase), <code>strncasecmp</code> returns a
number greater than zero.  If the two strings are equivalent,
<code>strncasecmp</code> returns zero.  If <code>*</code><var>a</var> sorts
lexicographically before <code>*</code><var>b</var>, <code>strncasecmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>strncasecmp</code> is in the Berkeley Software Distribution.

   <p><code>strncasecmp</code> requires no supporting OS subroutines. It uses
tolower() from elsewhere in this library.

   <p><br>

<div class="node">
<a name="strncat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strncmp">strncmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strncasecmp">strncasecmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.29 <code>strncat</code>&mdash;concatenate strings</h3>

<p><a name="index-strncat-410"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strncat(char *<var>dst</var>, const char *<var>src</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strncat</code> appends not more than <var>length</var> characters from
the string pointed to by <var>src</var> (including the	terminating
null character) to the end of the string pointed to by
<var>dst</var>.  The initial character of <var>src</var> overwrites the null
character at the end of <var>dst</var>.  A terminating null character
is always appended to the result

   <p><br>
<strong>Warnings</strong><br>
Note that a null is always appended, so that if the copy is
limited by the <var>length</var> argument, the number of characters
appended to <var>dst</var> is <code>n + 1</code>.

   <p><br>
<strong>Returns</strong><br>
This function returns the initial value of <var>dst</var>

   <p><br>
<strong>Portability</strong><br>
<code>strncat</code> is ANSI C.

   <p><code>strncat</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strncmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strncpy">strncpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strncat">strncat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.30 <code>strncmp</code>&mdash;character string compare</h3>

<p><a name="index-strncmp-411"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     int strncmp(const char *<var>a</var>, const char * <var>b</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strncmp</code> compares up to <var>length</var> characters
from the string at <var>a</var> to the string at <var>b</var>.

   <p><br>
<strong>Returns</strong><br>
If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var>,
<code>strncmp</code> returns a number greater than zero.  If the two
strings are equivalent, <code>strncmp</code> returns zero.  If <code>*</code><var>a</var>
sorts lexicographically before <code>*</code><var>b</var>, <code>strncmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>strncmp</code> is ANSI C.

   <p><code>strncmp</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strncpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strnlen">strnlen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strncmp">strncmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.31 <code>strncpy</code>&mdash;counted copy string</h3>

<p><a name="index-strncpy-412"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strncpy(char *<var>dst</var>, const char *<var>src</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strncpy</code> copies not more than <var>length</var> characters from the
the string pointed to by <var>src</var> (including the terminating
null character) to the array pointed to by <var>dst</var>.  If the
string pointed to by <var>src</var> is shorter than <var>length</var>
characters, null characters are appended to the destination
array until a total of <var>length</var> characters have been
written.

   <p><br>
<strong>Returns</strong><br>
This function returns the initial value of <var>dst</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strncpy</code> is ANSI C.

   <p><code>strncpy</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strnlen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strpbrk">strpbrk</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strncpy">strncpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.32 <code>strnlen</code>&mdash;character string length</h3>

<p><a name="index-strnlen-413"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     size_t strnlen(const char *<var>str</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>strnlen</code> function works out the length of the string
starting at <code>*</code><var>str</var> by counting chararacters until it
reaches a NUL character or the maximum: <var>n</var> number of
characters have been inspected.

   <p><br>
<strong>Returns</strong><br>
<code>strnlen</code> returns the character count or <var>n</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strnlen</code> is a GNU extension.

   <p><code>strnlen</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strpbrk"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strrchr">strrchr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strnlen">strnlen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.33 <code>strpbrk</code>&mdash;find characters in string</h3>

<p><a name="index-strpbrk-414"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strpbrk(const char *<var>s1</var>, const char *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
This function locates the first occurence in the string
pointed to by <var>s1</var> of any character in string pointed to by
<var>s2</var> (excluding the terminating null character).

   <p><br>
<strong>Returns</strong><br>
<code>strpbrk</code> returns a pointer to the character found in <var>s1</var>, or a
null pointer if no character from <var>s2</var> occurs in <var>s1</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strpbrk</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strrchr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strsignal">strsignal</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strpbrk">strpbrk</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.34 <code>strrchr</code>&mdash;reverse search for character in string</h3>

<p><a name="index-strrchr-415"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char * strrchr(const char *<var>string</var>, int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
This function finds the last occurence of <var>c</var> (converted to
a char) in the string pointed to by <var>string</var> (including the
terminating null character).

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located character, or a null pointer
if <var>c</var> does not occur in <var>string</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strrchr</code> is ANSI C.

   <p><code>strrchr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strsignal"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strspn">strspn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strrchr">strrchr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.35 <code>strsignal</code>&mdash;convert signal number to string</h3>

<p><a name="index-strsignal-416"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strsignal(int <var>signal</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strsignal</code> converts the signal number <var>signal</var> into a
string.  If <var>signal</var> is not a known signal number, the result
will be of the form "Unknown signal NN" where NN is the <var>signal</var>
is a decimal number.

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to a string.  Your application must
not modify that string.

   <p><br>
<strong>Portability</strong><br>
POSIX.1-2008 C requires <code>strsignal</code>, but does not specify the strings used
for each signal number.

   <p><code>strsignal</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strspn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strstr">strstr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strsignal">strsignal</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.36 <code>strspn</code>&mdash;find initial match</h3>

<p><a name="index-strspn-417"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     size_t strspn(const char *<var>s1</var>, const char *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
This function computes the length of the initial segment of
the string pointed to by <var>s1</var> which consists entirely of
characters from the string pointed to by <var>s2</var> (excluding the
terminating null character).

   <p><br>
<strong>Returns</strong><br>
<code>strspn</code> returns the length of the segment found.

   <p><br>
<strong>Portability</strong><br>
<code>strspn</code> is ANSI C.

   <p><code>strspn</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strstr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strtok">strtok</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strspn">strspn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.37 <code>strstr</code>&mdash;find string segment</h3>

<p><a name="index-strstr-418"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strstr(const char *<var>s1</var>, const char *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
Locates the first occurrence in the string pointed to by <var>s1</var> of
the sequence of characters in the string pointed to by <var>s2</var>
(excluding the terminating null character).

   <p><br>
<strong>Returns</strong><br>
Returns a pointer to the located string segment, or a null
pointer if the string <var>s2</var> is not found. If <var>s2</var> points to
a string with zero length, <var>s1</var> is returned.

   <p><br>
<strong>Portability</strong><br>
<code>strstr</code> is ANSI C.

   <p><code>strstr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strtok"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strupr">strupr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strstr">strstr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.38 <code>strtok</code>, <code>strtok_r</code>, <code>strsep</code>&mdash;get next token from a string</h3>

<p><a name="index-strtok-419"></a><a name="index-strtok_005fr-420"></a><a name="index-strsep-421"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strtok(char *<var>source</var>, const char *<var>delimiters</var>)
     char *strtok_r(char *<var>source</var>, const char *<var>delimiters</var>,
         char **<var>lasts</var>)
     char *strsep(char **<var>source_ptr</var>, const char *<var>delimiters</var>)

</pre>
   <p><strong>Description</strong><br>
The <code>strtok</code> function is used to isolate sequential tokens in a
null-terminated string, <code>*</code><var>source</var>. These tokens are delimited
in the string by at least one of the characters in <code>*</code><var>delimiters</var>.
The first time that <code>strtok</code> is called, <code>*</code><var>source</var> should be
specified; subsequent calls, wishing to obtain further tokens from
the same string, should pass a null pointer instead.  The separator
string, <code>*</code><var>delimiters</var>, must be supplied each time and may
change between calls.

   <p>The <code>strtok</code> function returns a pointer to the beginning of each
subsequent token in the string, after replacing the separator
character itself with a null character.  When no more tokens remain,
a null pointer is returned.

   <p>The <code>strtok_r</code> function has the same behavior as <code>strtok</code>, except
a pointer to placeholder <code>*</code><var>lasts</var> must be supplied by the caller.

   <p>The <code>strsep</code> function is similar in behavior to <code>strtok</code>, except
a pointer to the string pointer must be supplied <var>source_ptr</var> and
the function does not skip leading delimiters.  When the string starts
with a delimiter, the delimiter is changed to the null character and
the empty string is returned.  Like <code>strtok_r</code> and <code>strtok</code>, the
<code>*</code><var>source_ptr</var> is updated to the next character following the
last delimiter found or NULL if the end of string is reached with
no more delimiters.

   <p><br>
<strong>Returns</strong><br>
<code>strtok</code>, <code>strtok_r</code>, and <code>strsep</code> all return a pointer to the
next token, or <code>NULL</code> if no more tokens can be found.  For
<code>strsep</code>, a token may be the empty string.

   <p><br>
<strong>Portability</strong><br>
<code>strtok</code> is ANSI C.
<code>strtok_r</code> is POSIX.
<code>strsep</code> is a BSD extension.

   <p><code>strtok</code>, <code>strtok_r</code>, and <code>strsep</code> require no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strupr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strxfrm">strxfrm</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strtok">strtok</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.39 <code>strupr</code>&mdash;force string to uppercase</h3>

<p><a name="index-strupr-422"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     char *strupr(char *<var>a</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strupr</code> converts each character in the string at <var>a</var> to
uppercase.

   <p><br>
<strong>Returns</strong><br>
<code>strupr</code> returns its argument, <var>a</var>.

   <p><br>
<strong>Portability</strong><br>
<code>strupr</code> is not widely portable.

   <p><code>strupr</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strxfrm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#swab">swab</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strupr">strupr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.40 <code>strxfrm</code>&mdash;transform string</h3>

<p><a name="index-strxfrm-423"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;string.h&gt;
     size_t strxfrm(char *<var>s1</var>, const char *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function transforms the string pointed to by <var>s2</var> and
places the resulting string into the array pointed to by
<var>s1</var>. The transformation is such that if the <code>strcmp</code>
function is applied to the two transformed strings, it returns
a value greater than, equal to, or less than zero,
correspoinding to the result of a <code>strcoll</code> function applied
to the same two original strings.

   <p>No more than <var>n</var> characters are placed into the resulting
array pointed to by <var>s1</var>, including the terminating null
character. If <var>n</var> is zero, <var>s1</var> may be a null pointer. If
copying takes place between objects that overlap, the behavior
is undefined.

   <p>With a C locale, this function just copies.

   <p><br>
<strong>Returns</strong><br>
The <code>strxfrm</code> function returns the length of the transformed string
(not including the terminating null character). If the value returned
is <var>n</var> or more, the contents of the array pointed to by
<var>s1</var> are indeterminate.

   <p><br>
<strong>Portability</strong><br>
<code>strxfrm</code> is ANSI C.

   <p><code>strxfrm</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="swab"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscasecmp">wcscasecmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strxfrm">strxfrm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.41 <code>swab</code>&mdash;swap adjacent bytes</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;unistd.h&gt;
     void swab(const void *<var>in</var>, void *<var>out</var>, ssize_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
This function copies <var>n</var> bytes from the memory region
pointed to by <var>in</var> to the memory region pointed to by
<var>out</var>, exchanging adjacent even and odd bytes.

   <p><br>
<strong>Portability</strong><br>
<code>swab</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wcscasecmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsdup">wcsdup</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#swab">swab</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.42 <code>wcscasecmp</code>&mdash;case-insensitive wide character string compare</h3>

<p><a name="index-wcscasecmp-424"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcscasecmp(const wchar_t *<var>a</var>, const wchar_t *<var>b</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcscasecmp</code> compares the wide character string at <var>a</var> to
the wide character string at <var>b</var> in a case-insensitive manner.

   <p><br>
<strong>Returns</strong><br>

   <p>If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var> (after
both are converted to uppercase), <code>wcscasecmp</code> returns a
number greater than zero.  If the two strings match,
<code>wcscasecmp</code> returns zero.  If <code>*</code><var>a</var> sorts
lexicographically before <code>*</code><var>b</var>, <code>wcscasecmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
POSIX-1.2008

   <p><code>wcscasecmp</code> requires no supporting OS subroutines. It uses
tolower() from elsewhere in this library.

   <p><br>

<div class="node">
<a name="wcsdup"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsncasecmp">wcsncasecmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscasecmp">wcscasecmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.43 <code>wcsdup</code>&mdash;wide character string duplicate</h3>

<p><a name="index-wcsdup-425"></a><a name="index-g_t_005fwcsdup_005fr-426"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcsdup(const wchar_t *<var>str</var>);

     #include &lt;wchar.h&gt;
     wchar_t *_wcsdup_r(struct _reent *<var>ptr</var>, const wchar_t *<var>str</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcsdup</code> allocates a new wide character string using <code>malloc</code>,
and copies the content of the argument <var>str</var> into the newly
allocated string, thus making a copy of <var>str</var>.

   <p><br>
<strong>Returns</strong><br>
<code>wcsdup</code> returns a pointer to the copy of <var>str</var> if enough
memory for the copy was available.  Otherwise it returns NULL
and errno is set to ENOMEM.

   <p><br>
<strong>Portability</strong><br>
POSIX-1.2008

   <p><br>

<div class="node">
<a name="wcsncasecmp"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsdup">wcsdup</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Strings">Strings</a>

</div>

<h3 class="section">6.44 <code>wcsncasecmp</code>&mdash;case-insensitive wide character string compare</h3>

<p><a name="index-wcsncasecmp-427"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcsncasecmp(const wchar_t *<var>a</var>, const wchar_t * <var>b</var>, size_t <var>length</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcsncasecmp</code> compares up to <var>length</var> wide characters
from the string at <var>a</var> to the string at <var>b</var> in a
case-insensitive manner.

   <p><br>
<strong>Returns</strong><br>

   <p>If <code>*</code><var>a</var> sorts lexicographically after <code>*</code><var>b</var> (after
both are converted to uppercase), <code>wcsncasecmp</code> returns a
number greater than zero.  If the two strings are equivalent,
<code>wcsncasecmp</code> returns zero.  If <code>*</code><var>a</var> sorts
lexicographically before <code>*</code><var>b</var>, <code>wcsncasecmp</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
POSIX-1.2008

   <p><code>wcsncasecmp</code> requires no supporting OS subroutines. It uses
tolower() from elsewhere in this library.

   <p><br>
<div class="node">
<a name="Wchar-strings"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Signals">Signals</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Strings">Strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">7 Wide Character Strings (<samp><span class="file">wchar.h</span></samp>)</h2>

<p>This chapter describes wide-character string-handling functions and
managing areas of memory containing wide characters.  The corresponding
declarations are in <samp><span class="file">wchar.h</span></samp>.

<ul class="menu">
<li><a accesskey="1" href="#wmemchr">wmemchr</a>:      Find wide character in memory
<li><a accesskey="2" href="#wmemcmp">wmemcmp</a>:      Compare two wide-character memory areas
<li><a accesskey="3" href="#wmemcpy">wmemcpy</a>:      Copy wide-character memory regions
<li><a accesskey="4" href="#wmemmove">wmemmove</a>:     Move possibly overlapping wide-character memory
<li><a accesskey="5" href="#wmemset">wmemset</a>:      Set an area of memory to a specified wide character
<li><a accesskey="6" href="#wcscat">wcscat</a>:       Concatenate wide-character strings
<li><a accesskey="7" href="#wcschr">wcschr</a>:       Search for wide character in string
<li><a accesskey="8" href="#wcscmp">wcscmp</a>:       Wide-character string compare
<li><a accesskey="9" href="#wcscoll">wcscoll</a>:      Locale-specific wide-character string compare
<li><a href="#wcscpy">wcscpy</a>:       Copy wide-character string
<li><a href="#wcpcpy">wcpcpy</a>:       Copy a wide-character string returning a pointer to its end
<li><a href="#wcscspn">wcscspn</a>:      Count wide characters not in string
<li><a href="#wcsftime">wcsftime</a>:     Convert date and time to a formatted wide-character string
<li><a href="#wcslcat">wcslcat</a>:      Concatenate wide-character strings to specified length
<li><a href="#wcslcpy">wcslcpy</a>:      Copy wide-character string to specified length
<li><a href="#wcslen">wcslen</a>:       Wide-character string length
<li><a href="#wcsncat">wcsncat</a>:      Concatenate wide-character strings
<li><a href="#wcsncmp">wcsncmp</a>:      Wide-character string compare
<li><a href="#wcsncpy">wcsncpy</a>:      Counted copy wide-character string
<li><a href="#wcpncpy">wcpncpy</a>:      Copy part of a wide-character string returning a pointer to its end
<li><a href="#wcsnlen">wcsnlen</a>:      Wide-character string length with maximum limit
<li><a href="#wcspbrk">wcspbrk</a>:      Find wide characters in string
<li><a href="#wcsrchr">wcsrchr</a>:      Reverse search for wide character in string
<li><a href="#wcsspn">wcsspn</a>:       Find initial match in wide-character string
<li><a href="#wcsstr">wcsstr</a>:       Find wide-character string segment
<li><a href="#wcstok">wcstok</a>:       Tokenize wide-character string
<li><a href="#wcswidth">wcswidth</a>:     Number of column positions of a wide-character string
<li><a href="#wcsxfrm">wcsxfrm</a>:      Locale-specific wide-character string transformation
<li><a href="#wcwidth">wcwidth</a>:      Number of column positions of a wide-character code
</ul>

<div class="node">
<a name="wmemchr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wmemcmp">wmemcmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.1 <code>wmemchr</code>&mdash;find a wide character in memory</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t	*wmemchr(const wchar_t *<var>s</var>, wchar_t <var>c</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wmemchr</code> function locates the first occurrence of <var>c</var> in the
initial <var>n</var> wide characters of the object pointed to be <var>s</var>. This
function is not affected by locale and all wchar_t values are treated
identically.  The null wide character and wchar_t values not
corresponding to valid characters are not treated specially.

   <p>If <var>n</var> is zero, <var>s</var> must be a valid pointer and the function
behaves as if no valid occurrence of <var>c</var> is found.

   <p><br>
<strong>Returns</strong><br>
The <code>wmemchr</code> function returns a pointer to the located
wide character, or a null pointer if the wide character does not occur
in the object.

   <p><br>
<strong>Portability</strong><br>
<code>wmemchr</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wmemcmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wmemcpy">wmemcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wmemchr">wmemchr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.2 <code>wmemcmp</code>&mdash;compare wide characters in memory</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wmemcmp(const wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wmemcmp</code> function compares the first <var>n</var> wide characters of the
object pointed to by <var>s1</var> to the first <var>n</var> wide characters of the
object pointed to by <var>s2</var>. This function is not affected by locale
and all wchar_t values are treated identically. The null wide character
and wchar_t values not corresponding to valid characters are not treated
specially.

   <p>If <var>n</var> is zero, <var>s1</var> and <var>s2</var> must be a valid pointers and the
function behaves as if the two objects compare equal.

   <p><br>
<strong>Returns</strong><br>
The <code>wmemcmp</code> function returns an integer greater than, equal to,
or less than zero, accordingly as the object pointed to by <var>s1</var> is
greater than, equal to, or less than the object pointed to by <var>s2</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wmemcmp</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wmemcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wmemmove">wmemmove</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wmemcmp">wmemcmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.3 <code>wmemcpy</code>&mdash;copy wide characters in memory</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wmemcpy(wchar_t *<var>d</var>, const wchar_t *<var>s</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wmemcpy</code> function copies <var>n</var> wide characters from the object
pointed to by <var>s</var> to the object pointed to be <var>d</var>. This function
is not affected by locale and all wchar_t values are treated
identically.  The null wide character and wchar_t values not
corresponding to valid characters are not treated specially.

   <p>If <var>n</var> is zero, <var>d</var> and <var>s</var> must be a valid pointers, and the
function copies zero wide characters.

   <p><br>
<strong>Returns</strong><br>
The <code>wmemcpy</code> function returns the value of <var>d</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wmemcpy</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wmemmove"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wmemset">wmemset</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wmemcpy">wmemcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.4 <code>wmemmove</code>&mdash;copy wide characters in memory with overlapping areas</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wmemmove(wchar_t *<var>d</var>, const wchar_t *<var>s</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wmemmove</code> function copies <var>n</var> wide characters from the object
pointed to by <var>s</var> to the object pointed to by <var>d</var>. Copying takes
place as if the <var>n</var> wide characters from the object pointed to by
<var>s</var> are first copied into a temporary array of <var>n</var> wide characters
that does not overlap the objects pointed to by <var>d</var> or <var>s</var>, and then
the <var>n</var> wide characters from the temporary array are copied into the
object pointed to by <var>d</var>.

   <p>This function is not affected by locale and all wchar_t values are
treated identically. The null wide character and wchar_t values not
corresponding to valid characters are not treated specially.

   <p>If <var>n</var> is zero, <var>d</var> and <var>s</var> must be a valid pointers, and the
function copies zero wide characters.

   <p><br>
<strong>Returns</strong><br>
The <code>wmemmove</code> function returns the value of <var>d</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wmemmove</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wmemset"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscat">wcscat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wmemmove">wmemmove</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.5 <code>wmemset</code>&mdash;set wide characters in memory</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wmemset(wchar_t *<var>s</var>, wchar_t <var>c</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wmemset</code> function copies the value of <var>c</var> into each of the
first <var>n</var> wide characters of the object pointed to by <var>s</var>.  This
function is not affected by locale and all wchar_t values are treated
identically.  The null wide character and wchar_t values not
corresponding to valid characters are not treated specially.

   <p>If <var>n</var> is zero, <var>s</var> must be a valid pointer and the function
copies zero wide characters.

   <p><br>
<strong>Returns</strong><br>
The <code>wmemset</code> function returns the value of <var>s</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wmemset</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcscat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcschr">wcschr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wmemset">wmemset</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.6 <code>wcscat</code>&mdash;concatenate two wide-character strings</h3>

<p><a name="index-wcscat-428"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcscat(wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcscat</code> function appends a copy of the wide-character string
pointed to by <var>s2</var> (including the terminating null wide-character
code) to the end of the wide-character string pointed to by <var>s1</var>.
The initial wide-character code of <var>s2</var> overwrites the null
wide-character code at the end of <var>s1</var>. If copying takes place between
objects that overlap, the behaviour is undefined.

   <p><br>
<strong>Returns</strong><br>
The <code>wcscat</code> function returns <var>s1</var>;
no return value is reserved to indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcscat</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcschr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscmp">wcscmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscat">wcscat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.7 <code>wcschr</code>&mdash;wide-character string scanning operation</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcschr(const wchar_t *<var>s</var>, wchar_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcschr</code> function locates the first occurrence of <var>c</var> in the
wide-character string pointed to by <var>s</var>. The value of <var>c</var> must be a
character representable as a type wchar_t and must be a wide-character
code corresponding to a valid character in the current locale.
The terminating null wide-character string.

   <p><br>
<strong>Returns</strong><br>
Upon completion, <code>wcschr</code> returns a pointer to the wide-character
code, or a null pointer if the wide-character code is not found.

   <p><br>
<strong>Portability</strong><br>
<code>wcschr</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcscmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscoll">wcscoll</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcschr">wcschr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.8 <code>wcscmp</code>&mdash;compare two wide-character strings</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcscmp(const wchar_t *<var>s1</var>, *<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcscmp</code> function compares the wide-character string pointed to
by <var>s1</var> to the wide-character string pointed to by <var>s2</var>.

   <p>The sign of a non-zero return value is determined by the sign of the
difference between the values of the first pair of wide-character codes
that differ in the objects being compared.

   <p><br>
<strong>Returns</strong><br>
Upon completion, <code>wcscmp</code> returns an integer greater than, equal to
or less than 0, if the wide-character string pointed to by <var>s1</var> is
greater than, equal to or less than the wide-character string pointed
to by <var>s2</var> respectively.

   <p><br>
<strong>Portability</strong><br>
<code>wcscmp</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcscoll"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscpy">wcscpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscmp">wcscmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.9 <code>wcscoll</code>&mdash;locale-specific wide-character string compare</h3>

<p><a name="index-wcscoll-429"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcscoll(const wchar_t *<var>stra</var>, const wchar_t * <var>strb</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcscoll</code> compares the wide-character string pointed to by
<var>stra</var> to the wide-character string pointed to by <var>strb</var>,
using an interpretation appropriate to the current <code>LC_COLLATE</code>
state.

   <p>The current implementation of <code>wcscoll</code> simply uses <code>wcscmp</code>
and does not support any language-specific sorting.

   <p><br>
<strong>Returns</strong><br>
If the first string is greater than the second string,
<code>wcscoll</code> returns a number greater than zero.  If the two
strings are equivalent, <code>wcscoll</code> returns zero.  If the first
string is less than the second string, <code>wcscoll</code> returns a
number less than zero.

   <p><br>
<strong>Portability</strong><br>
<code>wcscoll</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p><br>

<div class="node">
<a name="wcscpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcpcpy">wcpcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscoll">wcscoll</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.10 <code>wcscpy</code>&mdash;copy a wide-character string</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcscpy(wchar_t *<var>s1</var>, const wchar_t *,<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcscpy</code> function copies the wide-character string pointed to by
<var>s2</var> (including the terminating null wide-character code) into the
array pointed to by <var>s1</var>. If copying takes place between objects that
overlap, the behaviour is undefined.

   <p><br>
<strong>Returns</strong><br>
The <code>wcscpy</code> function returns <var>s1</var>; no return value is reserved to
indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcscpy</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcpcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcscspn">wcscspn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscpy">wcscpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.11 <code>wcpcpy</code>&mdash;copy a wide-character string returning a pointer to its end</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcpcpy(wchar_t *<var>s1</var>, const wchar_t *,<var>s2</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcpcpy</code> function copies the wide-character string pointed to by
<var>s2</var> (including the terminating null wide-character code) into the
array pointed to by <var>s1</var>. If copying takes place between objects that
overlap, the behaviour is undefined.

   <p><br>
<strong>Returns</strong><br>
This function returns a pointer to the end of the destination string,
thus pointing to the trailing '\0'.

   <p><br>
<strong>Portability</strong><br>
<code>wcpcpy</code> is a GNU extension.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcscspn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsftime">wcsftime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcpcpy">wcpcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.12 <code>wcscspn</code>&mdash;get length of a complementary wide substring</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcscspn(const wchar_t *<var>s</var>, wchar_t *<var>set</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcscspn</code> function computes the length of the maximum initial
segment of the wide-character string pointed to by <var>s</var> which consists
entirely of wide-character codes not from the wide-character string
pointed to by <var>set</var>.

   <p><br>
<strong>Returns</strong><br>
The <code>wcscspn</code> function returns the length of the initial substring of
<var>s1</var>; no return value is reserved to indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcscspn</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsftime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcslcat">wcslcat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcscspn">wcscspn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.13 <code>wcsftime</code>&ndash;convert date and time to a formatted wide-character string</h3>

<p><a name="index-wcsftime-430"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     #include &lt;wchar.h&gt;
     size_t wcsftime(wchar_t *<var>s</var>, size_t <var>maxsize</var>,
         const wchar_t *<var>format</var>, const struct tm *<var>timp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcsftime</code> is equivalent to <code>strftime</code>, except that:
     <ul>
<li>The argument s points to the initial element of an array of wide characters
into which the generated output is to be placed.
<li>The argument maxsize indicates the limiting number of wide characters.
<li>The argument format is a wide-character string and the conversion specifiers
are replaced by corresponding sequences of wide characters.
<li>The return value indicates the number of wide characters.
</ul>

   <p>(The difference in all of the above being wide characters versus regular
characters.)
See <code>strftime</code> for the details of the format specifiers.

   <p><br>
<strong>Returns</strong><br>
When the formatted time takes up no more than <var>maxsize</var> wide characters,
the result is the length of the formatted wide string.  Otherwise, if the
formatting operation was abandoned due to lack of room, the result is
<code>0</code>, and the wide-character string starting at <var>s</var> corresponds to just those
parts of <code>*</code><var>format</var> that could be completely filled in within the
<var>maxsize</var> limit.

   <p><br>
<strong>Portability</strong><br>
C99 and POSIX require <code>wcsftime</code>, but do not specify the contents of
<code>*</code><var>s</var> when the formatted string would require more than
<var>maxsize</var> characters.  Unrecognized specifiers and fields of
<code>timp</code> that are out of range cause undefined results.  Since some
formats expand to 0 bytes, it is wise to set <code>*</code><var>s</var> to a nonzero
value beforehand to distinguish between failure and an empty string.
This implementation does not support <code>s</code> being NULL, nor overlapping
<code>s</code> and <code>format</code>.

   <p><code>wcsftime</code> requires no supporting OS subroutines.

   <p><br>
<strong>See Also</strong><br>
<code>strftime</code>

   <p><br>

<div class="node">
<a name="wcslcat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcslcpy">wcslcpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsftime">wcsftime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.14 <code>wcslcat</code>&mdash;concatenate wide-character strings to specified length</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcslcat(wchar_t *<var>dst</var>, const wchar_t *<var>src</var>, size_t <var>siz</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcslcat</code> function appends wide characters from <var>src</var> to
end of the <var>dst</var> wide-character string so that the resultant
wide-character string is not more than <var>siz</var> wide characters
including the terminating null wide-character code.  A terminating
null wide character is always added unless <var>siz</var> is 0.  Thus,
the maximum number of wide characters that can be appended from
<var>src</var> is <var>siz</var> - 1. If copying takes place between objects
that overlap, the behaviour is undefined.

   <p><br>
<strong>Returns</strong><br>
Wide-character string length of initial <var>dst</var> plus the
wide-character string length of <var>src</var> (does not include
terminating null wide-characters).  If the return value is
greater than or equal to <var>siz</var>, then truncation occurred and
not all wide characters from <var>src</var> were appended.

   <p><br>
<strong>Portability</strong><br>
No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcslcpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcslen">wcslen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcslcat">wcslcat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.15 <code>wcslcpy</code>&mdash;copy a wide-character string to specified length</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcslcpy(wchar_t *<var>dst</var>, const wchar_t *<var>src</var>, size_t <var>siz</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcslcpy</code> copies wide characters from <var>src</var> to <var>dst</var>
such that up to <var>siz</var> - 1 characters are copied.  A
terminating null is appended to the result, unless <var>siz</var>
is zero.

   <p><br>
<strong>Returns</strong><br>
<code>wcslcpy</code> returns the number of wide characters in <var>src</var>,
not including the terminating null wide character.  If the
return value is greater than or equal to <var>siz</var>, then
not all wide characters were copied from <var>src</var> and truncation
occurred.

   <p><br>
<strong>Portability</strong><br>
No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcslen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsncat">wcsncat</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcslcpy">wcslcpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.16 <code>wcslen</code>&mdash;get wide-character string length</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcslen(const wchar_t *<var>s</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcslen</code> function computes the number of wide-character codes
in the wide-character string to which <var>s</var> points, not including the
terminating null wide-character code.

   <p><br>
<strong>Returns</strong><br>
The <code>wcslen</code> function returns the length of <var>s</var>; no return value is
reserved to indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcslen</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsncat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsncmp">wcsncmp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcslen">wcslen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.17 <code>wcsncat</code>&mdash;concatenate part of two wide-character strings</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcsncat(wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsncat</code> function appends not more than <var>n</var> wide-character
codes (a null wide-character code and wide-character codes that follow
it are not appended) from the array pointed to by <var>s2</var> to the end of
the wide-character string pointed to by <var>s1</var>. The initial
wide-character code of <var>s2</var> overwrites the null wide-character code
at the end of <var>s1</var>.
A terminating null wide-character code is always appended to the result.
If copying takes place between objects that overlap, the behaviour is
undefined.

   <p><br>
<strong>Returns</strong><br>
The <code>wcsncat</code> function returns <var>s1</var>; no return value is reserved to
indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcsncat</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsncmp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsncpy">wcsncpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsncat">wcsncat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.18 <code>wcsncmp</code>&mdash;compare part of two wide-character strings</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcsncmp(const wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsncmp</code> function compares not more than <var>n</var> wide-character
codes (wide-character codes that follow a null wide-character code are
not compared) from the array pointed to by <var>s1</var> to the array pointed
to by <var>s2</var>.

   <p>The sign of a non-zero return value is determined by the sign of the
difference between the values of the first pair of wide-character codes
that differ in the objects being compared.

   <p><br>
<strong>Returns</strong><br>
Upon successful completion, <code>wcsncmp</code> returns an integer greater than,
equal to or less than 0, if the possibly null-terminated array pointed
to by <var>s1</var> is greater than, equal to or less than the possibly
null-terminated array pointed to by <var>s2</var> respectively.

   <p><br>
<strong>Portability</strong><br>
<code>wcsncmp</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsncpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcpncpy">wcpncpy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsncmp">wcsncmp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.19 <code>wcsncpy</code>&mdash;copy part of a wide-character string</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcsncpy(wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsncpy</code> function copies not more than <var>n</var> wide-character codes
(wide-character codes that follow a null wide-character code are not
copied) from the array pointed to by <var>s2</var> to the array pointed to
by <var>s1</var>. If copying takes place between objects that overlap, the
behaviour is undefined.  Note that if <var>s1</var> contains more than <var>n</var>
wide characters before its terminating null, the result is not
null-terminated.

   <p>If the array pointed to by <var>s2</var> is a wide-character string that is
shorter than <var>n</var> wide-character codes, null wide-character codes are
appended to the copy in the array pointed to by <var>s1</var>, until <var>n</var>
wide-character codes in all are written.

   <p><br>
<strong>Returns</strong><br>
The <code>wcsncpy</code> function returns <var>s1</var>; no return value is reserved to
indicate an error.

   <p><br>
<strong>Portability</strong><br>
ISO/IEC 9899; POSIX.1.

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcpncpy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsnlen">wcsnlen</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsncpy">wcsncpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.20 <code>wcpncpy</code>&mdash;copy part of a wide-character string returning a pointer to its end</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcpncpy(wchar_t *<var>s1</var>, const wchar_t *<var>s2</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcpncpy</code> function copies not more than n wide-character codes
(wide-character codes that follow a null wide-character code are not
copied) from the array pointed to by <var>s2</var> to the array pointed to
by <var>s1</var>. If copying takes place between objects that overlap, the
behaviour is undefined.

   <p>If the array pointed to by <var>s2</var> is a wide-character string that is
shorter than <var>n</var> wide-character codes, null wide-character codes are
appended to the copy in the array pointed to by <var>s1</var>, until <var>n</var>
wide-character codes in all are written.

   <p><br>
<strong>Returns</strong><br>
The <code>wcpncpy</code> function returns <var>s1</var>; no return value is reserved to
indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcpncpy</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsnlen"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcspbrk">wcspbrk</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcpncpy">wcpncpy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.21 <code>wcsnlen</code>&mdash;get fixed-size wide-character string length</h3>

<p><a name="index-wcsnlen-431"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcsnlen(const wchar_t *<var>s</var>, size_t <var>maxlen</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsnlen</code> function computes the number of wide-character codes
in the wide-character string pointed to by <var>s</var> not including the
terminating L'\0' wide character but at most <var>maxlen</var> wide
characters.

   <p><br>
<strong>Returns</strong><br>
<code>wcsnlen</code> returns the length of <var>s</var> if it is less then <var>maxlen</var>,
or <var>maxlen</var> if there is no L'\0' wide character in first <var>maxlen</var>
characters.

   <p><br>
<strong>Portability</strong><br>
<code>wcsnlen</code> is a GNU extension.

   <p><code>wcsnlen</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wcspbrk"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsrchr">wcsrchr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsnlen">wcsnlen</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.22 <code>wcspbrk</code>&mdash;&ndash;scan wide-character string for a wide-character code</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcspbrk(const wchar_t *<var>s</var>, const wchar_t *<var>set</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcspbrk</code> function locates the first occurrence in the
wide-character string pointed to by <var>s</var> of any wide-character code
from the wide-character string pointed to by <var>set</var>.

   <p><br>
<strong>Returns</strong><br>
Upon successful completion, <code>wcspbrk</code> returns a pointer to the
wide-character code or a null pointer if no wide-character code from
<var>set</var> occurs in <var>s</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wcspbrk</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsrchr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsspn">wcsspn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcspbrk">wcspbrk</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.23 <code>wcsrchr</code>&mdash;wide-character string scanning operation</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcsrchr(const wchar_t *<var>s</var>, wchar_t <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsrchr</code> function locates the last occurrence of <var>c</var> in the
wide-character string pointed to by <var>s</var>. The value of <var>c</var> must be a
character representable as a type wchar_t and must be a wide-character
code corresponding to a valid character in the current locale.
The terminating null wide-character code is considered to be part of
the wide-character string.

   <p><br>
<strong>Returns</strong><br>
Upon successful completion, <code>wcsrchr</code> returns a pointer to the
wide-character code or a null pointer if <var>c</var> does not occur in the
wide-character string.

   <p><br>
<strong>Portability</strong><br>
<code>wcsrchr</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsspn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsstr">wcsstr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsrchr">wcsrchr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.24 <code>wcsspn</code>&mdash;get length of a wide substring</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     size_t wcsspn(const wchar_t *<var>s</var>, const wchar_t *<var>set</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsspn</code> function computes the length of the maximum initial
segment of the wide-character string pointed to by <var>s</var> which consists
entirely of wide-character codes from the wide-character string
pointed to by <var>set</var>.

   <p><br>
<strong>Returns</strong><br>
The wcsspn() function returns the length <var>s1</var>; no return value is
reserved to indicate an error.

   <p><br>
<strong>Portability</strong><br>
<code>wcsspn</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p>No supporting OS subroutines are required.

   <p><br>

<div class="node">
<a name="wcsstr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcstok">wcstok</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsspn">wcsspn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.25 <code>wcsstr</code>&mdash;find a wide-character substring</h3>

<p><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcsstr(const wchar_t *<var>big</var>, const wchar_t *<var>little</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcsstr</code> function locates the first occurrence in the
wide-character string pointed to by <var>big</var> of the sequence of
wide characters (excluding the terminating null wide character) in the
wide-character string pointed to by <var>little</var>.

   <p><br>
<strong>Returns</strong><br>
On successful completion, <code>wcsstr</code> returns a pointer to the located
wide-character string, or a null pointer if the wide-character string
is not found.

   <p>If <var>little</var> points to a wide-character string with zero length,
the function returns <var>big</var>.

   <p><br>
<strong>Portability</strong><br>
<code>wcsstr</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p><br>

<div class="node">
<a name="wcstok"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcswidth">wcswidth</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsstr">wcsstr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.26 <code>wcstok</code>&mdash;get next token from a string</h3>

<p><a name="index-wcstok-432"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     wchar_t *wcstok(wchar_t *<var>source</var>, const wchar_t *<var>delimiters</var>,
         wchar_t **<var>lasts</var>)

</pre>
   <p><strong>Description</strong><br>
The <code>wcstok</code> function is the wide-character equivalent of the
<code>strtok_r</code> function (which in turn is the same as the <code>strtok</code>
function with an added argument to make it thread-safe).

   <p>The <code>wcstok</code> function is used to isolate (one at a time)
sequential tokens in a null-terminated wide-character string,
<code>*</code><var>source</var>.  A token is defined as a substring not containing
any wide-characters from <code>*</code><var>delimiters</var>.

   <p>The first time that <code>wcstok</code> is called, <code>*</code><var>source</var> should
be specified with the wide-character string to be searched, and
<code>*</code><var>lasts</var>&ndash;but not <code>lasts</code>, which must be non-NULL&ndash;may be
random; subsequent calls, wishing to obtain further tokens from
the same string, should pass a null pointer for <code>*</code><var>source</var>
instead but must supply <code>*</code><var>lasts</var> unchanged from the last
call.  The separator wide-character string, <code>*</code><var>delimiters</var>,
must be supplied each time and may change between calls.
A pointer to placeholder <code>*</code><var>lasts</var> must be supplied by
the caller, and is set each time as needed to save the state
by <code>wcstok</code>.	Every call to <code>wcstok</code> with <code>*</code><var>source</var>
== <code>NULL</code> must pass the value of <code>*</code><var>lasts</var> as last set
by <code>wcstok</code>.

   <p>The <code>wcstok</code> function returns a pointer to the beginning of each
subsequent token in the string, after replacing the separator
wide-character itself with a null wide-character.  When no more tokens
remain, a null pointer is returned.

   <p><br>
<strong>Returns</strong><br>
<code>wcstok</code> returns a pointer to the first wide character of a token, or
<code>NULL</code> if there is no token.

   <p><br>
<strong>Portability</strong><br>
<code>wcstok</code> is C99 and POSIX.1-2001.

   <p><code>wcstok</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="wcswidth"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcsxfrm">wcsxfrm</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcstok">wcstok</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.27 <code>wcswidth</code>&mdash;number of column positions of a wide-character string</h3>

<p><a name="index-wcswidth-433"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcswidth(const wchar_t *<var>pwcs</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcswidth</code> function shall determine the number of column
positions required for <var>n</var> wide-character codes (or fewer than <var>n</var>
wide-character codes if a null wide-character code is encountered
before <var>n</var> wide-character codes are exhausted) in the string pointed
to by <var>pwcs</var>.

   <p><br>
<strong>Returns</strong><br>
The <code>wcswidth</code> function either shall return 0 (if <var>pwcs</var> points to a
null wide-character code), or return the number of column positions
to be occupied by the wide-character string pointed to by <var>pwcs</var>, or
return -1 (if any of the first <var>n</var> wide-character codes in the
wide-character string pointed to by <var>pwcs</var> is not a printable
wide-character code).

   <p><br>
<strong>Portability</strong><br>
<code>wcswidth</code> has been introduced in the Single UNIX Specification Volume 2.
<code>wcswidth</code> has been marked as an extension in the Single UNIX Specification Volume 3.

   <p><br>

<div class="node">
<a name="wcsxfrm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#wcwidth">wcwidth</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcswidth">wcswidth</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.28 <code>wcsxfrm</code>&mdash;locale-specific wide-character string transformation</h3>

<p><a name="index-wcsxfrm-434"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcsxfrm(wchar_t *<var>stra</var>, const wchar_t * <var>strb</var>, size_t <var>n</var>);

</pre>
   <p><strong>Description</strong><br>
<code>wcsxfrm</code> transforms the wide-character string pointed to by
<var>strb</var> to the wide-character string pointed to by <var>stra</var>,
Comparing two transformed wide strings with <code>wcscmp</code> should return
the same result as comparing the original strings with <code>wcscoll</code>.
No more than <var>n</var> wide characters are transformed, including the
trailing null character.

   <p>If <var>n</var> is 0, <var>stra</var> may be a NULL pointer.

   <p>The current implementation of <code>wcsxfrm</code> simply uses <code>wcslcpy</code>
and does not support any language-specific transformations.

   <p><br>
<strong>Returns</strong><br>
<code>wcsxfrm</code> returns the length of the transformed wide character
string.  if the return value is greater or equal to <var>n</var>, the
content of <var>stra</var> is undefined.

   <p><br>
<strong>Portability</strong><br>
<code>wcsxfrm</code> is ISO/IEC 9899/AMD1:1995 (ISO C).

   <p><br>

<div class="node">
<a name="wcwidth"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#wcsxfrm">wcsxfrm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Wchar-strings">Wchar strings</a>

</div>

<h3 class="section">7.29 <code>wcwidth</code>&mdash;number of column positions of a wide-character code</h3>

<p><a name="index-wcwidth-435"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;wchar.h&gt;
     int wcwidth(const wchar_t <var>wc</var>);

</pre>
   <p><strong>Description</strong><br>
The <code>wcwidth</code> function shall determine the number of column
positions required for the wide character <var>wc</var>. The application
shall ensure that the value of <var>wc</var> is a character representable
as a wchar_t, and is a wide-character code corresponding to a
valid character in the current locale.

   <p><br>
<strong>Returns</strong><br>
The <code>wcwidth</code> function shall either return 0 (if <var>wc</var> is a null
wide-character code), or return the number of column positions to
be occupied by the wide-character code <var>wc</var>, or return -1 (if <var>wc</var>
does not correspond to a printable wide-character code).

   <p><br>
<strong>Portability</strong><br>
<code>wcwidth</code> has been introduced in the Single UNIX Specification Volume 2.
<code>wcwidth</code> has been marked as an extension in the Single UNIX Specification Volume 3.

   <p><br>

<div class="node">
<a name="Signals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Timefns">Timefns</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Wchar-strings">Wchar strings</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">8 Signal Handling (<samp><span class="file">signal.h</span></samp>)</h2>

<p>A <dfn>signal</dfn> is an event that interrupts the normal flow of control
in your program.  Your operating environment normally defines the full
set of signals available (see <samp><span class="file">sys/signal.h</span></samp>), as well as the
default means of dealing with them&mdash;typically, either printing an
error message and aborting your program, or ignoring the signal.

   <p>All systems support at least the following signals:
     <dl>
<dt><code>SIGABRT</code><dd>Abnormal termination of a program; raised by the &lt;&lt;abort&gt;&gt; function.

     <br><dt><code>SIGFPE</code><dd>A domain error in arithmetic, such as overflow, or division by zero.

     <br><dt><code>SIGILL</code><dd>Attempt to execute as a function data that is not executable.

     <br><dt><code>SIGINT</code><dd>Interrupt; an interactive attention signal.

     <br><dt><code>SIGSEGV</code><dd>An attempt to access a memory location that is not available.

     <br><dt><code>SIGTERM</code><dd>A request that your program end execution.
</dl>

   <p>Two functions are available for dealing with asynchronous
signals&mdash;one to allow your program to send signals to itself (this is
called <dfn>raising</dfn> a signal), and one to specify subroutines (called
<dfn>handlers</dfn> to handle particular signals that you anticipate may
occur&mdash;whether raised by your own program or the operating environment.

   <p>To support these functions, <samp><span class="file">signal.h</span></samp> defines three macros:

     <dl>
<dt><code>SIG_DFL</code><dd>Used with the <code>signal</code> function in place of a pointer to a
handler subroutine, to select the operating environment's default
handling of a signal.

     <br><dt><code>SIG_IGN</code><dd>Used with the <code>signal</code> function in place of a pointer to a
handler, to ignore a particular signal.

     <br><dt><code>SIG_ERR</code><dd>Returned by the <code>signal</code> function in place of a pointer to a
handler, to indicate that your request to set up a handler could not
be honored for some reason.
</dl>

   <p><samp><span class="file">signal.h</span></samp> also defines an integral type, <code>sig_atomic_t</code>.
This type is not used in any function declarations; it exists only to
allow your signal handlers to declare a static storage location where
they may store a signal value.  (Static storage is not otherwise
reliable from signal handlers.)

<ul class="menu">
<li><a accesskey="1" href="#raise">raise</a>:    Send a signal
<li><a accesskey="2" href="#signal">signal</a>:   Specify handler subroutine for a signal
</ul>

<div class="node">
<a name="raise"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#signal">signal</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Signals">Signals</a>

</div>

<h3 class="section">8.1 <code>raise</code>&mdash;send a signal</h3>

<p><a name="index-raise-436"></a><a name="index-g_t_005fraise_005fr-437"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;signal.h&gt;
     int raise(int <var>sig</var>);

     int _raise_r(void *<var>reent</var>, int <var>sig</var>);

</pre>
   <p><strong>Description</strong><br>
Send the signal <var>sig</var> (one of the macros from `<code>sys/signal.h</code>').
This interrupts your program's normal flow of execution, and allows a signal
handler (if you've defined one, using <code>signal</code>) to take control.

   <p>The alternate function <code>_raise_r</code> is a reentrant version.  The extra
argument <var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
The result is <code>0</code> if <var>sig</var> was successfully raised, <code>1</code>
otherwise.  However, the return value (since it depends on the normal
flow of execution) may not be visible, unless the signal handler for
<var>sig</var> terminates with a <code>return</code> or unless <code>SIG_IGN</code> is in
effect for this signal.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>raise</code>, but allows the full set of signal numbers
to vary from one implementation to another.

   <p>Required OS subroutines: <code>getpid</code>, <code>kill</code>.

   <p><br>

<div class="node">
<a name="signal"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#raise">raise</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Signals">Signals</a>

</div>

<h3 class="section">8.2 <code>signal</code>&mdash;specify handler subroutine for a signal</h3>

<p><a name="index-signal-438"></a><a name="index-g_t_005fsignal_005fr-439"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;signal.h&gt;
     void (*signal(int <var>sig</var>, void(*<var>func</var>)(int))) (int);

     void (*_signal_r(void *<var>reent</var>, int <var>sig</var>, void(*<var>func</var>)(int))) (int);

</pre>
   <p><strong>Description</strong><br>
<code>signal</code> provides a simple signal-handling implementation for embedded
targets.

   <p><code>signal</code> allows you to request changed treatment for a particular
signal <var>sig</var>.  You can use one of the predefined macros <code>SIG_DFL</code>
(select system default handling) or <code>SIG_IGN</code> (ignore this signal)
as the value of <var>func</var>; otherwise, <var>func</var> is a function pointer
that identifies a subroutine in your program as the handler for this signal.

   <p>Some of the execution environment for signal handlers is
unpredictable; notably, the only library function required to work
correctly from within a signal handler is <code>signal</code> itself, and
only when used to redefine the handler for the current signal value.

   <p>Static storage is likewise unreliable for signal handlers, with one
exception: if you declare a static storage location as `<code>volatile
sig_atomic_t</code>', then you may use that location in a signal handler to
store signal values.

   <p>If your signal handler terminates using <code>return</code> (or implicit
return), your program's execution continues at the point
where it was when the signal was raised (whether by your program
itself, or by an external event).  Signal handlers can also
use functions such as <code>exit</code> and <code>abort</code> to avoid returning.

   <p>The alternate function <code>_signal_r</code> is the reentrant version.
The extra argument <var>reent</var> is a pointer to a reentrancy structure.

<!-- FIXME: do we have setjmp.h and assoc fns? -->
   <p><br>
<strong>Returns</strong><br>
If your request for a signal handler cannot be honored, the result is
<code>SIG_ERR</code>; a specific error number is also recorded in <code>errno</code>.

   <p>Otherwise, the result is the previous handler (a function pointer or
one of the predefined macros).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>signal</code>.

   <p>No supporting OS subroutines are required to link with <code>signal</code>, but
it will not have any useful effects, except for software generated signals,
without an operating system that can actually raise exceptions.

   <p><br>
<div class="node">
<a name="Timefns"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Locale">Locale</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Signals">Signals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">9 Time Functions (<samp><span class="file">time.h</span></samp>)</h2>

<p>This chapter groups functions used either for reporting on time
(elapsed, current, or compute time) or to perform calculations based
on time.

   <p>The header file <samp><span class="file">time.h</span></samp> defines three types.  <code>clock_t</code> and
<code>time_t</code> are both used for representations of time particularly
suitable for arithmetic.  (In this implementation, quantities of type
<code>clock_t</code> have the highest resolution possible on your machine,
and quantities of type <code>time_t</code> resolve to seconds.)  <code>size_t</code>
is also defined if necessary for quantities representing sizes.

   <p><samp><span class="file">time.h</span></samp> also defines the structure <code>tm</code> for the traditional
representation of Gregorian calendar time as a series of numbers, with
the following fields:

     <dl>
<dt><code>tm_sec</code><dd>Seconds, between 0 and 60 inclusive (60 allows for leap seconds).

     <br><dt><code>tm_min</code><dd>Minutes, between 0 and 59 inclusive.

     <br><dt><code>tm_hour</code><dd>Hours, between 0 and 23 inclusive.

     <br><dt><code>tm_mday</code><dd>Day of the month, between 1 and 31 inclusive.

     <br><dt><code>tm_mon</code><dd>Month, between 0 (January) and 11 (December).

     <br><dt><code>tm_year</code><dd>Year (since 1900), can be negative for earlier years.

     <br><dt><code>tm_wday</code><dd>Day of week, between 0 (Sunday) and 6 (Saturday).

     <br><dt><code>tm_yday</code><dd>Number of days elapsed since last January 1, between 0 and 365 inclusive.

     <br><dt><code>tm_isdst</code><dd>Daylight Savings Time flag: positive means DST in effect, zero means DST
not in effect, negative means no information about DST is available.
Although for mktime(), negative means that it should decide if DST is in
effect or not.
</dl>

<ul class="menu">
<li><a accesskey="1" href="#asctime">asctime</a>:      Format time as string
<li><a accesskey="2" href="#clock">clock</a>:        Cumulative processor time
<li><a accesskey="3" href="#ctime">ctime</a>:        Convert time to local and format as string
<li><a accesskey="4" href="#difftime">difftime</a>:     Subtract two times
<li><a accesskey="5" href="#gmtime">gmtime</a>:       Convert time to UTC (GMT) traditional representation
<li><a accesskey="6" href="#localtime">localtime</a>:    Convert time to local representation
<li><a accesskey="7" href="#mktime">mktime</a>:       Convert time to arithmetic representation
<li><a accesskey="8" href="#strftime">strftime</a>:     Convert date and time to a user-formatted string
<li><a accesskey="9" href="#time">time</a>:         Get current calendar time (as single number)
<li><a href="#g_t_005f_005ftz_005flock">__tz_lock</a>:    Lock time zone global variables
<li><a href="#tzset">tzset</a>:        Set timezone info
</ul>

<div class="node">
<a name="asctime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#clock">clock</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.1 <code>asctime</code>&mdash;format time as string</h3>

<p><a name="index-asctime-440"></a><a name="index-g_t_005fasctime_005fr-441"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     char *asctime(const struct tm *<var>clock</var>);
     char *_asctime_r(const struct tm *<var>clock</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
Format the time value at <var>clock</var> into a string of the form
<pre class="smallexample">      Wed Jun 15 11:38:07 1988\n\0
</pre>
   <p>The string is generated in a static buffer; each call to <code>asctime</code>
overwrites the string generated by previous calls.

   <p><br>
<strong>Returns</strong><br>
A pointer to the string containing a formatted timestamp.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>asctime</code>.

   <p><code>asctime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="clock"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#ctime">ctime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#asctime">asctime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.2 <code>clock</code>&mdash;cumulative processor time</h3>

<p><a name="index-clock-442"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     clock_t clock(void);

</pre>
   <p><strong>Description</strong><br>
Calculates the best available approximation of the cumulative amount
of time used by your program since it started.  To convert the result
into seconds, divide by the macro <code>CLOCKS_PER_SEC</code>.

   <p><br>
<strong>Returns</strong><br>
The amount of processor time used so far by your program, in units
defined by the machine-dependent macro <code>CLOCKS_PER_SEC</code>.  If no
measurement is available, the result is (clock_t)<code>-1</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>clock</code> and <code>CLOCKS_PER_SEC</code>.

   <p>Supporting OS subroutine required: <code>times</code>.

   <p><br>

<div class="node">
<a name="ctime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#difftime">difftime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#clock">clock</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.3 <code>ctime</code>&mdash;convert time to local and format as string</h3>

<p><a name="index-ctime-443"></a><a name="index-ctime_005fr-444"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     char *ctime(const time_t *<var>clock</var>);
     char *ctime_r(const time_t *<var>clock</var>, char *<var>buf</var>);

</pre>
   <p><strong>Description</strong><br>
Convert the time value at <var>clock</var> to local time (like <code>localtime</code>)
and format it into a string of the form
<pre class="smallexample">      Wed Jun 15 11:38:07 1988\n\0
</pre>
   <p>(like <code>asctime</code>).

   <p><br>
<strong>Returns</strong><br>
A pointer to the string containing a formatted timestamp.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>ctime</code>.

   <p><code>ctime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="difftime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#gmtime">gmtime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ctime">ctime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.4 <code>difftime</code>&mdash;subtract two times</h3>

<p><a name="index-difftime-445"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     double difftime(time_t <var>tim1</var>, time_t <var>tim2</var>);

</pre>
   <p><strong>Description</strong><br>
Subtracts the two times in the arguments: `<var>tim1</var><code> - </code><var>tim2</var>'.

   <p><br>
<strong>Returns</strong><br>
The difference (in seconds) between <var>tim2</var> and <var>tim1</var>, as a <code>double</code>.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>difftime</code>, and defines its result to be in seconds
in all implementations.

   <p><code>difftime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="gmtime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#localtime">localtime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#difftime">difftime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.5 <code>gmtime</code>&mdash;convert time to UTC traditional form</h3>

<p><a name="index-gmtime-446"></a><a name="index-gmtime_005fr-447"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     struct tm *gmtime(const time_t *<var>clock</var>);
     struct tm *gmtime_r(const time_t *<var>clock</var>, struct tm *<var>res</var>);

</pre>
   <p><strong>Description</strong><br>
<code>gmtime</code> takes the time at <var>clock</var> representing the number
of elapsed seconds since 00:00:00 on January 1, 1970, Universal
Coordinated Time (UTC, also known in some countries as GMT,
Greenwich Mean time) and converts it to a <code>struct tm</code>
representation.

   <p><code>gmtime</code> constructs the traditional time representation in static
storage; each call to <code>gmtime</code> or <code>localtime</code> will overwrite the
information generated by previous calls to either function.

   <p><br>
<strong>Returns</strong><br>
A pointer to the traditional time representation (<code>struct tm</code>).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>gmtime</code>.

   <p><code>gmtime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="localtime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#mktime">mktime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#gmtime">gmtime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.6 <code>localtime</code>&mdash;convert time to local representation</h3>

<p><a name="index-localtime-448"></a><a name="index-localtime_005fr-449"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     struct tm *localtime(time_t *<var>clock</var>);
     struct tm *localtime_r(time_t *<var>clock</var>, struct tm *<var>res</var>);

</pre>
   <p><strong>Description</strong><br>
<code>localtime</code> converts the time at <var>clock</var> into local time, then
converts its representation from the arithmetic representation to the
traditional representation defined by <code>struct tm</code>.

   <p><code>localtime</code> constructs the traditional time representation in static
storage; each call to <code>gmtime</code> or <code>localtime</code> will overwrite the
information generated by previous calls to either function.

   <p><code>mktime</code> is the inverse of <code>localtime</code>.

   <p><br>
<strong>Returns</strong><br>
A pointer to the traditional time representation (<code>struct tm</code>).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>localtime</code>.

   <p><code>localtime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="mktime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#strftime">strftime</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#localtime">localtime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.7 <code>mktime</code>&mdash;convert time to arithmetic representation</h3>

<p><a name="index-mktime-450"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     time_t mktime(struct tm *<var>timp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>mktime</code> assumes the time at <var>timp</var> is a local time, and converts
its representation from the traditional representation defined by
<code>struct tm</code> into a representation suitable for arithmetic.

   <p><code>localtime</code> is the inverse of <code>mktime</code>.

   <p><br>
<strong>Returns</strong><br>
If the contents of the structure at <var>timp</var> do not form a valid
calendar time representation, the result is <code>-1</code>.  Otherwise, the
result is the time, converted to a <code>time_t</code> value.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>mktime</code>.

   <p><code>mktime</code> requires no supporting OS subroutines.

   <p><br>

<div class="node">
<a name="strftime"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#time">time</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#mktime">mktime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.8 <code>strftime</code>&mdash;convert date and time to a formatted string</h3>

<p><a name="index-strftime-451"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     size_t strftime(char *<var>s</var>, size_t <var>maxsize</var>,
         const char *<var>format</var>, const struct tm *<var>timp</var>);

</pre>
   <p><strong>Description</strong><br>
<code>strftime</code> converts a <code>struct tm</code> representation of the time (at
<var>timp</var>) into a null-terminated string, starting at <var>s</var> and occupying
no more than <var>maxsize</var> characters.

   <p>You control the format of the output using the string at <var>format</var>.
<code>*</code><var>format</var> can contain two kinds of specifications: text to be
copied literally into the formatted string, and time conversion
specifications.  Time conversion specifications are two- and
three-character sequences beginning with `<code>%</code>' (use `<code>%%</code>' to
include a percent sign in the output).  Each defined conversion
specification selects only the specified field(s) of calendar time
data from <code>*</code><var>timp</var>, and converts it to a string in one of the
following ways:

     <dl>
<dt><code>%a</code><dd>The abbreviated weekday name according to the current locale. [tm_wday]

     <br><dt><code>%A</code><dd>The full weekday name according to the current locale.
In the default "C" locale, one of `<code>Sunday</code>', `<code>Monday</code>', `<code>Tuesday</code>',
`<code>Wednesday</code>', `<code>Thursday</code>', `<code>Friday</code>', `<code>Saturday</code>'. [tm_wday]

     <br><dt><code>%b</code><dd>The abbreviated month name according to the current locale. [tm_mon]

     <br><dt><code>%B</code><dd>The full month name according to the current locale.
In the default "C" locale, one of `<code>January</code>', `<code>February</code>',
`<code>March</code>', `<code>April</code>', `<code>May</code>', `<code>June</code>', `<code>July</code>',
`<code>August</code>', `<code>September</code>', `<code>October</code>', `<code>November</code>',
`<code>December</code>'. [tm_mon]

     <br><dt><code>%c</code><dd>The preferred date and time representation for the current locale.
[tm_sec, tm_min, tm_hour, tm_mday, tm_mon, tm_year, tm_wday]

     <br><dt><code>%C</code><dd>The century, that is, the year divided by 100 then truncated.  For
4-digit years, the result is zero-padded and exactly two characters;
but for other years, there may a negative sign or more digits.  In
this way, `<code>%C%y</code>' is equivalent to `<code>%Y</code>'. [tm_year]
<br><dt><code>%d</code><dd>The day of the month, formatted with two digits (from `<code>01</code>' to
`<code>31</code>'). [tm_mday]

     <br><dt><code>%D</code><dd>A string representing the date, in the form `<code>"%m/%d/%y"</code>'.
[tm_mday, tm_mon, tm_year]

     <br><dt><code>%e</code><dd>The day of the month, formatted with leading space if single digit
(from `<code>1</code>' to `<code>31</code>'). [tm_mday]

     <br><dt><code>%Ex</code><dd>In some locales, the E modifier selects alternative representations of
certain modifiers <code>x</code>.  In newlib, it is ignored, and treated as %<code>x</code>.

     <br><dt><code>%F</code><dd>A string representing the ISO 8601:2000 date format, in the form
`<code>"%Y-%m-%d"</code>'. [tm_mday, tm_mon, tm_year]

     <br><dt><code>%g</code><dd>The last two digits of the week-based year, see specifier %G (from
`<code>00</code>' to `<code>99</code>'). [tm_year, tm_wday, tm_yday]

     <br><dt><code>%G</code><dd>The week-based year. In the ISO 8601:2000 calendar, week 1 of the year
includes January 4th, and begin on Mondays. Therefore, if January 1st,
2nd, or 3rd falls on a Sunday, that day and earlier belong to the last
week of the previous year; and if December 29th, 30th, or 31st falls
on Monday, that day and later belong to week 1 of the next year.  For
consistency with %Y, it always has at least four characters.
Example: "%G" for Saturday 2nd January 1999 gives "1998", and for
Tuesday 30th December 1997 gives "1998". [tm_year, tm_wday, tm_yday]

     <br><dt><code>%h</code><dd>Synonym for "%b". [tm_mon]

     <br><dt><code>%H</code><dd>The hour (on a 24-hour clock), formatted with two digits (from
`<code>00</code>' to `<code>23</code>'). [tm_hour]

     <br><dt><code>%I</code><dd>The hour (on a 12-hour clock), formatted with two digits (from
`<code>01</code>' to `<code>12</code>'). [tm_hour]

     <br><dt><code>%j</code><dd>The count of days in the year, formatted with three digits
(from `<code>001</code>' to `<code>366</code>'). [tm_yday]

     <br><dt><code>%k</code><dd>The hour (on a 24-hour clock), formatted with leading space if single
digit (from `<code>0</code>' to `<code>23</code>'). Non-POSIX extension (c.p. %I). [tm_hour]

     <br><dt><code>%l</code><dd>The hour (on a 12-hour clock), formatted with leading space if single
digit (from `<code>1</code>' to `<code>12</code>'). Non-POSIX extension (c.p. %H). [tm_hour]

     <br><dt><code>%m</code><dd>The month number, formatted with two digits (from `<code>01</code>' to `<code>12</code>').
[tm_mon]

     <br><dt><code>%M</code><dd>The minute, formatted with two digits (from `<code>00</code>' to `<code>59</code>'). [tm_min]

     <br><dt><code>%n</code><dd>A newline character (`<code>\n</code>').

     <br><dt><code>%Ox</code><dd>In some locales, the O modifier selects alternative digit characters
for certain modifiers <code>x</code>.  In newlib, it is ignored, and treated as %<code>x</code>.

     <br><dt><code>%p</code><dd>Either `<code>AM</code>' or `<code>PM</code>' as appropriate, or the corresponding strings for
the current locale. [tm_hour]

     <br><dt><code>%P</code><dd>Same as '<code>%p</code>', but in lowercase.  This is a GNU extension. [tm_hour]

     <br><dt><code>%r</code><dd>Replaced by the time in a.m. and p.m. notation.  In the "C" locale this
is equivalent to "%I:%M:%S %p".  In locales which don't define a.m./p.m.
notations, the result is an empty string. [tm_sec, tm_min, tm_hour]

     <br><dt><code>%R</code><dd>The 24-hour time, to the minute.  Equivalent to "%H:%M". [tm_min, tm_hour]

     <br><dt><code>%S</code><dd>The second, formatted with two digits (from `<code>00</code>' to `<code>60</code>').  The
value 60 accounts for the occasional leap second. [tm_sec]

     <br><dt><code>%t</code><dd>A tab character (`<code>\t</code>').

     <br><dt><code>%T</code><dd>The 24-hour time, to the second.  Equivalent to "%H:%M:%S". [tm_sec,
tm_min, tm_hour]

     <br><dt><code>%u</code><dd>The weekday as a number, 1-based from Monday (from `<code>1</code>' to
`<code>7</code>'). [tm_wday]

     <br><dt><code>%U</code><dd>The week number, where weeks start on Sunday, week 1 contains the first
Sunday in a year, and earlier days are in week 0.  Formatted with two
digits (from `<code>00</code>' to `<code>53</code>').  See also <code>%W</code>. [tm_wday, tm_yday]

     <br><dt><code>%V</code><dd>The week number, where weeks start on Monday, week 1 contains January 4th,
and earlier days are in the previous year.  Formatted with two digits
(from `<code>01</code>' to `<code>53</code>').  See also <code>%G</code>. [tm_year, tm_wday, tm_yday]

     <br><dt><code>%w</code><dd>The weekday as a number, 0-based from Sunday (from `<code>0</code>' to `<code>6</code>').
[tm_wday]

     <br><dt><code>%W</code><dd>The week number, where weeks start on Monday, week 1 contains the first
Monday in a year, and earlier days are in week 0.  Formatted with two
digits (from `<code>00</code>' to `<code>53</code>'). [tm_wday, tm_yday]

     <br><dt><code>%x</code><dd>Replaced by the preferred date representation in the current locale.
In the "C" locale this is equivalent to "%m/%d/%y".
[tm_mon, tm_mday, tm_year]

     <br><dt><code>%X</code><dd>Replaced by the preferred time representation in the current locale.
In the "C" locale this is equivalent to "%H:%M:%S". [tm_sec, tm_min, tm_hour]

     <br><dt><code>%y</code><dd>The last two digits of the year (from `<code>00</code>' to `<code>99</code>'). [tm_year]
(Implementation interpretation:  always positive, even for negative years.)

     <br><dt><code>%Y</code><dd>The full year, equivalent to <code>%C%y</code>.  It will always have at least four
characters, but may have more.  The year is accurate even when tm_year
added to the offset of 1900 overflows an int. [tm_year]

     <br><dt><code>%z</code><dd>The offset from UTC.  The format consists of a sign (negative is west of
Greewich), two characters for hour, then two characters for minutes
(-hhmm or +hhmm).  If tm_isdst is negative, the offset is unknown and no
output is generated; if it is zero, the offset is the standard offset for
the current time zone; and if it is positive, the offset is the daylight
savings offset for the current timezone. The offset is determined from
the TZ environment variable, as if by calling tzset(). [tm_isdst]

     <br><dt><code>%Z</code><dd>The time zone name.  If tm_isdst is negative, no output is generated.
Otherwise, the time zone name is based on the TZ environment variable,
as if by calling tzset(). [tm_isdst]

     <br><dt><code>%%</code><dd>A single character, `<code>%</code>'.
</dl>

   <p><br>
<strong>Returns</strong><br>
When the formatted time takes up no more than <var>maxsize</var> characters,
the result is the length of the formatted string.  Otherwise, if the
formatting operation was abandoned due to lack of room, the result is
<code>0</code>, and the string starting at <var>s</var> corresponds to just those
parts of <code>*</code><var>format</var> that could be completely filled in within the
<var>maxsize</var> limit.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>strftime</code>, but does not specify the contents of
<code>*</code><var>s</var> when the formatted string would require more than
<var>maxsize</var> characters.  Unrecognized specifiers and fields of
<code>timp</code> that are out of range cause undefined results.  Since some
formats expand to 0 bytes, it is wise to set <code>*</code><var>s</var> to a nonzero
value beforehand to distinguish between failure and an empty string.
This implementation does not support <code>s</code> being NULL, nor overlapping
<code>s</code> and <code>format</code>.

   <p><code>strftime</code> requires no supporting OS subroutines.

   <p><br>
<strong>Bugs</strong><br>
<code>strftime</code> ignores the LC_TIME category of the current locale, hard-coding
the "C" locale settings.

   <p><br>

<div class="node">
<a name="time"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#g_t_005f_005ftz_005flock">__tz_lock</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#strftime">strftime</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.9 <code>time</code>&mdash;get current calendar time (as single number)</h3>

<p><a name="index-time-452"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     time_t time(time_t *<var>t</var>);

</pre>
   <p><strong>Description</strong><br>
<code>time</code> looks up the best available representation of the current
time and returns it, encoded as a <code>time_t</code>.  It stores the same
value at <var>t</var> unless the argument is <code>NULL</code>.

   <p><br>
<strong>Returns</strong><br>
A <code>-1</code> result means the current time is not available; otherwise the
result represents the current time.

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>time</code>.

   <p>Supporting OS subroutine required: Some implementations require
<code>gettimeofday</code>.

   <p><br>

<div class="node">
<a name="__tz_lock"></a>
<a name="g_t_005f_005ftz_005flock"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#tzset">tzset</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#time">time</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.10 <code>__tz_lock</code>, <code>__tz_unlock</code>&mdash;lock time zone global variables</h3>

<p><a name="index-g_t_005f_005ftz_005flock-453"></a><a name="index-g_t_005f_005ftz_005funlock-454"></a><strong>Synopsis</strong>
<pre class="example">     #include "local.h"
     void __tz_lock (void);
     void __tz_unlock (void);

</pre>
   <p><strong>Description</strong><br>
The <code>tzset</code> facility functions call these functions when they need to
ensure the values of global variables.  The version of these routines
supplied in the library use the lock API defined in sys/lock.h.  If multiple
threads of execution can call the time functions and give up scheduling in
the middle, then you you need to define your own versions of these functions
in order to safely lock the time zone variables during a call.  If you do
not, the results of <code>localtime</code>, <code>mktime</code>, <code>ctime</code>, and <code>strftime</code>
are undefined.

   <p>The lock <code>__tz_lock</code> may not be called recursively; that is,
a call <code>__tz_lock</code> will always lock all subsequent <code>__tz_lock</code> calls
until the corresponding <code>__tz_unlock</code> call on the same thread is made.

   <p><br>

<div class="node">
<a name="tzset"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#g_t_005f_005ftz_005flock">__tz_lock</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Timefns">Timefns</a>

</div>

<h3 class="section">9.11 <code>tzset</code>&mdash;set timezone characteristics from TZ environment variable</h3>

<p><a name="index-tzset-455"></a><a name="index-g_t_005ftzset_005fr-456"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;time.h&gt;
     void tzset(void);
     void _tzset_r (struct _reent *);

</pre>
   <p><strong>Description</strong><br>
<code>tzset</code> examines the TZ environment variable and sets up the three
external variables: <code>_timezone</code>, <code>_daylight</code>, and <code>tzname</code>.  The
value of <code>_timezone</code> shall be the offset from the current time zone
to GMT.  The value of <code>_daylight</code> shall be 0 if there is no daylight
savings time for the current time zone, otherwise it will be non-zero.
The <code>tzname</code> array has two entries: the first is the name of the
standard time zone, the second is the name of the daylight-savings time
zone.

   <p>The TZ environment variable is expected to be in the following POSIX
format:

   <p>stdoffset1[dst[offset2][,start[/time1],end[/time2]]]

   <p>where: std is the name of the standard time-zone (minimum 3 chars)
offset1 is the value to add to local time to arrive at Universal time
it has the form:  hh[:mm[:ss]]
dst is the name of the alternate (daylight-savings) time-zone (min 3 chars)
offset2 is the value to add to local time to arrive at Universal time
it has the same format as the std offset
start is the day that the alternate time-zone starts
time1 is the optional time that the alternate time-zone starts
(this is in local time and defaults to 02:00:00 if not specified)
end is the day that the alternate time-zone ends
time2 is the time that the alternate time-zone ends
(it is in local time and defaults to 02:00:00 if not specified)

   <p>Note that there is no white-space padding between fields.  Also note that
if TZ is null, the default is Universal GMT which has no daylight-savings
time.  If TZ is empty, the default EST5EDT is used.

   <p>The function <code>_tzset_r</code> is identical to <code>tzset</code> only it is reentrant
and is used for applications that use multiple threads.

   <p><br>
<strong>Returns</strong><br>
There is no return value.

   <p><br>
<strong>Portability</strong><br>
<code>tzset</code> is part of the POSIX standard.

   <p>Supporting OS subroutine required: None

   <p><br>
<div class="node">
<a name="Locale"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reentrancy">Reentrancy</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Timefns">Timefns</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">10 Locale (<samp><span class="file">locale.h</span></samp>)</h2>

<p>A <dfn>locale</dfn> is the name for a collection of parameters (affecting
collating sequences and formatting conventions) that may be different
depending on location or culture.  The <code>"C"</code> locale is the only
one defined in the ANSI C standard.

   <p>This is a minimal implementation, supporting only the required <code>"C"</code>
value for locale; strings representing other locales are not
honored.  (<code>""</code> is also accepted; it represents the default locale
for an implementation, here equivalent to <code>"C"</code>.

   <p><samp><span class="file">locale.h</span></samp> defines the structure <code>lconv</code> to collect the
information on a locale, with the following fields:

     <dl>
<dt><code>char *decimal_point</code><dd>The decimal point character used to format &ldquo;ordinary&rdquo; numbers (all
numbers except those referring to amounts of money).  <code>"."</code> in the
C locale.

     <br><dt><code>char *thousands_sep</code><dd>The character (if any) used to separate groups of digits, when
formatting ordinary numbers.
<code>""</code> in the C locale.

     <br><dt><code>char *grouping</code><dd>Specifications for how many digits to group (if any grouping is done at
all) when formatting ordinary numbers.  The <em>numeric value</em> of each
character in the string represents the number of digits for the next
group, and a value of <code>0</code> (that is, the string's trailing
<code>NULL</code>) means to continue grouping digits using the last value
specified.  Use <code>CHAR_MAX</code> to indicate that no further grouping is
desired.  <code>""</code> in the C locale.

     <br><dt><code>char *int_curr_symbol</code><dd>The international currency symbol (first three characters), if any, and
the character used to separate it from numbers.
<code>""</code> in the C locale.

     <br><dt><code>char *currency_symbol</code><dd>The local currency symbol, if any.
<code>""</code> in the C locale.

     <br><dt><code>char *mon_decimal_point</code><dd>The symbol used to delimit fractions in amounts of money.
<code>""</code> in the C locale.

     <br><dt><code>char *mon_thousands_sep</code><dd>Similar to <code>thousands_sep</code>, but used for amounts of money.
<code>""</code> in the C locale.

     <br><dt><code>char *mon_grouping</code><dd>Similar to <code>grouping</code>, but used for amounts of money.
<code>""</code> in the C locale.

     <br><dt><code>char *positive_sign</code><dd>A string to flag positive amounts of money when formatting.
<code>""</code> in the C locale.

     <br><dt><code>char *negative_sign</code><dd>A string to flag negative amounts of money when formatting.
<code>""</code> in the C locale.

     <br><dt><code>char int_frac_digits</code><dd>The number of digits to display when formatting amounts of money to
international conventions.
<code>CHAR_MAX</code> (the largest number representable as a <code>char</code>) in
the C locale.

     <br><dt><code>char frac_digits</code><dd>The number of digits to display when formatting amounts of money to
local conventions.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char p_cs_precedes</code><dd><code>1</code> indicates the local currency symbol is used before a
<em>positive or zero</em> formatted amount of money; <code>0</code> indicates
the currency symbol is placed after the formatted number.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char p_sep_by_space</code><dd><code>1</code> indicates the local currency symbol must be separated from
<em>positive or zero</em> numbers by a space; <code>0</code> indicates that it
is immediately adjacent to numbers.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char n_cs_precedes</code><dd><code>1</code> indicates the local currency symbol is used before a
<em>negative</em> formatted amount of money; <code>0</code> indicates
the currency symbol is placed after the formatted number.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char n_sep_by_space</code><dd><code>1</code> indicates the local currency symbol must be separated from
<em>negative</em> numbers by a space; <code>0</code> indicates that it
is immediately adjacent to numbers.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char p_sign_posn</code><dd>Controls the position of the <em>positive</em> sign for
numbers representing money.  <code>0</code> means parentheses surround the
number; <code>1</code> means the sign is placed before both the number and the
currency symbol; <code>2</code> means the sign is placed after both the number
and the currency symbol; <code>3</code> means the sign is placed just before
the currency symbol; and <code>4</code> means the sign is placed just after
the currency symbol.
<code>CHAR_MAX</code> in the C locale.

     <br><dt><code>char n_sign_posn</code><dd>Controls the position of the <em>negative</em> sign for numbers
representing money, using the same rules as <code>p_sign_posn</code>.
<code>CHAR_MAX</code> in the C locale.
</dl>

<ul class="menu">
<li><a accesskey="1" href="#setlocale">setlocale</a>:   Select or query locale
</ul>

<div class="node">
<a name="setlocale"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#Locale">Locale</a>

</div>

<h3 class="section">10.1 <code>setlocale</code>, <code>localeconv</code>&mdash;select or query locale</h3>

<p><a name="index-setlocale-457"></a><a name="index-localeconv-458"></a><a name="index-g_t_005fsetlocale_005fr-459"></a><a name="index-g_t_005flocaleconv_005fr-460"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;locale.h&gt;
     char *setlocale(int <var>category</var>, const char *<var>locale</var>);
     lconv *localeconv(void);

     char *_setlocale_r(void *<var>reent</var>,
         int <var>category</var>, const char *<var>locale</var>);
     lconv *_localeconv_r(void *<var>reent</var>);

</pre>
   <p><strong>Description</strong><br>
<code>setlocale</code> is the facility defined by ANSI C to condition the
execution environment for international collating and formatting
information; <code>localeconv</code> reports on the settings of the current
locale.

   <p>This is a minimal implementation, supporting only the required <code>"POSIX"</code>
and <code>"C"</code> values for <var>locale</var>; strings representing other locales are not
honored unless _MB_CAPABLE is defined.

   <p>If _MB_CAPABLE is defined, POSIX locale strings are allowed, following
the form

   <p>language[_TERRITORY][.charset][@modifier]

   <p><code>"language"</code> is a two character string per ISO 639, or, if not available
for a given language, a three character string per ISO 639-3.
<code>"TERRITORY"</code> is a country code per ISO 3166.  For <code>"charset"</code> and
<code>"modifier"</code> see below.

   <p>Additionally to the POSIX specifier, the following extension is supported
for backward compatibility with older implementations using newlib:
<code>"C-charset"</code>.
Instead of <code>"C-"</code>, you can also specify <code>"C."</code>.  Both variations allow
to specify language neutral locales while using other charsets than ASCII,
for instance <code>"C.UTF-8"</code>, which keeps all settings as in the C locale,
but uses the UTF-8 charset.

   <p>The following charsets are recognized:
<code>"UTF-8"</code>, <code>"JIS"</code>, <code>"EUCJP"</code>, <code>"SJIS"</code>, <code>"KOI8-R"</code>, <code>"KOI8-U"</code>,
<code>"GEORGIAN-PS"</code>, <code>"PT154"</code>, <code>"TIS-620"</code>, <code>"ISO-8859-x"</code> with
1 &lt;= x &lt;= 16, or <code>"CPxxx"</code> with xxx in [437, 720, 737, 775, 850, 852, 855,
857, 858, 862, 866, 874, 932, 1125, 1250, 1251, 1252, 1253, 1254, 1255, 1256,
1257, 1258].

   <p>Charsets are case insensitive.  For instance, <code>"EUCJP"</code> and <code>"eucJP"</code>
are equivalent.  Charset names with dashes can also be written without
dashes, as in <code>"UTF8"</code>, <code>"iso88591"</code> or <code>"koi8r"</code>.  <code>"EUCJP"</code> and
<code>"EUCKR"</code> are also recognized with dash, <code>"EUC-JP"</code> and <code>"EUC-KR"</code>.

   <p>Full support for all of the above charsets requires that newlib has been
build with multibyte support and support for all ISO and Windows Codepage.
Otherwise all singlebyte charsets are simply mapped to ASCII.  Right now,
only newlib for Cygwin is built with full charset support by default.
Under Cygwin, this implementation additionally supports the charsets
<code>"GBK"</code>, <code>"GB2312"</code>, <code>"eucCN"</code>, <code>"eucKR"</code>, and <code>"Big5"</code>.  Cygwin
does not support <code>"JIS"</code>.

   <p>Cygwin additionally supports locales from the file
/usr/share/locale/locale.alias.

   <p>(<code>""</code> is also accepted; if given, the settings are read from the
corresponding LC_* environment variables and $LANG according to POSIX rules.

   <p>This implementation also supports the modifier <code>"cjknarrow"</code>, which
affects how the functions <code>wcwidth</code> and <code>wcswidth</code> handle characters
from the "CJK Ambiguous Width" category of characters described at
http://www.unicode.org/reports/tr11/#Ambiguous. These characters have a width
of 1 for singlebyte charsets and a width of 2 for multibyte charsets
other than UTF-8. For UTF-8, their width depends on the language specifier:
it is 2 for <code>"zh"</code> (Chinese), <code>"ja"</code> (Japanese), and <code>"ko"</code> (Korean),
and 1 for everything else. Specifying <code>"cjknarrow"</code> forces a width of 1,
independent of charset and language.

   <p>If you use <code>NULL</code> as the <var>locale</var> argument, <code>setlocale</code> returns a
pointer to the string representing the current locale.  The acceptable
values for <var>category</var> are defined in `<code>locale.h</code>' as macros
beginning with <code>"LC_"</code>.

   <p><code>localeconv</code> returns a pointer to a structure (also defined in
`<code>locale.h</code>') describing the locale-specific conventions currently
in effect.

   <p><code>_localeconv_r</code> and <code>_setlocale_r</code> are reentrant versions of
<code>localeconv</code> and <code>setlocale</code> respectively.  The extra argument
<var>reent</var> is a pointer to a reentrancy structure.

   <p><br>
<strong>Returns</strong><br>
A successful call to <code>setlocale</code> returns a pointer to a string
associated with the specified category for the new locale.  The string
returned by <code>setlocale</code> is such that a subsequent call using that
string will restore that category (or all categories in case of LC_ALL),
to that state.  The application shall not modify the string returned
which may be overwritten by a subsequent call to <code>setlocale</code>.
On error, <code>setlocale</code> returns <code>NULL</code>.

   <p><code>localeconv</code> returns a pointer to a structure of type <code>lconv</code>,
which describes the formatting and collating conventions in effect (in
this implementation, always those of the C locale).

   <p><br>
<strong>Portability</strong><br>
ANSI C requires <code>setlocale</code>, but the only locale required across all
implementations is the C locale.

   <p><br>
<div class="node">
<a name="Reentrancy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Misc">Misc</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Locale">Locale</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">11 Reentrancy</h2>

<p><a name="index-reentrancy-461"></a>Reentrancy is a characteristic of library functions which allows multiple
processes to use the same address space with assurance that the values stored
in those spaces will remain constant between calls. The Red Hat
newlib implementation of the library functions ensures that
whenever possible, these library functions are reentrant.  However,
there are some functions that can not be trivially made reentrant.
Hooks have been provided to allow you to use these functions in a fully
reentrant fashion.

   <p><a name="index-g_t_005freent-462"></a><a name="index-reent_002eh-463"></a><a name="index-reentrancy-structure-464"></a>These hooks use the structure <code>_reent</code> defined in <samp><span class="file">reent.h</span></samp>.
A variable defined as &lsquo;<samp><span class="samp">struct _reent</span></samp>&rsquo; is called a <dfn>reentrancy
structure</dfn>.  All functions which must manipulate global information are
available in two versions.  The first version has the usual name, and
uses a single global instance of the reentrancy structure.  The second
has a different name, normally formed by prepending &lsquo;<samp><span class="samp">_</span></samp>&rsquo; and
appending &lsquo;<samp><span class="samp">_r</span></samp>&rsquo;, and takes a pointer to the particular reentrancy
structure to use.

   <p>For example, the function <code>fopen</code> takes two arguments, <var>file</var>
and <var>mode</var>, and uses the global reentrancy structure.  The function
<code>_fopen_r</code> takes the arguments, <var>struct_reent</var>, which is a
pointer to an instance of the reentrancy structure, <var>file</var>
and <var>mode</var>.

   <p>There are two versions of &lsquo;<samp><span class="samp">struct _reent</span></samp>&rsquo;, a normal one and one
for small memory systems, controlled by the <code>_REENT_SMALL</code>
definition from the (automatically included) <samp><span class="file">&lt;sys/config.h&gt;</span></samp>.

   <p><a name="index-global-reentrancy-structure-465"></a><a name="index-g_t_005fimpure_005fptr-466"></a>Each function which uses the global reentrancy structure uses the global
variable <code>_impure_ptr</code>, which points to a reentrancy structure.

   <p>This means that you have two ways to achieve reentrancy.  Both require
that each thread of execution control initialize a unique global
variable of type &lsquo;<samp><span class="samp">struct _reent</span></samp>&rsquo;:

     <ol type=1 start=1>
<li><a name="index-extra-argument_002c-reentrant-fns-467"></a>Use the reentrant versions of the library functions, after initializing
a global reentrancy structure for each process.  Use the pointer to this
structure as the extra argument for all library functions.

     <li>Ensure that each thread of execution control has a pointer to its own
unique reentrancy structure in the global variable <code>_impure_ptr</code>,
and call the standard library subroutines.
        </ol>

   <p><a name="index-list-of-reentrant-functions-468"></a><a name="index-reentrant-function-list-469"></a>The following functions are provided in both reentrant
and non-reentrant versions.

<pre class="example"><br><em>Equivalent for errno variable:</em><br>
     _errno_r

<br><em>Locale functions:</em><br>
     _localeconv_r  _setlocale_r

<br><em>Equivalents for stdio variables:</em><br>
     _stdin_r        _stdout_r       _stderr_r


<br><em>Stdio functions:</em><br>
     _fdopen_r       _perror_r       _tempnam_r
     _fopen_r        _putchar_r      _tmpnam_r
     _getchar_r      _puts_r         _tmpfile_r
     _gets_r         _remove_r       _vfprintf_r
     _iprintf_r      _rename_r       _vsnprintf_r
     _mkstemp_r      _snprintf_r     _vsprintf_r
     _mktemp_t       _sprintf_r

<br><em>Signal functions:</em><br>
     _init_signal_r  _signal_r
     _kill_r         __sigtramp_r
     _raise_r

<br><em>Stdlib functions:</em><br>
     _calloc_r       _mblen_r        _setenv_r
     _dtoa_r         _mbstowcs_r     _srand_r
     _free_r         _mbtowc_r       _strtod_r
     _getenv_r       _memalign_r     _strtol_r
     _mallinfo_r     _mstats_r       _strtoul_r
     _malloc_r       _putenv_r       _system_r
     _malloc_r       _rand_r         _wcstombs_r
     _malloc_stats_r _realloc_r      _wctomb_r

<br><em>String functions:</em><br>
     _strdup_r       _strtok_r

<br><em>System functions:</em><br>
     _close_r        _link_r         _unlink_r
     _execve_r       _lseek_r        _wait_r
     _fcntl_r        _open_r         _write_r
     _fork_r         _read_r
     _fstat_r        _sbrk_r
     _gettimeofday_r _stat_r
     _getpid_r       _times_r

<br><em>Additional 64-bit I/O System functions:</em><br>
     _fstat64_r	_lseek64_r	_open64_r

<br><em>Time function:</em><br>
     _asctime_r
</pre>
   <div class="node">
<a name="Misc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Posix">Posix</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reentrancy">Reentrancy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">12 Miscellaneous Macros and Functions</h2>

<p>This chapter describes miscellaneous routines not covered elsewhere.

<ul class="menu">
<li><a accesskey="1" href="#ffs">ffs</a>:       Return first bit set in a word
<li><a accesskey="2" href="#unctrl">unctrl</a>:    Return printable representation of a character
</ul>

<div class="node">
<a name="ffs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#unctrl">unctrl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Misc">Misc</a>

</div>

<h3 class="section">12.1 <code>ffs</code>&mdash;find first bit set in a word</h3>

<p><a name="index-ffs-470"></a><strong>Synopsis</strong>
<pre class="example">     int ffs(int <var>word</var>);

</pre>
   <p><strong>Description</strong><br>

   <p><code>ffs</code> returns the first bit set in a word.

   <p><br>
<strong>Returns</strong><br>
<code>ffs</code> returns 0 if <var>c</var> is 0, 1 if <var>c</var> is odd, 2 if <var>c</var> is a multiple of
2, etc.

   <p><br>
<strong>Portability</strong><br>
<code>ffs</code> is not ANSI C.

   <p>No supporting OS subroutines are required.
<br>

<div class="node">
<a name="unctrl"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#ffs">ffs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Misc">Misc</a>

</div>

<h3 class="section">12.2 <code>unctrl</code>&mdash;get printable representation of a character</h3>

<p><a name="index-unctrl-471"></a><a name="index-unctrllen-472"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;unctrl.h&gt;
     char *unctrl(int <var>c</var>);
     int unctrllen(int <var>c</var>);

</pre>
   <p><strong>Description</strong><br>
<code>unctrl</code> is a macro which returns the printable representation of <var>c</var>
as a string.
<code>unctrllen</code> is a macro which returns the length of the printable
representation of <var>c</var>.

   <p><br>
<strong>Returns</strong><br>
<code>unctrl</code> returns a string of the printable representation of <var>c</var>.

   <p><code>unctrllen</code> returns the length of the string which is the printable
representation of <var>c</var>.

   <p><br>
<strong>Portability</strong><br>
<code>unctrl</code> and <code>unctrllen</code> are not ANSI C.

   <p>No supporting OS subroutines are required.

   <p><br>
<div class="node">
<a name="Posix"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Syscalls">Syscalls</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Misc">Misc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">13 Posix Functions</h2>

<p>This chapter groups several utility functions specified by POSIX, but
not by C.  Each function documents which header to use.

<ul class="menu">
<li><a accesskey="1" href="#popen">popen</a>:        Create a stream tied to a child process
</ul>

<div class="node">
<a name="popen"></a>
<p><hr>
Up:&nbsp;<a rel="up" accesskey="u" href="#Posix">Posix</a>

</div>

<h3 class="section">13.1 <code>popen</code>, <code>pclose</code>&mdash;tie a stream to a command string</h3>

<p><a name="index-popen-473"></a><a name="index-pclose-474"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdio.h&gt;
     FILE *popen(const char *<var>s</var>, const char *<var>mode</var>);

     int pclose(FILE *<var>f</var>);

</pre>
   <p><strong>Description</strong><br>
Use <code>popen</code> to create a stream to a child process executing a
command string <code>*</code><var>s</var> as processed by <code>/bin/sh</code> on your system.
The argument <var>mode</var> must start with either `<code>r</code>', where the stream
reads from the child's <code>stdout</code>, or `<code>w</code>', where the stream writes
to the child's <code>stdin</code>.  As an extension, <var>mode</var> may also contain
`<code>e</code>' to set the close-on-exec bit of the parent's file descriptor.
The stream created by <code>popen</code> must be closed by <code>pclose</code> to avoid
resource leaks.

   <p>Streams created by prior calls to <code>popen</code> are not visible in
subsequent <code>popen</code> children, regardless of the close-on-exec bit.

   <p>Use &ldquo;<code>system(NULL)</code>&rdquo; to test whether your system has <code>/bin/sh</code>
available.

   <p><br>
<strong>Returns</strong><br>
<code>popen</code> returns a file stream opened with the specified <var>mode</var>,
or <code>NULL</code> if a child process could not be created.  <code>pclose</code>
returns -1 if the stream was not created by <code>popen</code> or if the
application used <code>wait</code> or similar to steal the status; otherwise
it returns the exit status of the child which can be interpreted
in the same manner as a status obtained by <code>waitpid</code>.

   <p><br>
<strong>Portability</strong><br>
POSIX.2 requires <code>popen</code> and <code>pclose</code>, but only specifies a mode
of just <code>r</code> or <code>w</code>.  Where <code>sh</code> is found is left unspecified.

   <p>Supporting OS subroutines required: <code>_exit</code>, <code>_execve</code>, <code>_fork_r</code>,
<code>_wait_r</code>, <code>pipe</code>, <code>fcntl</code>, <code>sbrk</code>.

   <p><br>

<!-- *- Texinfo -*- -->
<div class="node">
<a name="Syscalls"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Arglists">Arglists</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Posix">Posix</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">14 System Calls</h2>

<p><a name="index-linking-the-C-library-475"></a>The C subroutine library depends on a handful of subroutine calls for
operating system services.  If you use the C library on a system that
complies with the POSIX.1 standard (also known as IEEE 1003.1), most of
these subroutines are supplied with your operating system.

   <p>If some of these subroutines are not provided with your system&mdash;in
the extreme case, if you are developing software for a &ldquo;bare board&rdquo;
system, without an OS&mdash;you will at least need to provide do-nothing
stubs (or subroutines with minimal functionality) to allow your
programs to link with the subroutines in <code>libc.a</code>.

<ul class="menu">
<li><a accesskey="1" href="#Stubs">Stubs</a>: 		Definitions for OS interface
<li><a accesskey="2" href="#Reentrant-Syscalls">Reentrant Syscalls</a>: 	Reentrant covers for OS subroutines
</ul>

<div class="node">
<a name="Stubs"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reentrant-Syscalls">Reentrant Syscalls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syscalls">Syscalls</a>

</div>

<h3 class="section">14.1 Definitions for OS interface</h3>

<p><a name="index-stubs-476"></a>
<a name="index-subroutines-for-OS-interface-477"></a><a name="index-OS-interface-subroutines-478"></a>This is the complete set of system definitions (primarily subroutines)
required; the examples shown implement the minimal functionality
required to allow <code>libc</code> to link, and fail gracefully where OS
services are not available.

   <p>Graceful failure is permitted by returning an error code.  A minor
complication arises here: the C library must be compatible with
development environments that supply fully functional versions of these
subroutines.  Such environments usually return error codes in a global
<code>errno</code>.  However, the Red Hat newlib C library provides a <em>macro</em>
definition for <code>errno</code> in the header file <samp><span class="file">errno.h</span></samp>, as part
of its support for reentrant routines (see <a href="#Reentrancy">Reentrancy</a>).

   <p><a name="index-g_t_0040code_007berrno_007d-global-vs-macro-479"></a>The bridge between these two interpretations of <code>errno</code> is
straightforward: the C library routines with OS interface calls
capture the <code>errno</code> values returned globally, and record them in
the appropriate field of the reentrancy structure (so that you can query
them using the <code>errno</code> macro from <samp><span class="file">errno.h</span></samp>).

   <p>This mechanism becomes visible when you write stub routines for OS
interfaces.   You must include <samp><span class="file">errno.h</span></samp>, then disable the macro,
like this:

<pre class="example">     #include &lt;errno.h&gt;
     #undef errno
     extern int errno;
</pre>
   <p class="noindent">The examples in this chapter include this treatment of <code>errno</code>.

     <dl>
<dt><code>_exit</code><a name="index-g_t_005fexit-480"></a><dd>Exit a program without cleaning up files.  If your system doesn't
provide this, it is best to avoid linking with subroutines that require
it (<code>exit</code>, <code>system</code>).

     <br><dt><code>close</code><a name="index-close-481"></a><dd>Close a file.  Minimal implementation:

     <pre class="example">          int close(int file) {
            return -1;
          }
</pre>
     <br><dt><code>environ</code><a name="index-environ-482"></a><dd>A pointer to a list of environment variables and their values.  For a
minimal environment, this empty list is adequate:

     <pre class="example">          char *__env[1] = { 0 };
          char **environ = __env;
</pre>
     <br><dt><code>execve</code><a name="index-execve-483"></a><dd>Transfer control to a new process.  Minimal implementation (for a system
without processes):

     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int execve(char *name, char **argv, char **env) {
            errno = ENOMEM;
            return -1;
          }
</pre>
     <br><dt><code>fork</code><a name="index-fork-484"></a><dd>Create a new process.  Minimal implementation (for a system without processes):

     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int fork(void) {
            errno = EAGAIN;
            return -1;
          }
</pre>
     <br><dt><code>fstat</code><a name="index-fstat-485"></a><dd>Status of an open file.  For consistency with other minimal
implementations in these examples, all files are regarded as character
special devices.  The <samp><span class="file">sys/stat.h</span></samp> header file required is
distributed in the <samp><span class="file">include</span></samp> subdirectory for this C library.

     <pre class="example">          #include &lt;sys/stat.h&gt;
          int fstat(int file, struct stat *st) {
            st-&gt;st_mode = S_IFCHR;
            return 0;
          }
</pre>
     <br><dt><code>getpid</code><a name="index-getpid-486"></a><dd>Process-ID; this is sometimes used to generate strings unlikely to
conflict with other processes.  Minimal implementation, for a system
without processes:

     <pre class="example">          int getpid(void) {
            return 1;
          }
</pre>
     <br><dt><code>isatty</code><a name="index-isatty-487"></a><dd>Query whether output stream is a terminal.   For consistency with the
other minimal implementations, which only support output to
<code>stdout</code>, this minimal implementation is suggested:

     <pre class="example">          int isatty(int file) {
            return 1;
          }
</pre>
     <br><dt><code>kill</code><a name="index-kill-488"></a><dd>Send a signal.  Minimal implementation:

     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int kill(int pid, int sig) {
            errno = EINVAL;
            return -1;
          }
</pre>
     <br><dt><code>link</code><a name="index-link-489"></a><dd>Establish a new name for an existing file.  Minimal implementation:

     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int link(char *old, char *new) {
            errno = EMLINK;
            return -1;
          }
</pre>
     <br><dt><code>lseek</code><a name="index-lseek-490"></a><dd>Set position in a file.  Minimal implementation:

     <pre class="example">          int lseek(int file, int ptr, int dir) {
            return 0;
          }
</pre>
     <br><dt><code>open</code><a name="index-open-491"></a><dd>Open a file.  Minimal implementation:

     <pre class="example">          int open(const char *name, int flags, int mode) {
            return -1;
          }
</pre>
     <br><dt><code>read</code><a name="index-read-492"></a><dd>Read from a file.  Minimal implementation:

     <pre class="example">          int read(int file, char *ptr, int len) {
            return 0;
          }
</pre>
     <br><dt><code>sbrk</code><a name="index-sbrk-493"></a><dd>Increase program data space.  As <code>malloc</code> and related functions
depend on this, it is useful to have a working implementation.  The
following suffices for a standalone system; it exploits the symbol
<code>_end</code> automatically defined by the GNU linker.

     <pre class="example">          caddr_t sbrk(int incr) {
            extern char _end;		/* <span class="roman">Defined by the linker</span> */
            static char *heap_end;
            char *prev_heap_end;

            if (heap_end == 0) {
              heap_end = &amp;_end;
            }
            prev_heap_end = heap_end;
            if (heap_end + incr &gt; stack_ptr) {
              write (1, "Heap and stack collision\n", 25);
              abort ();
            }

            heap_end += incr;
            return (caddr_t) prev_heap_end;
          }
</pre>
     <br><dt><code>stat</code><a name="index-stat-494"></a><dd>Status of a file (by name).  Minimal implementation:

     <pre class="example">          int stat(char *file, struct stat *st) {
            st-&gt;st_mode = S_IFCHR;
            return 0;
          }
</pre>
     <br><dt><code>times</code><a name="index-times-495"></a><dd>Timing information for current process.  Minimal implementation:

     <pre class="example">          int times(struct tms *buf) {
            return -1;
          }
</pre>
     <br><dt><code>unlink</code><a name="index-unlink-496"></a><dd>Remove a file's directory entry.  Minimal implementation:

     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int unlink(char *name) {
            errno = ENOENT;
            return -1;
          }
</pre>
     <br><dt><code>wait</code><a name="index-wait-497"></a><dd>Wait for a child process.  Minimal implementation:
     <pre class="example">          #include &lt;errno.h&gt;
          #undef errno
          extern int errno;
          int wait(int *status) {
            errno = ECHILD;
            return -1;
          }
</pre>
     <br><dt><code>write</code><a name="index-write-498"></a><dd>Write to a file.  <samp><span class="file">libc</span></samp> subroutines will use this
system routine for output to all files, <em>including</em>
<code>stdout</code>&mdash;so if you need to generate any output, for example to a
serial port for debugging, you should make your minimal <code>write</code>
capable of doing this.  The following minimal implementation is an
incomplete example; it relies on a <code>outbyte</code> subroutine (not
shown; typically, you must write this in assembler from examples
provided by your hardware manufacturer) to actually perform the output.

     <pre class="example">          int write(int file, char *ptr, int len) {
            int todo;

            for (todo = 0; todo &lt; len; todo++) {
              outbyte (*ptr++);
            }
            return len;
          }
</pre>
     </dl>

<div class="node">
<a name="Reentrant-Syscalls"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stubs">Stubs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Syscalls">Syscalls</a>

</div>

<h3 class="section">14.2 Reentrant covers for OS subroutines</h3>

<p>Since the system subroutines are used by other library routines that
require reentrancy, <samp><span class="file">libc.a</span></samp> provides cover routines (for example,
the reentrant version of <code>fork</code> is <code>_fork_r</code>).  These cover
routines are consistent with the other reentrant subroutines in this
library, and achieve reentrancy by using a reserved global data block
(see <a href="#Reentrancy">Reentrancy</a>).

<!-- FIXME!!! The following ignored text specifies how this section ought -->
<!-- to work;  however, both standalone info and Emacs info mode fail when -->
<!-- confronted with nodes beginning `_' as of 24may93.  Restore when Info -->
<!-- readers fixed! -->
     <dl>
<dt><code>_open_r</code><a name="index-g_t_005fopen_005fr-499"></a><dd>A reentrant version of <code>open</code>.  It takes a pointer
to the global data block, which holds <code>errno</code>.

     <pre class="example">          int _open_r(void *<var>reent</var>,
              const char *<var>file</var>, int <var>flags</var>, int <var>mode</var>);
</pre>
     <br><dt><code>_open64_r</code><dd>A reentrant version of <code>open64</code>.  It takes a pointer
to the global data block, which holds <code>errno</code>.

     <pre class="example">          int _open64_r(void *<var>reent</var>,
              const char *<var>file</var>, int <var>flags</var>, int <var>mode</var>);
</pre>
     <br><dt><code>_close_r</code><a name="index-g_t_005fclose_005fr-500"></a><dd>A reentrant version of <code>close</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _close_r(void *<var>reent</var>, int <var>fd</var>);
</pre>
     <br><dt><code>_lseek_r</code><a name="index-g_t_005flseek_005fr-501"></a><dd>A reentrant version of <code>lseek</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          off_t _lseek_r(void *<var>reent</var>,
              int <var>fd</var>, off_t <var>pos</var>, int <var>whence</var>);
</pre>
     <br><dt><code>_lseek64_r</code><dd>A reentrant version of <code>lseek64</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          off_t _lseek64_r(void *<var>reent</var>,
              int <var>fd</var>, off_t <var>pos</var>, int <var>whence</var>);
</pre>
     <br><dt><code>_read_r</code><a name="index-g_t_005fread_005fr-502"></a><dd>A reentrant version of <code>read</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          long _read_r(void *<var>reent</var>,
              int <var>fd</var>, void *<var>buf</var>, size_t <var>cnt</var>);
</pre>
     <br><dt><code>_write_r</code><a name="index-g_t_005fwrite_005fr-503"></a><dd>A reentrant version of <code>write</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          long _write_r(void *<var>reent</var>,
              int <var>fd</var>, const void *<var>buf</var>, size_t <var>cnt</var>);
</pre>
     <br><dt><code>_fork_r</code><a name="index-g_t_005ffork_005fr-504"></a><dd>A reentrant version of <code>fork</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _fork_r(void *<var>reent</var>);
</pre>
     <br><dt><code>_wait_r</code><a name="index-g_t_005fwait_005fr-505"></a><dd>A reentrant version of <code>wait</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _wait_r(void *<var>reent</var>, int *<var>status</var>);
</pre>
     <br><dt><code>_stat_r</code><a name="index-g_t_005fstat_005fr-506"></a><dd>A reentrant version of <code>stat</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _stat_r(void *<var>reent</var>,
              const char *<var>file</var>, struct stat *<var>pstat</var>);
</pre>
     <br><dt><code>_fstat_r</code><a name="index-g_t_005ffstat_005fr-507"></a><dd>A reentrant version of <code>fstat</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _fstat_r(void *<var>reent</var>,
              int <var>fd</var>, struct stat *<var>pstat</var>);
</pre>
     <br><dt><code>_fstat64_r</code><dd>A reentrant version of <code>fstat64</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _fstat64_r(void *<var>reent</var>,
              int <var>fd</var>, struct stat *<var>pstat</var>);
</pre>
     <br><dt><code>_link_r</code><a name="index-g_t_005flink_005fr-508"></a><dd>A reentrant version of <code>link</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _link_r(void *<var>reent</var>,
              const char *<var>old</var>, const char *<var>new</var>);
</pre>
     <br><dt><code>_unlink_r</code><a name="index-g_t_005funlink_005fr-509"></a><dd>A reentrant version of <code>unlink</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          int _unlink_r(void *<var>reent</var>, const char *<var>file</var>);
</pre>
     <br><dt><code>_sbrk_r</code><a name="index-g_t_005fsbrk_005fr-510"></a><dd>A reentrant version of <code>sbrk</code>.  It takes a pointer to the global
data block, which holds <code>errno</code>.

     <pre class="example">          char *_sbrk_r(void *<var>reent</var>, size_t <var>incr</var>);
</pre>
     </dl>

<div class="node">
<a name="Arglists"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Library-Index">Library Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Syscalls">Syscalls</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">15 Variable Argument Lists</h2>

<p>The <code>printf</code> family of functions is defined to accept a variable
number of arguments, rather than a fixed argument list.  You can define
your own functions with a variable argument list, by using macro
definitions from either <samp><span class="file">stdarg.h</span></samp> (for compatibility with ANSI C)
or from <samp><span class="file">varargs.h</span></samp> (for compatibility with a popular convention
prior to ANSI C).

<ul class="menu">
<li><a accesskey="1" href="#Stdarg">Stdarg</a>
<li><a accesskey="2" href="#Varargs">Varargs</a>
</ul>

<div class="node">
<a name="Stdarg"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Varargs">Varargs</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Arglists">Arglists</a>

</div>

<h3 class="section">15.1 ANSI-standard macros, <samp><span class="file">stdarg.h</span></samp></h3>

<p>In ANSI C, a function has a variable number of arguments when its
parameter list ends in an ellipsis (<code>...</code>).  The parameter list
must also include at least one explicitly named argument; that argument
is used to initialize the variable list data structure.

   <p>ANSI C defines three macros (<code>va_start</code>, <code>va_arg</code>, and
<code>va_end</code>) to operate on variable argument lists.  <samp><span class="file">stdarg.h</span></samp>
also defines a special type to represent variable argument lists: this
type is called <code>va_list</code>.

<ul class="menu">
<li><a accesskey="1" href="#va_005fstart">va_start</a>
<li><a accesskey="2" href="#va_005farg">va_arg</a>
<li><a accesskey="3" href="#va_005fend">va_end</a>
</ul>

<div class="node">
<a name="va_start"></a>
<a name="va_005fstart"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#va_005farg">va_arg</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdarg">Stdarg</a>

</div>

<h4 class="subsection">15.1.1 Initialize variable argument list</h4>

<p><a name="index-va_005fstart-511"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdarg.h&gt;
     void va_start(va_list <var>ap</var>, <var>rightmost</var>);
</pre>
   <p><strong>Description</strong><br>
Use <code>va_start</code> to initialize the variable argument list <var>ap</var>,
so that <code>va_arg</code> can extract values from it.  <var>rightmost</var> is
the name of the last explicit argument in the parameter list (the
argument immediately preceding the ellipsis &lsquo;<samp><span class="samp">...</span></samp>&rsquo; that flags
variable arguments in an ANSI C function header).  You can only use
<code>va_start</code> in a function declared using this ellipsis notation
(not, for example, in one of its subfunctions).

   <p><strong>Returns</strong><br>
<code>va_start</code> does not return a result.

   <p><strong>Portability</strong><br>
ANSI C requires <code>va_start</code>.

<div class="node">
<a name="va_arg"></a>
<a name="va_005farg"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#va_005fend">va_end</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#va_005fstart">va_start</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdarg">Stdarg</a>

</div>

<h4 class="subsection">15.1.2 Extract a value from argument list</h4>

<p><a name="index-va_005farg-512"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdarg.h&gt;
     <var>type</var> va_arg(va_list <var>ap</var>, <var>type</var>);
</pre>
   <p><strong>Description</strong><br>
<code>va_arg</code> returns the next unprocessed value from a variable
argument list <var>ap</var> (which you must previously create with
<var>va_start</var>).  Specify the type for the value as the second parameter
to the macro, <var>type</var>.

   <p>You may pass a <code>va_list</code> object <var>ap</var> to a subfunction, and use
<code>va_arg</code> from the subfunction rather than from the function
actually declared with an ellipsis in the header; however, in that case
you may <em>only</em> use <code>va_arg</code> from the subfunction.  ANSI C does
not permit extracting successive values from a single variable-argument
list from different levels of the calling stack.

   <p>There is no mechanism for testing whether there is actually a next
argument available; you might instead pass an argument count (or some
other data that implies an argument count) as one of the fixed arguments
in your function call.

   <p><strong>Returns</strong><br>
<code>va_arg</code> returns the next argument, an object of type <var>type</var>.

   <p><strong>Portability</strong><br>
ANSI C requires <code>va_arg</code>.

<div class="node">
<a name="va_end"></a>
<a name="va_005fend"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#va_005farg">va_arg</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Stdarg">Stdarg</a>

</div>

<h4 class="subsection">15.1.3 Abandon a variable argument list</h4>

<p><a name="index-va_005fend-513"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;stdarg.h&gt;
     void va_end(va_list <var>ap</var>);
</pre>
   <p><strong>Description</strong><br>
Use <code>va_end</code> to declare that your program will not use the variable
argument list <var>ap</var> any further.

   <p><strong>Returns</strong><br>
<code>va_end</code> does not return a result.

   <p><strong>Portability</strong><br>
ANSI C requires <code>va_end</code>.

<div class="node">
<a name="Varargs"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Stdarg">Stdarg</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Arglists">Arglists</a>

</div>

<h3 class="section">15.2 Traditional macros, <samp><span class="file">varargs.h</span></samp></h3>

<p>If your C compiler predates ANSI C, you may still be able to use
variable argument lists using the macros from the <samp><span class="file">varargs.h</span></samp>
header file.  These macros resemble their ANSI counterparts, but have
important differences in usage.   In particular, since traditional C has
no declaration mechanism for variable argument lists, two additional
macros are provided simply for the purpose of defining functions with
variable argument lists.

   <p>As with <samp><span class="file">stdarg.h</span></samp>, the type <code>va_list</code> is used to hold a data
structure representing a variable argument list.

<ul class="menu">
<li><a accesskey="1" href="#va_005falist">va_alist</a>
<li><a accesskey="2" href="#va_005fstart_002dtrad">va_start-trad</a>
<li><a accesskey="3" href="#va_005farg_002dtrad">va_arg-trad</a>
<li><a accesskey="4" href="#va_005fend_002dtrad">va_end-trad</a>
</ul>

<div class="node">
<a name="va_alist"></a>
<a name="va_005falist"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#va_005fstart_002dtrad">va_start-trad</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Varargs">Varargs</a>

</div>

<h4 class="subsection">15.2.1 Declare variable arguments</h4>

<p><a name="index-va_005falist-514"></a><a name="index-va_005fdcl-515"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;varargs.h&gt;
     <var>function</var>(va_alist)
     va_dcl
</pre>
   <p><strong>Description</strong><br>
To use the <samp><span class="file">varargs.h</span></samp> version of variable argument lists, you must
declare your function with a call to the macro <code>va_alist</code> as its
argument list, and use <code>va_dcl</code> as the declaration.  <em>Do not
use a semicolon after </em><code>va_dcl</code><em>.</em>

   <p><strong>Returns</strong><br>
These macros cannot be used in a context where a return is syntactically
possible.

   <p><strong>Portability</strong><br>
<var>va_alist</var> and <var>va_dcl</var> were the most widespread method of
declaring variable argument lists prior to ANSI C.

<div class="node">
<a name="va_start-trad"></a>
<a name="va_005fstart_002dtrad"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#va_005farg_002dtrad">va_arg-trad</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#va_005falist">va_alist</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Varargs">Varargs</a>

</div>

<h4 class="subsection">15.2.2 Initialize variable argument list</h4>

<p><a name="index-va_005fstart-516"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;varargs.h&gt;
     va_list <var>ap</var>;
     va_start(<var>ap</var>);
</pre>
   <p><strong>Description</strong><br>
With the <samp><span class="file">varargs.h</span></samp> macros, use <code>va_start</code> to initialize a
data structure <var>ap</var> to permit manipulating a variable argument list.
<var>ap</var> must have the type <var>va_alist</var>.

   <p><strong>Returns</strong><br>
<code>va_start</code> does not return a result.

   <p><strong>Portability</strong><br>
<code>va_start</code> is also defined as a macro in ANSI C, but the
definitions are incompatible; the ANSI version has another parameter
besides <var>ap</var>.

<div class="node">
<a name="va_arg-trad"></a>
<a name="va_005farg_002dtrad"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#va_005fend_002dtrad">va_end-trad</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#va_005fstart_002dtrad">va_start-trad</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Varargs">Varargs</a>

</div>

<h4 class="subsection">15.2.3 Extract a value from argument list</h4>

<p><a name="index-va_005farg-517"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;varargs.h&gt;
     <var>type</var> va_arg(va_list <var>ap</var>, <var>type</var>);
</pre>
   <p><strong>Description</strong><br>
<code>va_arg</code> returns the next unprocessed value from a variable
argument list <var>ap</var> (which you must previously create with
<var>va_start</var>).  Specify the type for the value as the second parameter
to the macro, <var>type</var>.

   <p><strong>Returns</strong><br>
<code>va_arg</code> returns the next argument, an object of type <var>type</var>.

   <p><strong>Portability</strong><br>
The <code>va_arg</code> defined in <samp><span class="file">varargs.h</span></samp> has the same syntax and
usage as the ANSI C version from <samp><span class="file">stdarg.h</span></samp>.

<div class="node">
<a name="va_end-trad"></a>
<a name="va_005fend_002dtrad"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#va_005farg_002dtrad">va_arg-trad</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Varargs">Varargs</a>

</div>

<h4 class="subsection">15.2.4 Abandon a variable argument list</h4>

<p><a name="index-va_005fend-518"></a><strong>Synopsis</strong>
<pre class="example">     #include &lt;varargs.h&gt;
     va_end(va_list <var>ap</var>);
</pre>
   <p><strong>Description</strong><br>
Use <code>va_end</code> to declare that your program will not use the variable
argument list <var>ap</var> any further.

   <p><strong>Returns</strong><br>
<code>va_end</code> does not return a result.

   <p><strong>Portability</strong><br>
The <code>va_end</code> defined in <samp><span class="file">varargs.h</span></samp> has the same syntax and
usage as the ANSI C version from <samp><span class="file">stdarg.h</span></samp>.

<div class="node">
<a name="Library-Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Arglists">Arglists</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="unnumbered">Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-g_t_005f_005fenv_005flock-28"><code>__env_lock</code></a>: <a href="#g_t_005f_005fenv_005flock">__env_lock</a></li>
<li><a href="#index-g_t_005f_005fenv_005funlock-29"><code>__env_unlock</code></a>: <a href="#g_t_005f_005fenv_005flock">__env_lock</a></li>
<li><a href="#index-g_t_005f_005fmalloc_005flock-55"><code>__malloc_lock</code></a>: <a href="#g_t_005f_005fmalloc_005flock">__malloc_lock</a></li>
<li><a href="#index-g_t_005f_005fmalloc_005funlock-56"><code>__malloc_unlock</code></a>: <a href="#g_t_005f_005fmalloc_005flock">__malloc_lock</a></li>
<li><a href="#index-g_t_005f_005ftz_005flock-453"><code>__tz_lock</code></a>: <a href="#g_t_005f_005ftz_005flock">__tz_lock</a></li>
<li><a href="#index-g_t_005f_005ftz_005funlock-454"><code>__tz_unlock</code></a>: <a href="#g_t_005f_005ftz_005flock">__tz_lock</a></li>
<li><a href="#index-g_t_005fasctime_005fr-441"><code>_asctime_r</code></a>: <a href="#asctime">asctime</a></li>
<li><a href="#index-g_t_005fasiprintf_005fr-275"><code>_asiprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005fasniprintf_005fr-277"><code>_asniprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005fasnprintf_005fr-295"><code>_asnprintf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005fasprintf_005fr-289"><code>_asprintf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005fatoi_005fr-12"><code>_atoi_r</code></a>: <a href="#atoi">atoi</a></li>
<li><a href="#index-g_t_005fatol_005fr-13"><code>_atol_r</code></a>: <a href="#atoi">atoi</a></li>
<li><a href="#index-g_t_005fatoll_005fr-15"><code>_atoll_r</code></a>: <a href="#atoll">atoll</a></li>
<li><a href="#index-g_t_005fcalloc_005fr-18"><code>_calloc_r</code></a>: <a href="#calloc">calloc</a></li>
<li><a href="#index-g_t_005fclose_005fr-500"><code>_close_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fdiprintf_005fr-147"><code>_diprintf_r</code></a>: <a href="#diprintf">diprintf</a></li>
<li><a href="#index-g_t_005fdprintf_005fr-151"><code>_dprintf_r</code></a>: <a href="#dprintf">dprintf</a></li>
<li><a href="#index-g_t_005fexit-480"><code>_exit</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-g_t_005fExit-1"><code>_Exit</code></a>: <a href="#g_t_005fExit">_Exit</a></li>
<li><a href="#index-g_t_005ffclose_005fr-155"><code>_fclose_r</code></a>: <a href="#fclose">fclose</a></li>
<li><a href="#index-g_t_005ffcloseall_005fr-157"><code>_fcloseall_r</code></a>: <a href="#fcloseall">fcloseall</a></li>
<li><a href="#index-g_t_005ffdopen_005fr-159"><code>_fdopen_r</code></a>: <a href="#fdopen">fdopen</a></li>
<li><a href="#index-g_t_005ffflush_005fr-163"><code>_fflush_r</code></a>: <a href="#fflush">fflush</a></li>
<li><a href="#index-g_t_005ffgetc_005fr-165"><code>_fgetc_r</code></a>: <a href="#fgetc">fgetc</a></li>
<li><a href="#index-g_t_005ffgetpos64_005fr-381"><code>_fgetpos64_r</code></a>: <a href="#fgetpos64">fgetpos64</a></li>
<li><a href="#index-g_t_005ffgetpos_005fr-167"><code>_fgetpos_r</code></a>: <a href="#fgetpos">fgetpos</a></li>
<li><a href="#index-g_t_005ffgets_005fr-169"><code>_fgets_r</code></a>: <a href="#fgets">fgets</a></li>
<li><a href="#index-g_t_005ffgetwc_005fr-171"><code>_fgetwc_r</code></a>: <a href="#fgetwc">fgetwc</a></li>
<li><a href="#index-g_t_005ffgetws_005fr-175"><code>_fgetws_r</code></a>: <a href="#fgetws">fgetws</a></li>
<li><a href="#index-g_t_005ffiprintf_005fr-267"><code>_fiprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005ffiscanf_005fr-281"><code>_fiscanf_r</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-g_t_005ffopen64_005fr-373"><code>_fopen64_r</code></a>: <a href="#fopen64">fopen64</a></li>
<li><a href="#index-g_t_005ffopen_005fr-179"><code>_fopen_r</code></a>: <a href="#fopen">fopen</a></li>
<li><a href="#index-g_t_005ffork_005fr-504"><code>_fork_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005ffprintf_005fr-285"><code>_fprintf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005ffpurge_005fr-182"><code>_fpurge_r</code></a>: <a href="#fpurge">fpurge</a></li>
<li><a href="#index-g_t_005ffputc_005fr-184"><code>_fputc_r</code></a>: <a href="#fputc">fputc</a></li>
<li><a href="#index-g_t_005ffputs_005fr-186"><code>_fputs_r</code></a>: <a href="#fputs">fputs</a></li>
<li><a href="#index-g_t_005ffputwc_005fr-188"><code>_fputwc_r</code></a>: <a href="#fputwc">fputwc</a></li>
<li><a href="#index-g_t_005ffputws_005fr-192"><code>_fputws_r</code></a>: <a href="#fputws">fputws</a></li>
<li><a href="#index-g_t_005ffread_005fr-194"><code>_fread_r</code></a>: <a href="#fread">fread</a></li>
<li><a href="#index-g_t_005ffree_005fr-46"><code>_free_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005ffreopen64_005fr-375"><code>_freopen64_r</code></a>: <a href="#freopen64">freopen64</a></li>
<li><a href="#index-g_t_005ffreopen_005fr-196"><code>_freopen_r</code></a>: <a href="#freopen">freopen</a></li>
<li><a href="#index-g_t_005ffscanf_005fr-299"><code>_fscanf_r</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-g_t_005ffseek_005fr-199"><code>_fseek_r</code></a>: <a href="#fseek">fseek</a></li>
<li><a href="#index-g_t_005ffseeko64_005fr-379"><code>_fseeko64_r</code></a>: <a href="#fseeko64">fseeko64</a></li>
<li><a href="#index-g_t_005ffseeko_005fr-200"><code>_fseeko_r</code></a>: <a href="#fseek">fseek</a></li>
<li><a href="#index-g_t_005ffsetpos64_005fr-383"><code>_fsetpos64_r</code></a>: <a href="#fsetpos64">fsetpos64</a></li>
<li><a href="#index-g_t_005ffsetpos_005fr-202"><code>_fsetpos_r</code></a>: <a href="#fsetpos">fsetpos</a></li>
<li><a href="#index-g_t_005ffstat_005fr-507"><code>_fstat_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fftell_005fr-205"><code>_ftell_r</code></a>: <a href="#ftell">ftell</a></li>
<li><a href="#index-g_t_005fftello64_005fr-377"><code>_ftello64_r</code></a>: <a href="#ftello64">ftello64</a></li>
<li><a href="#index-g_t_005fftello_005fr-206"><code>_ftello_r</code></a>: <a href="#ftell">ftell</a></li>
<li><a href="#index-g_t_005ffwide_005fr-211"><code>_fwide_r</code></a>: <a href="#fwide">fwide</a></li>
<li><a href="#index-g_t_005ffwprintf_005fr-303"><code>_fwprintf_r</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-g_t_005ffwrite_005fr-213"><code>_fwrite_r</code></a>: <a href="#fwrite">fwrite</a></li>
<li><a href="#index-g_t_005ffwscanf_005fr-311"><code>_fwscanf_r</code></a>: <a href="#swscanf">swscanf</a></li>
<li><a href="#index-g_t_005fgetc_005fr-215"><code>_getc_r</code></a>: <a href="#getc">getc</a></li>
<li><a href="#index-g_t_005fgetc_005funlocked_005fr-217"><code>_getc_unlocked_r</code></a>: <a href="#getc_005funlocked">getc_unlocked</a></li>
<li><a href="#index-g_t_005fgetchar_005fr-219"><code>_getchar_r</code></a>: <a href="#getchar">getchar</a></li>
<li><a href="#index-g_t_005fgetchar_005funlocked_005fr-221"><code>_getchar_unlocked_r</code></a>: <a href="#getchar_005funlocked">getchar_unlocked</a></li>
<li><a href="#index-g_t_005fgets_005fr-225"><code>_gets_r</code></a>: <a href="#gets">gets</a></li>
<li><a href="#index-g_t_005fgetwc_005fr-173"><code>_getwc_r</code></a>: <a href="#fgetwc">fgetwc</a></li>
<li><a href="#index-g_t_005fgetwchar_005fr-228"><code>_getwchar_r</code></a>: <a href="#getwchar">getwchar</a></li>
<li><a href="#index-g_t_005fimpure_005fptr-466"><code>_impure_ptr</code></a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-g_t_005fiprintf_005fr-269"><code>_iprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005fiscanf_005fr-279"><code>_iscanf_r</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-g_t_005flink_005fr-508"><code>_link_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005flocaleconv_005fr-460"><code>_localeconv_r</code></a>: <a href="#setlocale">setlocale</a></li>
<li><a href="#index-g_t_005flseek_005fr-501"><code>_lseek_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fmallinfo_005fr-52"><code>_mallinfo_r</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-g_t_005fmalloc_005fr-43"><code>_malloc_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005fmalloc_005fstats_005fr-53"><code>_malloc_stats_r</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-g_t_005fmalloc_005fusable_005fsize_005fr-48"><code>_malloc_usable_size_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005fmallopt_005fr-54"><code>_mallopt_r</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-g_t_005fmbsnrtowcs_005fr-61"><code>_mbsnrtowcs_r</code></a>: <a href="#mbsrtowcs">mbsrtowcs</a></li>
<li><a href="#index-g_t_005fmbsrtowcs_005fr-59"><code>_mbsrtowcs_r</code></a>: <a href="#mbsrtowcs">mbsrtowcs</a></li>
<li><a href="#index-g_t_005fmemalign_005fr-47"><code>_memalign_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005fmkdtemp_005fr-236"><code>_mkdtemp_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fmkostemp_005fr-239"><code>_mkostemp_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fmkostemps_005fr-240"><code>_mkostemps_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fmkstemp_005fr-237"><code>_mkstemp_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fmkstemps_005fr-238"><code>_mkstemps_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fmktemp_005fr-235"><code>_mktemp_r</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-g_t_005fopen_005fr-499"><code>_open_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fperror_005fr-244"><code>_perror_r</code></a>: <a href="#perror">perror</a></li>
<li><a href="#index-g_t_005fprintf_005fr-287"><code>_printf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005fputc_005fr-246"><code>_putc_r</code></a>: <a href="#putc">putc</a></li>
<li><a href="#index-g_t_005fputc_005funlocked_005fr-248"><code>_putc_unlocked_r</code></a>: <a href="#putc_005funlocked">putc_unlocked</a></li>
<li><a href="#index-g_t_005fputchar_005fr-250"><code>_putchar_r</code></a>: <a href="#putchar">putchar</a></li>
<li><a href="#index-g_t_005fputs_005fr-253"><code>_puts_r</code></a>: <a href="#puts">puts</a></li>
<li><a href="#index-g_t_005fputwc_005fr-190"><code>_putwc_r</code></a>: <a href="#fputwc">fputwc</a></li>
<li><a href="#index-g_t_005fputwchar_005fr-256"><code>_putwchar_r</code></a>: <a href="#putwchar">putwchar</a></li>
<li><a href="#index-g_t_005fraise_005fr-437"><code>_raise_r</code></a>: <a href="#raise">raise</a></li>
<li><a href="#index-g_t_005fread_005fr-502"><code>_read_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005frealloc_005fr-44"><code>_realloc_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005freallocf_005fr-45"><code>_reallocf_r</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-g_t_005freent-462"><code>_reent</code></a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-g_t_005fremove_005fr-258"><code>_remove_r</code></a>: <a href="#remove">remove</a></li>
<li><a href="#index-g_t_005frewind_005fr-261"><code>_rewind_r</code></a>: <a href="#rewind">rewind</a></li>
<li><a href="#index-g_t_005fsbrk_005fr-510"><code>_sbrk_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fscanf_005fr-297"><code>_scanf_r</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-g_t_005fsetlocale_005fr-459"><code>_setlocale_r</code></a>: <a href="#setlocale">setlocale</a></li>
<li><a href="#index-g_t_005fsignal_005fr-439"><code>_signal_r</code></a>: <a href="#signal">signal</a></li>
<li><a href="#index-g_t_005fsiprintf_005fr-271"><code>_siprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005fsiscanf_005fr-283"><code>_siscanf_r</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-g_t_005fsniprintf_005fr-273"><code>_sniprintf_r</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-g_t_005fsnprintf_005fr-293"><code>_snprintf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005fsprintf_005fr-291"><code>_sprintf_r</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-g_t_005fsscanf_005fr-301"><code>_sscanf_r</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-g_t_005fstat_005fr-506"><code>_stat_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fstrtod_005fr-80"><code>_strtod_r</code></a>: <a href="#strtod">strtod</a></li>
<li><a href="#index-g_t_005fstrtol_005fr-83"><code>_strtol_r</code></a>: <a href="#strtol">strtol</a></li>
<li><a href="#index-g_t_005fstrtoll_005fr-85"><code>_strtoll_r</code></a>: <a href="#strtoll">strtoll</a></li>
<li><a href="#index-g_t_005fstrtoul_005fr-87"><code>_strtoul_r</code></a>: <a href="#strtoul">strtoul</a></li>
<li><a href="#index-g_t_005fstrtoull_005fr-89"><code>_strtoull_r</code></a>: <a href="#strtoull">strtoull</a></li>
<li><a href="#index-g_t_005fswprintf_005fr-307"><code>_swprintf_r</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-g_t_005fswscanf_005fr-313"><code>_swscanf_r</code></a>: <a href="#swscanf">swscanf</a></li>
<li><a href="#index-g_t_005fsystem_005fr-107"><code>_system_r</code></a>: <a href="#system">system</a></li>
<li><a href="#index-g_t_005ftempnam_005fr-319"><code>_tempnam_r</code></a>: <a href="#tmpnam">tmpnam</a></li>
<li><a href="#index-g_t_005ftmpfile64_005fr-385"><code>_tmpfile64_r</code></a>: <a href="#tmpfile64">tmpfile64</a></li>
<li><a href="#index-g_t_005ftmpfile_005fr-315"><code>_tmpfile_r</code></a>: <a href="#tmpfile">tmpfile</a></li>
<li><a href="#index-g_t_005ftmpnam_005fr-318"><code>_tmpnam_r</code></a>: <a href="#tmpnam">tmpnam</a></li>
<li><a href="#index-g_t_005ftolower-124"><code>_tolower</code></a>: <a href="#tolower">tolower</a></li>
<li><a href="#index-g_t_005ftoupper-126"><code>_toupper</code></a>: <a href="#toupper">toupper</a></li>
<li><a href="#index-g_t_005ftzset_005fr-456"><code>_tzset_r</code></a>: <a href="#tzset">tzset</a></li>
<li><a href="#index-g_t_005fungetc_005fr-321"><code>_ungetc_r</code></a>: <a href="#ungetc">ungetc</a></li>
<li><a href="#index-g_t_005fungetwc_005fr-323"><code>_ungetwc_r</code></a>: <a href="#ungetwc">ungetwc</a></li>
<li><a href="#index-g_t_005funlink_005fr-509"><code>_unlink_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fvasiprintf_005fr-363"><code>_vasiprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fvasniprintf_005fr-365"><code>_vasniprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fvasnprintf_005fr-335"><code>_vasnprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvasprintf_005fr-333"><code>_vasprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvdiprintf_005fr-149"><code>_vdiprintf_r</code></a>: <a href="#diprintf">diprintf</a></li>
<li><a href="#index-g_t_005fvdprintf_005fr-153"><code>_vdprintf_r</code></a>: <a href="#dprintf">dprintf</a></li>
<li><a href="#index-g_t_005fvfiprintf_005fr-357"><code>_vfiprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fvfiscanf_005fr-369"><code>_vfiscanf_r</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-g_t_005fvfprintf_005fr-325"><code>_vfprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvfscanf_005fr-337"><code>_vfscanf_r</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-g_t_005fvfwprintf_005fr-343"><code>_vfwprintf_r</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-g_t_005fvfwscanf-349"><code>_vfwscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-g_t_005fviprintf_005fr-355"><code>_viprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fviscanf_005fr-367"><code>_viscanf_r</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-g_t_005fvprintf_005fr-327"><code>_vprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvscanf_005fr-339"><code>_vscanf_r</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-g_t_005fvsiprintf_005fr-359"><code>_vsiprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fvsiscanf_005fr-371"><code>_vsiscanf_r</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-g_t_005fvsniprintf_005fr-361"><code>_vsniprintf_r</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-g_t_005fvsnprintf_005fr-331"><code>_vsnprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvsprintf_005fr-329"><code>_vsprintf_r</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-g_t_005fvsscanf_005fr-341"><code>_vsscanf_r</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-g_t_005fvswprintf_005fr-347"><code>_vswprintf_r</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-g_t_005fvswscanf-353"><code>_vswscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-g_t_005fvwprintf_005fr-345"><code>_vwprintf_r</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-g_t_005fvwscanf-351"><code>_vwscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-g_t_005fwait_005fr-505"><code>_wait_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fwcsdup_005fr-426"><code>_wcsdup_r</code></a>: <a href="#wcsdup">wcsdup</a></li>
<li><a href="#index-g_t_005fwcsnrtombs_005fr-93"><code>_wcsnrtombs_r</code></a>: <a href="#wcsrtombs">wcsrtombs</a></li>
<li><a href="#index-g_t_005fwcsrtombs_005fr-91"><code>_wcsrtombs_r</code></a>: <a href="#wcsrtombs">wcsrtombs</a></li>
<li><a href="#index-g_t_005fwcstod_005fr-95"><code>_wcstod_r</code></a>: <a href="#wcstod">wcstod</a></li>
<li><a href="#index-g_t_005fwcstof_005fr-97"><code>_wcstof_r</code></a>: <a href="#wcstod">wcstod</a></li>
<li><a href="#index-g_t_005fwcstol_005fr-99"><code>_wcstol_r</code></a>: <a href="#wcstol">wcstol</a></li>
<li><a href="#index-g_t_005fwcstoll_005fr-101"><code>_wcstoll_r</code></a>: <a href="#wcstoll">wcstoll</a></li>
<li><a href="#index-g_t_005fwcstoul_005fr-103"><code>_wcstoul_r</code></a>: <a href="#wcstoul">wcstoul</a></li>
<li><a href="#index-g_t_005fwcstoull_005fr-105"><code>_wcstoull_r</code></a>: <a href="#wcstoull">wcstoull</a></li>
<li><a href="#index-g_t_005fwprintf_005fr-305"><code>_wprintf_r</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-g_t_005fwrite_005fr-503"><code>_write_r</code></a>: <a href="#Reentrant-Syscalls">Reentrant Syscalls</a></li>
<li><a href="#index-g_t_005fwscanf_005fr-309"><code>_wscanf_r</code></a>: <a href="#swscanf">swscanf</a></li>
<li><a href="#index-a64l-2"><code>a64l</code></a>: <a href="#a64l">a64l</a></li>
<li><a href="#index-abort-4"><code>abort</code></a>: <a href="#abort">abort</a></li>
<li><a href="#index-abs-5"><code>abs</code></a>: <a href="#abs">abs</a></li>
<li><a href="#index-asctime-440"><code>asctime</code></a>: <a href="#asctime">asctime</a></li>
<li><a href="#index-asiprintf-274"><code>asiprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-asniprintf-276"><code>asniprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-asnprintf-294"><code>asnprintf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-asprintf-288"><code>asprintf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-assert-6"><code>assert</code></a>: <a href="#assert">assert</a></li>
<li><a href="#index-atexit-7"><code>atexit</code></a>: <a href="#atexit">atexit</a></li>
<li><a href="#index-atof-8"><code>atof</code></a>: <a href="#atof">atof</a></li>
<li><a href="#index-atoff-9"><code>atoff</code></a>: <a href="#atof">atof</a></li>
<li><a href="#index-atoi-10"><code>atoi</code></a>: <a href="#atoi">atoi</a></li>
<li><a href="#index-atol-11"><code>atol</code></a>: <a href="#atoi">atoi</a></li>
<li><a href="#index-atoll-14"><code>atoll</code></a>: <a href="#atoll">atoll</a></li>
<li><a href="#index-bcmp-386"><code>bcmp</code></a>: <a href="#bcmp">bcmp</a></li>
<li><a href="#index-bsearch-16"><code>bsearch</code></a>: <a href="#bsearch">bsearch</a></li>
<li><a href="#index-bzero-387"><code>bzero</code></a>: <a href="#bzero">bzero</a></li>
<li><a href="#index-calloc-17"><code>calloc</code></a>: <a href="#calloc">calloc</a></li>
<li><a href="#index-clearerr-145"><code>clearerr</code></a>: <a href="#clearerr">clearerr</a></li>
<li><a href="#index-clock-442"><code>clock</code></a>: <a href="#clock">clock</a></li>
<li><a href="#index-close-481"><code>close</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-ctime-443"><code>ctime</code></a>: <a href="#ctime">ctime</a></li>
<li><a href="#index-ctime_005fr-444"><code>ctime_r</code></a>: <a href="#ctime">ctime</a></li>
<li><a href="#index-difftime-445"><code>difftime</code></a>: <a href="#difftime">difftime</a></li>
<li><a href="#index-diprintf-146"><code>diprintf</code></a>: <a href="#diprintf">diprintf</a></li>
<li><a href="#index-div-19"><code>div</code></a>: <a href="#div">div</a></li>
<li><a href="#index-dprintf-150"><code>dprintf</code></a>: <a href="#dprintf">dprintf</a></li>
<li><a href="#index-drand48-70"><code>drand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-ecvt-20"><code>ecvt</code></a>: <a href="#ecvt">ecvt</a></li>
<li><a href="#index-ecvtbuf-26"><code>ecvtbuf</code></a>: <a href="#ecvtbuf">ecvtbuf</a></li>
<li><a href="#index-ecvtf-21"><code>ecvtf</code></a>: <a href="#ecvt">ecvt</a></li>
<li><a href="#index-environ-482"><code>environ</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-environ-32"><code>environ</code></a>: <a href="#getenv">getenv</a></li>
<li><a href="#index-erand48-71"><code>erand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-g_t_0040code_007berrno_007d-global-vs-macro-479"><code>errno</code> global vs macro</a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-execve-483"><code>execve</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-exit-30"><code>exit</code></a>: <a href="#exit">exit</a></li>
<li><a href="#index-extra-argument_002c-reentrant-fns-467">extra argument, reentrant fns</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-fclose-154"><code>fclose</code></a>: <a href="#fclose">fclose</a></li>
<li><a href="#index-fcloseall-156"><code>fcloseall</code></a>: <a href="#fcloseall">fcloseall</a></li>
<li><a href="#index-fcvt-22"><code>fcvt</code></a>: <a href="#ecvt">ecvt</a></li>
<li><a href="#index-fcvtbuf-27"><code>fcvtbuf</code></a>: <a href="#ecvtbuf">ecvtbuf</a></li>
<li><a href="#index-fcvtf-23"><code>fcvtf</code></a>: <a href="#ecvt">ecvt</a></li>
<li><a href="#index-fdopen-158"><code>fdopen</code></a>: <a href="#fdopen">fdopen</a></li>
<li><a href="#index-feof-160"><code>feof</code></a>: <a href="#feof">feof</a></li>
<li><a href="#index-ferror-161"><code>ferror</code></a>: <a href="#ferror">ferror</a></li>
<li><a href="#index-fflush-162"><code>fflush</code></a>: <a href="#fflush">fflush</a></li>
<li><a href="#index-ffs-470"><code>ffs</code></a>: <a href="#ffs">ffs</a></li>
<li><a href="#index-fgetc-164"><code>fgetc</code></a>: <a href="#fgetc">fgetc</a></li>
<li><a href="#index-fgetpos-166"><code>fgetpos</code></a>: <a href="#fgetpos">fgetpos</a></li>
<li><a href="#index-fgetpos64-380"><code>fgetpos64</code></a>: <a href="#fgetpos64">fgetpos64</a></li>
<li><a href="#index-fgets-168"><code>fgets</code></a>: <a href="#fgets">fgets</a></li>
<li><a href="#index-fgetwc-170"><code>fgetwc</code></a>: <a href="#fgetwc">fgetwc</a></li>
<li><a href="#index-fgetws-174"><code>fgetws</code></a>: <a href="#fgetws">fgetws</a></li>
<li><a href="#index-fileno-176"><code>fileno</code></a>: <a href="#fileno">fileno</a></li>
<li><a href="#index-fiprintf-266"><code>fiprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-fiscanf-280"><code>fiscanf</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-fmemopen-177"><code>fmemopen</code></a>: <a href="#fmemopen">fmemopen</a></li>
<li><a href="#index-fopen-178"><code>fopen</code></a>: <a href="#fopen">fopen</a></li>
<li><a href="#index-fopen64-372"><code>fopen64</code></a>: <a href="#fopen64">fopen64</a></li>
<li><a href="#index-fopencookie-180"><code>fopencookie</code></a>: <a href="#fopencookie">fopencookie</a></li>
<li><a href="#index-fork-484"><code>fork</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-fprintf-284"><code>fprintf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-fpurge-181"><code>fpurge</code></a>: <a href="#fpurge">fpurge</a></li>
<li><a href="#index-fputc-183"><code>fputc</code></a>: <a href="#fputc">fputc</a></li>
<li><a href="#index-fputs-185"><code>fputs</code></a>: <a href="#fputs">fputs</a></li>
<li><a href="#index-fputwc-187"><code>fputwc</code></a>: <a href="#fputwc">fputwc</a></li>
<li><a href="#index-fputws-191"><code>fputws</code></a>: <a href="#fputws">fputws</a></li>
<li><a href="#index-fread-193"><code>fread</code></a>: <a href="#fread">fread</a></li>
<li><a href="#index-free-40"><code>free</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-freopen-195"><code>freopen</code></a>: <a href="#freopen">freopen</a></li>
<li><a href="#index-freopen64-374"><code>freopen64</code></a>: <a href="#freopen64">freopen64</a></li>
<li><a href="#index-fropen-208"><code>fropen</code></a>: <a href="#funopen">funopen</a></li>
<li><a href="#index-fscanf-298"><code>fscanf</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-fseek-197"><code>fseek</code></a>: <a href="#fseek">fseek</a></li>
<li><a href="#index-fseeko-198"><code>fseeko</code></a>: <a href="#fseek">fseek</a></li>
<li><a href="#index-fseeko64-378"><code>fseeko64</code></a>: <a href="#fseeko64">fseeko64</a></li>
<li><a href="#index-fsetpos-201"><code>fsetpos</code></a>: <a href="#fsetpos">fsetpos</a></li>
<li><a href="#index-fsetpos64-382"><code>fsetpos64</code></a>: <a href="#fsetpos64">fsetpos64</a></li>
<li><a href="#index-fstat-485"><code>fstat</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-ftell-203"><code>ftell</code></a>: <a href="#ftell">ftell</a></li>
<li><a href="#index-ftello-204"><code>ftello</code></a>: <a href="#ftell">ftell</a></li>
<li><a href="#index-ftello64-376"><code>ftello64</code></a>: <a href="#ftello64">ftello64</a></li>
<li><a href="#index-funopen-207"><code>funopen</code></a>: <a href="#funopen">funopen</a></li>
<li><a href="#index-fwide-210"><code>fwide</code></a>: <a href="#fwide">fwide</a></li>
<li><a href="#index-fwopen-209"><code>fwopen</code></a>: <a href="#funopen">funopen</a></li>
<li><a href="#index-fwprintf-302"><code>fwprintf</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-fwrite-212"><code>fwrite</code></a>: <a href="#fwrite">fwrite</a></li>
<li><a href="#index-fwscanf-310"><code>fwscanf</code></a>: <a href="#swscanf">swscanf</a></li>
<li><a href="#index-gcvt-24"><code>gcvt</code></a>: <a href="#gvcvt">gvcvt</a></li>
<li><a href="#index-gcvtf-25"><code>gcvtf</code></a>: <a href="#gvcvt">gvcvt</a></li>
<li><a href="#index-getc-214"><code>getc</code></a>: <a href="#getc">getc</a></li>
<li><a href="#index-getc_005funlocked-216"><code>getc_unlocked</code></a>: <a href="#getc_005funlocked">getc_unlocked</a></li>
<li><a href="#index-getchar-218"><code>getchar</code></a>: <a href="#getchar">getchar</a></li>
<li><a href="#index-getchar_005funlocked-220"><code>getchar_unlocked</code></a>: <a href="#getchar_005funlocked">getchar_unlocked</a></li>
<li><a href="#index-getdelim-222"><code>getdelim</code></a>: <a href="#getdelim">getdelim</a></li>
<li><a href="#index-getenv-31"><code>getenv</code></a>: <a href="#getenv">getenv</a></li>
<li><a href="#index-getline-223"><code>getline</code></a>: <a href="#getline">getline</a></li>
<li><a href="#index-getpid-486"><code>getpid</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-gets-224"><code>gets</code></a>: <a href="#gets">gets</a></li>
<li><a href="#index-getw-226"><code>getw</code></a>: <a href="#getw">getw</a></li>
<li><a href="#index-getwc-172"><code>getwc</code></a>: <a href="#fgetwc">fgetwc</a></li>
<li><a href="#index-getwchar-227"><code>getwchar</code></a>: <a href="#getwchar">getwchar</a></li>
<li><a href="#index-global-reentrancy-structure-465">global reentrancy structure</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-gmtime-446"><code>gmtime</code></a>: <a href="#gmtime">gmtime</a></li>
<li><a href="#index-gmtime_005fr-447"><code>gmtime_r</code></a>: <a href="#gmtime">gmtime</a></li>
<li><a href="#index-index-388"><code>index</code></a>: <a href="#index">index</a></li>
<li><a href="#index-iprintf-268"><code>iprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-isalnum-110"><code>isalnum</code></a>: <a href="#isalnum">isalnum</a></li>
<li><a href="#index-isalpha-111"><code>isalpha</code></a>: <a href="#isalpha">isalpha</a></li>
<li><a href="#index-isascii-112"><code>isascii</code></a>: <a href="#isascii">isascii</a></li>
<li><a href="#index-isatty-487"><code>isatty</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-iscanf-278"><code>iscanf</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-iscntrl-113"><code>iscntrl</code></a>: <a href="#iscntrl">iscntrl</a></li>
<li><a href="#index-isdigit-114"><code>isdigit</code></a>: <a href="#isdigit">isdigit</a></li>
<li><a href="#index-isgraph-117"><code>isgraph</code></a>: <a href="#isprint">isprint</a></li>
<li><a href="#index-islower-115"><code>islower</code></a>: <a href="#islower">islower</a></li>
<li><a href="#index-isprint-116"><code>isprint</code></a>: <a href="#isprint">isprint</a></li>
<li><a href="#index-ispunct-118"><code>ispunct</code></a>: <a href="#ispunct">ispunct</a></li>
<li><a href="#index-isspace-119"><code>isspace</code></a>: <a href="#isspace">isspace</a></li>
<li><a href="#index-isupper-120"><code>isupper</code></a>: <a href="#isupper">isupper</a></li>
<li><a href="#index-iswalnum-127"><code>iswalnum</code></a>: <a href="#iswalnum">iswalnum</a></li>
<li><a href="#index-iswalpha-128"><code>iswalpha</code></a>: <a href="#iswalpha">iswalpha</a></li>
<li><a href="#index-iswblank-130"><code>iswblank</code></a>: <a href="#iswblank">iswblank</a></li>
<li><a href="#index-iswcntrl-129"><code>iswcntrl</code></a>: <a href="#iswcntrl">iswcntrl</a></li>
<li><a href="#index-iswctype-139"><code>iswctype</code></a>: <a href="#iswctype">iswctype</a></li>
<li><a href="#index-iswdigit-131"><code>iswdigit</code></a>: <a href="#iswdigit">iswdigit</a></li>
<li><a href="#index-iswgraph-132"><code>iswgraph</code></a>: <a href="#iswgraph">iswgraph</a></li>
<li><a href="#index-iswlower-133"><code>iswlower</code></a>: <a href="#iswlower">iswlower</a></li>
<li><a href="#index-iswprint-134"><code>iswprint</code></a>: <a href="#iswprint">iswprint</a></li>
<li><a href="#index-iswpunct-135"><code>iswpunct</code></a>: <a href="#iswpunct">iswpunct</a></li>
<li><a href="#index-iswspace-136"><code>iswspace</code></a>: <a href="#iswspace">iswspace</a></li>
<li><a href="#index-iswupper-137"><code>iswupper</code></a>: <a href="#iswupper">iswupper</a></li>
<li><a href="#index-iswxdigit-138"><code>iswxdigit</code></a>: <a href="#iswxdigit">iswxdigit</a></li>
<li><a href="#index-isxdigit-121"><code>isxdigit</code></a>: <a href="#isxdigit">isxdigit</a></li>
<li><a href="#index-jrand48-75"><code>jrand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-kill-488"><code>kill</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-l64a-3"><code>l64a</code></a>: <a href="#a64l">a64l</a></li>
<li><a href="#index-labs-33"><code>labs</code></a>: <a href="#labs">labs</a></li>
<li><a href="#index-lcong48-78"><code>lcong48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-ldiv-34"><code>ldiv</code></a>: <a href="#ldiv">ldiv</a></li>
<li><a href="#index-link-489"><code>link</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-linking-the-C-library-475">linking the C library</a>: <a href="#Syscalls">Syscalls</a></li>
<li><a href="#index-list-of-reentrant-functions-468">list of reentrant functions</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-llabs-35"><code>llabs</code></a>: <a href="#llabs">llabs</a></li>
<li><a href="#index-lldiv-36"><code>lldiv</code></a>: <a href="#lldiv">lldiv</a></li>
<li><a href="#index-localeconv-458"><code>localeconv</code></a>: <a href="#setlocale">setlocale</a></li>
<li><a href="#index-localtime-448"><code>localtime</code></a>: <a href="#localtime">localtime</a></li>
<li><a href="#index-localtime_005fr-449"><code>localtime_r</code></a>: <a href="#localtime">localtime</a></li>
<li><a href="#index-lrand48-72"><code>lrand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-lseek-490"><code>lseek</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-mallinfo-49"><code>mallinfo</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-malloc-37"><code>malloc</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-malloc_005fstats-50"><code>malloc_stats</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-malloc_005fusable_005fsize-42"><code>malloc_usable_size</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-mallopt-51"><code>mallopt</code></a>: <a href="#mallinfo">mallinfo</a></li>
<li><a href="#index-mblen-57"><code>mblen</code></a>: <a href="#mblen">mblen</a></li>
<li><a href="#index-mbsnrtowcs-60"><code>mbsnrtowcs</code></a>: <a href="#mbsrtowcs">mbsrtowcs</a></li>
<li><a href="#index-mbsrtowcs-58"><code>mbsrtowcs</code></a>: <a href="#mbsrtowcs">mbsrtowcs</a></li>
<li><a href="#index-mbstowcs-62"><code>mbstowcs</code></a>: <a href="#mbstowcs">mbstowcs</a></li>
<li><a href="#index-mbtowc-63"><code>mbtowc</code></a>: <a href="#mbtowc">mbtowc</a></li>
<li><a href="#index-memalign-41"><code>memalign</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-memchr-389"><code>memchr</code></a>: <a href="#memchr">memchr</a></li>
<li><a href="#index-memcmp-390"><code>memcmp</code></a>: <a href="#memcmp">memcmp</a></li>
<li><a href="#index-memmem-391"><code>memmem</code></a>: <a href="#memmem">memmem</a></li>
<li><a href="#index-memmove-392"><code>memmove</code></a>: <a href="#memmove">memmove</a></li>
<li><a href="#index-memset-393"><code>memset</code></a>: <a href="#memset">memset</a></li>
<li><a href="#index-mkdtemp-230"><code>mkdtemp</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mkostemp-233"><code>mkostemp</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mkostemps-234"><code>mkostemps</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mkstemp-231"><code>mkstemp</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mkstemps-232"><code>mkstemps</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mktemp-229"><code>mktemp</code></a>: <a href="#mktemp">mktemp</a></li>
<li><a href="#index-mktime-450"><code>mktime</code></a>: <a href="#mktime">mktime</a></li>
<li><a href="#index-mrand48-74"><code>mrand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-nrand48-73"><code>nrand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-on_005fexit-64"><code>on_exit</code></a>: <a href="#on_005fexit">on_exit</a></li>
<li><a href="#index-open-491"><code>open</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-open_005fmemstream-241"><code>open_memstream</code></a>: <a href="#open_005fmemstream">open_memstream</a></li>
<li><a href="#index-open_005fwmemstream-242"><code>open_wmemstream</code></a>: <a href="#open_005fmemstream">open_memstream</a></li>
<li><a href="#index-OS-interface-subroutines-478">OS interface subroutines</a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-pclose-474"><code>pclose</code></a>: <a href="#popen">popen</a></li>
<li><a href="#index-perror-243"><code>perror</code></a>: <a href="#perror">perror</a></li>
<li><a href="#index-popen-473"><code>popen</code></a>: <a href="#popen">popen</a></li>
<li><a href="#index-printf-286"><code>printf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-putc-245"><code>putc</code></a>: <a href="#putc">putc</a></li>
<li><a href="#index-putc_005funlocked-247"><code>putc_unlocked</code></a>: <a href="#putc_005funlocked">putc_unlocked</a></li>
<li><a href="#index-putchar-249"><code>putchar</code></a>: <a href="#putchar">putchar</a></li>
<li><a href="#index-putchar_005funlocked-251"><code>putchar_unlocked</code></a>: <a href="#putchar_005funlocked">putchar_unlocked</a></li>
<li><a href="#index-puts-252"><code>puts</code></a>: <a href="#puts">puts</a></li>
<li><a href="#index-putw-254"><code>putw</code></a>: <a href="#putw">putw</a></li>
<li><a href="#index-putwc-189"><code>putwc</code></a>: <a href="#fputwc">fputwc</a></li>
<li><a href="#index-putwchar-255"><code>putwchar</code></a>: <a href="#putwchar">putwchar</a></li>
<li><a href="#index-qsort-65"><code>qsort</code></a>: <a href="#qsort">qsort</a></li>
<li><a href="#index-raise-436"><code>raise</code></a>: <a href="#raise">raise</a></li>
<li><a href="#index-rand-66"><code>rand</code></a>: <a href="#rand">rand</a></li>
<li><a href="#index-rand48-69"><code>rand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-rand_005fr-68"><code>rand_r</code></a>: <a href="#rand">rand</a></li>
<li><a href="#index-read-492"><code>read</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-realloc-38"><code>realloc</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-reallocf-39"><code>reallocf</code></a>: <a href="#malloc">malloc</a></li>
<li><a href="#index-reent_002eh-463"><code>reent.h</code></a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-reentrancy-461">reentrancy</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-reentrancy-structure-464">reentrancy structure</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-reentrant-function-list-469">reentrant function list</a>: <a href="#Reentrancy">Reentrancy</a></li>
<li><a href="#index-remove-257"><code>remove</code></a>: <a href="#remove">remove</a></li>
<li><a href="#index-rename-259"><code>rename</code></a>: <a href="#rename">rename</a></li>
<li><a href="#index-rewind-260"><code>rewind</code></a>: <a href="#rewind">rewind</a></li>
<li><a href="#index-rindex-394"><code>rindex</code></a>: <a href="#rindex">rindex</a></li>
<li><a href="#index-sbrk-493"><code>sbrk</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-scanf-296"><code>scanf</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-seed48-77"><code>seed48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-setbuf-262"><code>setbuf</code></a>: <a href="#setbuf">setbuf</a></li>
<li><a href="#index-setbuffer-263"><code>setbuffer</code></a>: <a href="#setbuffer">setbuffer</a></li>
<li><a href="#index-setlinebuf-264"><code>setlinebuf</code></a>: <a href="#setlinebuf">setlinebuf</a></li>
<li><a href="#index-setlocale-457"><code>setlocale</code></a>: <a href="#setlocale">setlocale</a></li>
<li><a href="#index-setvbuf-265"><code>setvbuf</code></a>: <a href="#setvbuf">setvbuf</a></li>
<li><a href="#index-signal-438"><code>signal</code></a>: <a href="#signal">signal</a></li>
<li><a href="#index-siprintf-270"><code>siprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-siscanf-282"><code>siscanf</code></a>: <a href="#siscanf">siscanf</a></li>
<li><a href="#index-sniprintf-272"><code>sniprintf</code></a>: <a href="#siprintf">siprintf</a></li>
<li><a href="#index-snprintf-292"><code>snprintf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-sprintf-290"><code>sprintf</code></a>: <a href="#sprintf">sprintf</a></li>
<li><a href="#index-srand-67"><code>srand</code></a>: <a href="#rand">rand</a></li>
<li><a href="#index-srand48-76"><code>srand48</code></a>: <a href="#rand48">rand48</a></li>
<li><a href="#index-sscanf-300"><code>sscanf</code></a>: <a href="#sscanf">sscanf</a></li>
<li><a href="#index-stat-494"><code>stat</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-stpcpy-395"><code>stpcpy</code></a>: <a href="#stpcpy">stpcpy</a></li>
<li><a href="#index-stpncpy-396"><code>stpncpy</code></a>: <a href="#stpncpy">stpncpy</a></li>
<li><a href="#index-strcasecmp-397"><code>strcasecmp</code></a>: <a href="#strcasecmp">strcasecmp</a></li>
<li><a href="#index-strcasestr-398"><code>strcasestr</code></a>: <a href="#strcasestr">strcasestr</a></li>
<li><a href="#index-strcat-399"><code>strcat</code></a>: <a href="#strcat">strcat</a></li>
<li><a href="#index-strchr-400"><code>strchr</code></a>: <a href="#strchr">strchr</a></li>
<li><a href="#index-strcmp-401"><code>strcmp</code></a>: <a href="#strcmp">strcmp</a></li>
<li><a href="#index-strcoll-402"><code>strcoll</code></a>: <a href="#strcoll">strcoll</a></li>
<li><a href="#index-strcpy-403"><code>strcpy</code></a>: <a href="#strcpy">strcpy</a></li>
<li><a href="#index-strcspn-404"><code>strcspn</code></a>: <a href="#strcspn">strcspn</a></li>
<li><a href="#index-strerror-405"><code>strerror</code></a>: <a href="#strerror">strerror</a></li>
<li><a href="#index-strerror_005fr-406"><code>strerror_r</code></a>: <a href="#strerror_005fr">strerror_r</a></li>
<li><a href="#index-strftime-451"><code>strftime</code></a>: <a href="#strftime">strftime</a></li>
<li><a href="#index-strlen-407"><code>strlen</code></a>: <a href="#strlen">strlen</a></li>
<li><a href="#index-strlwr-408"><code>strlwr</code></a>: <a href="#strlwr">strlwr</a></li>
<li><a href="#index-strncasecmp-409"><code>strncasecmp</code></a>: <a href="#strncasecmp">strncasecmp</a></li>
<li><a href="#index-strncat-410"><code>strncat</code></a>: <a href="#strncat">strncat</a></li>
<li><a href="#index-strncmp-411"><code>strncmp</code></a>: <a href="#strncmp">strncmp</a></li>
<li><a href="#index-strncpy-412"><code>strncpy</code></a>: <a href="#strncpy">strncpy</a></li>
<li><a href="#index-strnlen-413"><code>strnlen</code></a>: <a href="#strnlen">strnlen</a></li>
<li><a href="#index-strpbrk-414"><code>strpbrk</code></a>: <a href="#strpbrk">strpbrk</a></li>
<li><a href="#index-strrchr-415"><code>strrchr</code></a>: <a href="#strrchr">strrchr</a></li>
<li><a href="#index-strsep-421"><code>strsep</code></a>: <a href="#strtok">strtok</a></li>
<li><a href="#index-strsignal-416"><code>strsignal</code></a>: <a href="#strsignal">strsignal</a></li>
<li><a href="#index-strspn-417"><code>strspn</code></a>: <a href="#strspn">strspn</a></li>
<li><a href="#index-strstr-418"><code>strstr</code></a>: <a href="#strstr">strstr</a></li>
<li><a href="#index-strtod-79"><code>strtod</code></a>: <a href="#strtod">strtod</a></li>
<li><a href="#index-strtof-81"><code>strtof</code></a>: <a href="#strtod">strtod</a></li>
<li><a href="#index-strtok-419"><code>strtok</code></a>: <a href="#strtok">strtok</a></li>
<li><a href="#index-strtok_005fr-420"><code>strtok_r</code></a>: <a href="#strtok">strtok</a></li>
<li><a href="#index-strtol-82"><code>strtol</code></a>: <a href="#strtol">strtol</a></li>
<li><a href="#index-strtoll-84"><code>strtoll</code></a>: <a href="#strtoll">strtoll</a></li>
<li><a href="#index-strtoul-86"><code>strtoul</code></a>: <a href="#strtoul">strtoul</a></li>
<li><a href="#index-strtoull-88"><code>strtoull</code></a>: <a href="#strtoull">strtoull</a></li>
<li><a href="#index-strupr-422"><code>strupr</code></a>: <a href="#strupr">strupr</a></li>
<li><a href="#index-strxfrm-423"><code>strxfrm</code></a>: <a href="#strxfrm">strxfrm</a></li>
<li><a href="#index-stubs-476">stubs</a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-subroutines-for-OS-interface-477">subroutines for OS interface</a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-swprintf-306"><code>swprintf</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-swscanf-312"><code>swscanf</code></a>: <a href="#swscanf">swscanf</a></li>
<li><a href="#index-system-106"><code>system</code></a>: <a href="#system">system</a></li>
<li><a href="#index-tempnam-317"><code>tempnam</code></a>: <a href="#tmpnam">tmpnam</a></li>
<li><a href="#index-time-452"><code>time</code></a>: <a href="#time">time</a></li>
<li><a href="#index-times-495"><code>times</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-tmpfile-314"><code>tmpfile</code></a>: <a href="#tmpfile">tmpfile</a></li>
<li><a href="#index-tmpfile64-384"><code>tmpfile64</code></a>: <a href="#tmpfile64">tmpfile64</a></li>
<li><a href="#index-tmpnam-316"><code>tmpnam</code></a>: <a href="#tmpnam">tmpnam</a></li>
<li><a href="#index-toascii-122"><code>toascii</code></a>: <a href="#toascii">toascii</a></li>
<li><a href="#index-tolower-123"><code>tolower</code></a>: <a href="#tolower">tolower</a></li>
<li><a href="#index-toupper-125"><code>toupper</code></a>: <a href="#toupper">toupper</a></li>
<li><a href="#index-towctrans-143"><code>towctrans</code></a>: <a href="#towctrans">towctrans</a></li>
<li><a href="#index-towlower-141"><code>towlower</code></a>: <a href="#towlower">towlower</a></li>
<li><a href="#index-towupper-142"><code>towupper</code></a>: <a href="#towupper">towupper</a></li>
<li><a href="#index-tzset-455"><code>tzset</code></a>: <a href="#tzset">tzset</a></li>
<li><a href="#index-unctrl-471"><code>unctrl</code></a>: <a href="#unctrl">unctrl</a></li>
<li><a href="#index-unctrllen-472"><code>unctrllen</code></a>: <a href="#unctrl">unctrl</a></li>
<li><a href="#index-ungetc-320"><code>ungetc</code></a>: <a href="#ungetc">ungetc</a></li>
<li><a href="#index-ungetwc-322"><code>ungetwc</code></a>: <a href="#ungetwc">ungetwc</a></li>
<li><a href="#index-unlink-496"><code>unlink</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-va_005falist-514"><code>va_alist</code></a>: <a href="#va_005falist">va_alist</a></li>
<li><a href="#index-va_005farg-517"><code>va_arg</code></a>: <a href="#va_005farg_002dtrad">va_arg-trad</a></li>
<li><a href="#index-va_005farg-512"><code>va_arg</code></a>: <a href="#va_005farg">va_arg</a></li>
<li><a href="#index-va_005fdcl-515"><code>va_dcl</code></a>: <a href="#va_005falist">va_alist</a></li>
<li><a href="#index-va_005fend-518"><code>va_end</code></a>: <a href="#va_005fend_002dtrad">va_end-trad</a></li>
<li><a href="#index-va_005fend-513"><code>va_end</code></a>: <a href="#va_005fend">va_end</a></li>
<li><a href="#index-va_005fstart-516"><code>va_start</code></a>: <a href="#va_005fstart_002dtrad">va_start-trad</a></li>
<li><a href="#index-va_005fstart-511"><code>va_start</code></a>: <a href="#va_005fstart">va_start</a></li>
<li><a href="#index-vasiprintf-362"><code>vasiprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-vasniprintf-364"><code>vasniprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-vasnprintf-334"><code>vasnprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vasprintf-332"><code>vasprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vdiprintf-148"><code>vdiprintf</code></a>: <a href="#diprintf">diprintf</a></li>
<li><a href="#index-vdprintf-152"><code>vdprintf</code></a>: <a href="#dprintf">dprintf</a></li>
<li><a href="#index-vfiprintf-356"><code>vfiprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-vfiscanf-368"><code>vfiscanf</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-vfprintf-324"><code>vfprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vfscanf-336"><code>vfscanf</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-vfwprintf-342"><code>vfwprintf</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-vfwscanf-348"><code>vfwscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-viprintf-354"><code>viprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-viscanf-366"><code>viscanf</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-vprintf-326"><code>vprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vscanf-338"><code>vscanf</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-vsiprintf-358"><code>vsiprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-vsiscanf-370"><code>vsiscanf</code></a>: <a href="#viscanf">viscanf</a></li>
<li><a href="#index-vsniprintf-360"><code>vsniprintf</code></a>: <a href="#viprintf">viprintf</a></li>
<li><a href="#index-vsnprintf-330"><code>vsnprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vsprintf-328"><code>vsprintf</code></a>: <a href="#vfprintf">vfprintf</a></li>
<li><a href="#index-vsscanf-340"><code>vsscanf</code></a>: <a href="#vfscanf">vfscanf</a></li>
<li><a href="#index-vswprintf-346"><code>vswprintf</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-vswscanf-352"><code>vswscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-vwprintf-344"><code>vwprintf</code></a>: <a href="#vfwprintf">vfwprintf</a></li>
<li><a href="#index-vwscanf-350"><code>vwscanf</code></a>: <a href="#vfwscanf">vfwscanf</a></li>
<li><a href="#index-wait-497"><code>wait</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-wcscasecmp-424"><code>wcscasecmp</code></a>: <a href="#wcscasecmp">wcscasecmp</a></li>
<li><a href="#index-wcscat-428"><code>wcscat</code></a>: <a href="#wcscat">wcscat</a></li>
<li><a href="#index-wcscoll-429"><code>wcscoll</code></a>: <a href="#wcscoll">wcscoll</a></li>
<li><a href="#index-wcsdup-425"><code>wcsdup</code></a>: <a href="#wcsdup">wcsdup</a></li>
<li><a href="#index-wcsftime-430"><code>wcsftime</code></a>: <a href="#wcsftime">wcsftime</a></li>
<li><a href="#index-wcsncasecmp-427"><code>wcsncasecmp</code></a>: <a href="#wcsncasecmp">wcsncasecmp</a></li>
<li><a href="#index-wcsnlen-431"><code>wcsnlen</code></a>: <a href="#wcsnlen">wcsnlen</a></li>
<li><a href="#index-wcsnrtombs-92"><code>wcsnrtombs</code></a>: <a href="#wcsrtombs">wcsrtombs</a></li>
<li><a href="#index-wcsrtombs-90"><code>wcsrtombs</code></a>: <a href="#wcsrtombs">wcsrtombs</a></li>
<li><a href="#index-wcstod-94"><code>wcstod</code></a>: <a href="#wcstod">wcstod</a></li>
<li><a href="#index-wcstof-96"><code>wcstof</code></a>: <a href="#wcstod">wcstod</a></li>
<li><a href="#index-wcstok-432"><code>wcstok</code></a>: <a href="#wcstok">wcstok</a></li>
<li><a href="#index-wcstol-98"><code>wcstol</code></a>: <a href="#wcstol">wcstol</a></li>
<li><a href="#index-wcstoll-100"><code>wcstoll</code></a>: <a href="#wcstoll">wcstoll</a></li>
<li><a href="#index-wcstombs-108"><code>wcstombs</code></a>: <a href="#wcstombs">wcstombs</a></li>
<li><a href="#index-wcstoul-102"><code>wcstoul</code></a>: <a href="#wcstoul">wcstoul</a></li>
<li><a href="#index-wcstoull-104"><code>wcstoull</code></a>: <a href="#wcstoull">wcstoull</a></li>
<li><a href="#index-wcswidth-433"><code>wcswidth</code></a>: <a href="#wcswidth">wcswidth</a></li>
<li><a href="#index-wcsxfrm-434"><code>wcsxfrm</code></a>: <a href="#wcsxfrm">wcsxfrm</a></li>
<li><a href="#index-wctomb-109"><code>wctomb</code></a>: <a href="#wctomb">wctomb</a></li>
<li><a href="#index-wctrans-144"><code>wctrans</code></a>: <a href="#wctrans">wctrans</a></li>
<li><a href="#index-wctype-140"><code>wctype</code></a>: <a href="#wctype">wctype</a></li>
<li><a href="#index-wcwidth-435"><code>wcwidth</code></a>: <a href="#wcwidth">wcwidth</a></li>
<li><a href="#index-wprintf-304"><code>wprintf</code></a>: <a href="#swprintf">swprintf</a></li>
<li><a href="#index-write-498"><code>write</code></a>: <a href="#Stubs">Stubs</a></li>
<li><a href="#index-wscanf-308"><code>wscanf</code></a>: <a href="#swscanf">swscanf</a></li>
</ul>
<div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">The Red Hat newlib C Library</a>
<li><a name="toc_Introduction" href="#Introduction">1 Introduction</a>
<li><a name="toc_Stdlib" href="#Stdlib">2 Standard Utility Functions (<samp><span class="file">stdlib.h</span></samp>)</a>
<ul>
<li><a href="#_005fExit">2.1 <code>_Exit</code>&mdash;end program execution with no cleanup processing</a>
<li><a href="#a64l">2.2 <code>a64l</code>, <code>l64a</code>&mdash;convert between radix-64 ASCII string and long</a>
<li><a href="#abort">2.3 <code>abort</code>&mdash;abnormal termination of a program</a>
<li><a href="#abs">2.4 <code>abs</code>&mdash;integer absolute value (magnitude)</a>
<li><a href="#assert">2.5 <code>assert</code>&mdash;macro for debugging diagnostics</a>
<li><a href="#atexit">2.6 <code>atexit</code>&mdash;request execution of functions at program exit</a>
<li><a href="#atof">2.7 <code>atof</code>, <code>atoff</code>&mdash;string to double or float</a>
<li><a href="#atoi">2.8 <code>atoi</code>, <code>atol</code>&mdash;string to integer</a>
<li><a href="#atoll">2.9 <code>atoll</code>&mdash;convert a string to a long long integer</a>
<li><a href="#bsearch">2.10 <code>bsearch</code>&mdash;binary search</a>
<li><a href="#calloc">2.11 <code>calloc</code>&mdash;allocate space for arrays</a>
<li><a href="#div">2.12 <code>div</code>&mdash;divide two integers</a>
<li><a href="#ecvt">2.13 <code>ecvt</code>, <code>ecvtf</code>, <code>fcvt</code>, <code>fcvtf</code>&mdash;double or float to string</a>
<li><a href="#gvcvt">2.14 <code>gvcvt</code>, <code>gcvtf</code>&mdash;format double or float as string</a>
<li><a href="#ecvtbuf">2.15 <code>ecvtbuf</code>, <code>fcvtbuf</code>&mdash;double or float to string</a>
<li><a href="#_005f_005fenv_005flock">2.16 <code>__env_lock</code>, <code>__env_unlock</code>&mdash;lock environ variable</a>
<li><a href="#exit">2.17 <code>exit</code>&mdash;end program execution</a>
<li><a href="#getenv">2.18 <code>getenv</code>&mdash;look up environment variable</a>
<li><a href="#labs">2.19 <code>labs</code>&mdash;long integer absolute value</a>
<li><a href="#ldiv">2.20 <code>ldiv</code>&mdash;divide two long integers</a>
<li><a href="#llabs">2.21 <code>llabs</code>&mdash;compute the absolute value of an long long integer.</a>
<li><a href="#lldiv">2.22 <code>lldiv</code>&mdash;divide two long long integers</a>
<li><a href="#malloc">2.23 <code>malloc</code>, <code>realloc</code>, <code>free</code>&mdash;manage memory</a>
<li><a href="#mallinfo">2.24 <code>mallinfo</code>, <code>malloc_stats</code>, <code>mallopt</code>&mdash;malloc support</a>
<li><a href="#_005f_005fmalloc_005flock">2.25 <code>__malloc_lock</code>, <code>__malloc_unlock</code>&mdash;lock malloc pool</a>
<li><a href="#mblen">2.26 <code>mblen</code>&mdash;minimal multibyte length function</a>
<li><a href="#mbsrtowcs">2.27 <code>mbsrtowcs</code>, <code>mbsnrtowcs</code>&mdash;convert a character string to a wide-character string</a>
<li><a href="#mbstowcs">2.28 <code>mbstowcs</code>&mdash;minimal multibyte string to wide char converter</a>
<li><a href="#mbtowc">2.29 <code>mbtowc</code>&mdash;minimal multibyte to wide char converter</a>
<li><a href="#on_005fexit">2.30 <code>on_exit</code>&mdash;request execution of function with argument at program exit</a>
<li><a href="#qsort">2.31 <code>qsort</code>&mdash;sort an array</a>
<li><a href="#rand">2.32 <code>rand</code>, <code>srand</code>&mdash;pseudo-random numbers</a>
<li><a href="#rand48">2.33 <code>rand48</code>, <code>drand48</code>, <code>erand48</code>, <code>lrand48</code>, <code>nrand48</code>, <code>mrand48</code>, <code>jrand48</code>, <code>srand48</code>, <code>seed48</code>, <code>lcong48</code>&mdash;pseudo-random number generators and initialization routines</a>
<li><a href="#strtod">2.34 <code>strtod</code>, <code>strtof</code>&mdash;string to double or float</a>
<li><a href="#strtol">2.35 <code>strtol</code>&mdash;string to long</a>
<li><a href="#strtoll">2.36 <code>strtoll</code>&mdash;string to long long</a>
<li><a href="#strtoul">2.37 <code>strtoul</code>&mdash;string to unsigned long</a>
<li><a href="#strtoull">2.38 <code>strtoull</code>&mdash;string to unsigned long long</a>
<li><a href="#wcsrtombs">2.39 <code>wcsrtombs</code>, <code>wcsnrtombs</code>&mdash;convert a wide-character string to a character string</a>
<li><a href="#wcstod">2.40 <code>wcstod</code>, <code>wcstof</code>&mdash;wide char string to double or float</a>
<li><a href="#wcstol">2.41 <code>wcstol</code>&mdash;wide string to long</a>
<li><a href="#wcstoll">2.42 <code>wcstoll</code>&mdash;wide string to long long</a>
<li><a href="#wcstoul">2.43 <code>wcstoul</code>&mdash;wide string to unsigned long</a>
<li><a href="#wcstoull">2.44 <code>wcstoull</code>&mdash;wide string to unsigned long long</a>
<li><a href="#system">2.45 <code>system</code>&mdash;execute command string</a>
<li><a href="#wcstombs">2.46 <code>wcstombs</code>&mdash;minimal wide char string to multibyte string converter</a>
<li><a href="#wctomb">2.47 <code>wctomb</code>&mdash;minimal wide char to multibyte converter</a>
</li></ul>
<li><a name="toc_Ctype" href="#Ctype">3 Character Type Macros and Functions (<samp><span class="file">ctype.h</span></samp>)</a>
<ul>
<li><a href="#isalnum">3.1 <code>isalnum</code>&mdash;alphanumeric character predicate</a>
<li><a href="#isalpha">3.2 <code>isalpha</code>&mdash;alphabetic character predicate</a>
<li><a href="#isascii">3.3 <code>isascii</code>&mdash;ASCII character predicate</a>
<li><a href="#iscntrl">3.4 <code>iscntrl</code>&mdash;control character predicate</a>
<li><a href="#isdigit">3.5 <code>isdigit</code>&mdash;decimal digit predicate</a>
<li><a href="#islower">3.6 <code>islower</code>&mdash;lowercase character predicate</a>
<li><a href="#isprint">3.7 <code>isprint</code>, <code>isgraph</code>&mdash;printable character predicates</a>
<li><a href="#ispunct">3.8 <code>ispunct</code>&mdash;punctuation character predicate</a>
<li><a href="#isspace">3.9 <code>isspace</code>&mdash;whitespace character predicate</a>
<li><a href="#isupper">3.10 <code>isupper</code>&mdash;uppercase character predicate</a>
<li><a href="#isxdigit">3.11 <code>isxdigit</code>&mdash;hexadecimal digit predicate</a>
<li><a href="#toascii">3.12 <code>toascii</code>&mdash;force integers to ASCII range</a>
<li><a href="#tolower">3.13 <code>tolower</code>&mdash;translate characters to lowercase</a>
<li><a href="#toupper">3.14 <code>toupper</code>&mdash;translate characters to uppercase</a>
<li><a href="#iswalnum">3.15 <code>iswalnum</code>&mdash;alphanumeric wide character test</a>
<li><a href="#iswalpha">3.16 <code>iswalpha</code>&mdash;alphabetic wide character test</a>
<li><a href="#iswcntrl">3.17 <code>iswcntrl</code>&mdash;control wide character test</a>
<li><a href="#iswblank">3.18 <code>iswblank</code>&mdash;blank wide character test</a>
<li><a href="#iswdigit">3.19 <code>iswdigit</code>&mdash;decimal digit wide character test</a>
<li><a href="#iswgraph">3.20 <code>iswgraph</code>&mdash;graphic wide character test</a>
<li><a href="#iswlower">3.21 <code>iswlower</code>&mdash;lowercase wide character test</a>
<li><a href="#iswprint">3.22 <code>iswprint</code>&mdash;printable wide character test</a>
<li><a href="#iswpunct">3.23 <code>iswpunct</code>&mdash;punctuation wide character test</a>
<li><a href="#iswspace">3.24 <code>iswspace</code>&mdash;whitespace wide character test</a>
<li><a href="#iswupper">3.25 <code>iswupper</code>&mdash;uppercase wide character test</a>
<li><a href="#iswxdigit">3.26 <code>iswxdigit</code>&mdash;hexadecimal digit wide character test</a>
<li><a href="#iswctype">3.27 <code>iswctype</code>&mdash;extensible wide-character test</a>
<li><a href="#wctype">3.28 <code>wctype</code>&mdash;get wide-character classification type</a>
<li><a href="#towlower">3.29 <code>towlower</code>&mdash;translate wide characters to lowercase</a>
<li><a href="#towupper">3.30 <code>towupper</code>&mdash;translate wide characters to uppercase</a>
<li><a href="#towctrans">3.31 <code>towctrans</code>&mdash;extensible wide-character translation</a>
<li><a href="#wctrans">3.32 <code>wctrans</code>&mdash;get wide-character translation type</a>
</li></ul>
<li><a name="toc_Stdio" href="#Stdio">4 Input and Output (<samp><span class="file">stdio.h</span></samp>)</a>
<ul>
<li><a href="#clearerr">4.1 <code>clearerr</code>&mdash;clear file or stream error indicator</a>
<li><a href="#diprintf">4.2 <code>diprintf</code>, <code>vdiprintf</code>&mdash;print to a file descriptor (integer only)</a>
<li><a href="#dprintf">4.3 <code>dprintf</code>, <code>vdprintf</code>&mdash;print to a file descriptor</a>
<li><a href="#fclose">4.4 <code>fclose</code>&mdash;close a file</a>
<li><a href="#fcloseall">4.5 <code>fcloseall</code>&mdash;close all files</a>
<li><a href="#fdopen">4.6 <code>fdopen</code>&mdash;turn open file into a stream</a>
<li><a href="#feof">4.7 <code>feof</code>&mdash;test for end of file</a>
<li><a href="#ferror">4.8 <code>ferror</code>&mdash;test whether read/write error has occurred</a>
<li><a href="#fflush">4.9 <code>fflush</code>&mdash;flush buffered file output</a>
<li><a href="#fgetc">4.10 <code>fgetc</code>&mdash;get a character from a file or stream</a>
<li><a href="#fgetpos">4.11 <code>fgetpos</code>&mdash;record position in a stream or file</a>
<li><a href="#fgets">4.12 <code>fgets</code>&mdash;get character string from a file or stream</a>
<li><a href="#fgetwc">4.13 <code>fgetwc</code>, <code>getwc</code>&mdash;get a wide character from a file or stream</a>
<li><a href="#fgetws">4.14 <code>fgetws</code>&mdash;get wide character string from a file or stream</a>
<li><a href="#fileno">4.15 <code>fileno</code>&mdash;return file descriptor associated with stream</a>
<li><a href="#fmemopen">4.16 <code>fmemopen</code>&mdash;open a stream around a fixed-length string</a>
<li><a href="#fopen">4.17 <code>fopen</code>&mdash;open a file</a>
<li><a href="#fopencookie">4.18 <code>fopencookie</code>&mdash;open a stream with custom callbacks</a>
<li><a href="#fpurge">4.19 <code>fpurge</code>&mdash;discard pending file I/O</a>
<li><a href="#fputc">4.20 <code>fputc</code>&mdash;write a character on a stream or file</a>
<li><a href="#fputs">4.21 <code>fputs</code>&mdash;write a character string in a file or stream</a>
<li><a href="#fputwc">4.22 <code>fputwc</code>, <code>putwc</code>&mdash;write a wide character on a stream or file</a>
<li><a href="#fputws">4.23 <code>fputws</code>&mdash;write a wide character string in a file or stream</a>
<li><a href="#fread">4.24 <code>fread</code>&mdash;read array elements from a file</a>
<li><a href="#freopen">4.25 <code>freopen</code>&mdash;open a file using an existing file descriptor</a>
<li><a href="#fseek">4.26 <code>fseek</code>, <code>fseeko</code>&mdash;set file position</a>
<li><a href="#fsetpos">4.27 <code>fsetpos</code>&mdash;restore position of a stream or file</a>
<li><a href="#ftell">4.28 <code>ftell</code>, <code>ftello</code>&mdash;return position in a stream or file</a>
<li><a href="#funopen">4.29 <code>funopen</code>, <code>fropen</code>, <code>fwopen</code>&mdash;open a stream with custom callbacks</a>
<li><a href="#fwide">4.30 <code>fwide</code>&mdash;set and determine the orientation of a FILE stream</a>
<li><a href="#fwrite">4.31 <code>fwrite</code>&mdash;write array elements</a>
<li><a href="#getc">4.32 <code>getc</code>&mdash;read a character (macro)</a>
<li><a href="#getc_005funlocked">4.33 <code>getc_unlocked</code>&mdash;non-thread-safe version of getc (macro)</a>
<li><a href="#getchar">4.34 <code>getchar</code>&mdash;read a character (macro)</a>
<li><a href="#getchar_005funlocked">4.35 <code>getchar_unlocked</code>&mdash;non-thread-safe version of getchar (macro)</a>
<li><a href="#getdelim">4.36 <code>getdelim</code>&mdash;read a line up to a specified line delimiter</a>
<li><a href="#getline">4.37 <code>getline</code>&mdash;read a line from a file</a>
<li><a href="#gets">4.38 <code>gets</code>&mdash;get character string (obsolete, use <code>fgets</code> instead)</a>
<li><a href="#getw">4.39 <code>getw</code>&mdash;read a word (int)</a>
<li><a href="#getwchar">4.40 <code>getwchar</code>&mdash;read a wide character from standard input</a>
<li><a href="#mktemp">4.41 <code>mktemp</code>, <code>mkstemp</code>, <code>mkostemp</code>, <code>mkstemps</code>,</a>
<li><a href="#open_005fmemstream">4.42 <code>open_memstream</code>, <code>open_wmemstream</code>&mdash;open a write stream around an arbitrary-length string</a>
<li><a href="#perror">4.43 <code>perror</code>&mdash;print an error message on standard error</a>
<li><a href="#putc">4.44 <code>putc</code>&mdash;write a character (macro)</a>
<li><a href="#putc_005funlocked">4.45 <code>putc_unlocked</code>&mdash;non-thread-safe version of putc (macro)</a>
<li><a href="#putchar">4.46 <code>putchar</code>&mdash;write a character (macro)</a>
<li><a href="#putchar_005funlocked">4.47 <code>putchar_unlocked</code>&mdash;non-thread-safe version of putchar (macro)</a>
<li><a href="#puts">4.48 <code>puts</code>&mdash;write a character string</a>
<li><a href="#putw">4.49 <code>putw</code>&mdash;write a word (int)</a>
<li><a href="#putwchar">4.50 <code>putwchar</code>&mdash;write a wide character to standard output</a>
<li><a href="#remove">4.51 <code>remove</code>&mdash;delete a file's name</a>
<li><a href="#rename">4.52 <code>rename</code>&mdash;rename a file</a>
<li><a href="#rewind">4.53 <code>rewind</code>&mdash;reinitialize a file or stream</a>
<li><a href="#setbuf">4.54 <code>setbuf</code>&mdash;specify full buffering for a file or stream</a>
<li><a href="#setbuffer">4.55 <code>setbuffer</code>&mdash;specify full buffering for a file or stream with size</a>
<li><a href="#setlinebuf">4.56 <code>setlinebuf</code>&mdash;specify line buffering for a file or stream</a>
<li><a href="#setvbuf">4.57 <code>setvbuf</code>&mdash;specify file or stream buffering</a>
<li><a href="#siprintf">4.58 <code>siprintf</code>, <code>fiprintf</code>, <code>iprintf</code>, <code>sniprintf</code>, <code>asiprintf</code>, <code>asniprintf</code>&mdash;format output (integer only)</a>
<li><a href="#siscanf">4.59 <code>siscanf</code>, <code>fiscanf</code>, <code>iscanf</code>&mdash;scan and format non-floating input</a>
<li><a href="#sprintf">4.60 <code>sprintf</code>, <code>fprintf</code>, <code>printf</code>, <code>snprintf</code>, <code>asprintf</code>, <code>asnprintf</code>&mdash;format output</a>
<li><a href="#sscanf">4.61 <code>sscanf</code>, <code>fscanf</code>, <code>scanf</code>&mdash;scan and format input</a>
<li><a href="#swprintf">4.62 <code>swprintf</code>, <code>fwprintf</code>, <code>wprintf</code>&mdash;wide character format output</a>
<li><a href="#swscanf">4.63 <code>swscanf</code>, <code>fwscanf</code>, <code>wscanf</code>&mdash;scan and format wide character input</a>
<li><a href="#tmpfile">4.64 <code>tmpfile</code>&mdash;create a temporary file</a>
<li><a href="#tmpnam">4.65 <code>tmpnam</code>, <code>tempnam</code>&mdash;name for a temporary file</a>
<li><a href="#ungetc">4.66 <code>ungetc</code>&mdash;push data back into a stream</a>
<li><a href="#ungetwc">4.67 <code>ungetwc</code>&mdash;push wide character data back into a stream</a>
<li><a href="#vfprintf">4.68 <code>vfprintf</code>, <code>vprintf</code>, <code>vsprintf</code>, <code>vsnprintf</code>, <code>vasprintf</code>, <code>vasnprintf</code>&mdash;format argument list</a>
<li><a href="#vfscanf">4.69 <code>vfscanf</code>, <code>vscanf</code>, <code>vsscanf</code>&mdash;format argument list</a>
<li><a href="#vfwprintf">4.70 <code>vfwprintf</code>, <code>vwprintf</code>, <code>vswprintf</code>&mdash;wide character format argument list</a>
<li><a href="#vfwscanf">4.71 <code>vfwscanf</code>, <code>vwscanf</code>, <code>vswscanf</code>&mdash;scan and format argument list from wide character input</a>
<li><a href="#viprintf">4.72 <code>viprintf</code>, <code>vfiprintf</code>, <code>vsiprintf</code>, <code>vsniprintf</code>, <code>vasiprintf</code>, <code>vasniprintf</code>&mdash;format argument list (integer only)</a>
<li><a href="#viscanf">4.73 <code>viscanf</code>, <code>vfiscanf</code>, <code>vsiscanf</code>&mdash;format argument list</a>
</li></ul>
<li><a name="toc_Stdio64" href="#Stdio64">5 Large File Input and Output (<samp><span class="file">stdio.h</span></samp>)</a>
<ul>
<li><a href="#fopen64">5.1 <code>fopen64</code>&mdash;open a large file</a>
<li><a href="#freopen64">5.2 <code>freopen64</code>&mdash;open a large file using an existing file descriptor</a>
<li><a href="#ftello64">5.3 <code>ftello64</code>&mdash;return position in a stream or file</a>
<li><a href="#fseeko64">5.4 <code>fseeko64</code>&mdash;set file position for large file</a>
<li><a href="#fgetpos64">5.5 <code>fgetpos64</code>&mdash;record position in a large stream or file</a>
<li><a href="#fsetpos64">5.6 <code>fsetpos64</code>&mdash;restore position of a large stream or file</a>
<li><a href="#tmpfile64">5.7 <code>tmpfile64</code>&mdash;create a large temporary file</a>
</li></ul>
<li><a name="toc_Strings" href="#Strings">6 Strings and Memory (<samp><span class="file">string.h</span></samp>)</a>
<ul>
<li><a href="#bcmp">6.1 <code>bcmp</code>&mdash;compare two memory areas</a>
<li><a href="#bcopy">6.2 <code>bcopy</code>&mdash;copy memory regions</a>
<li><a href="#bzero">6.3 <code>bzero</code>&mdash;initialize memory to zero</a>
<li><a href="#index">6.4 <code>index</code>&mdash;search for character in string</a>
<li><a href="#memccpy">6.5 <code>memccpy</code>&mdash;copy memory regions with end-token check</a>
<li><a href="#memchr">6.6 <code>memchr</code>&mdash;find character in memory</a>
<li><a href="#memcmp">6.7 <code>memcmp</code>&mdash;compare two memory areas</a>
<li><a href="#memcpy">6.8 <code>memcpy</code>&mdash;copy memory regions</a>
<li><a href="#memmem">6.9 <code>memmem</code>&mdash;find memory segment</a>
<li><a href="#memmove">6.10 <code>memmove</code>&mdash;move possibly overlapping memory</a>
<li><a href="#mempcpy">6.11 <code>mempcpy</code>&mdash;copy memory regions and return end pointer</a>
<li><a href="#memset">6.12 <code>memset</code>&mdash;set an area of memory</a>
<li><a href="#rindex">6.13 <code>rindex</code>&mdash;reverse search for character in string</a>
<li><a href="#stpcpy">6.14 <code>stpcpy</code>&mdash;copy string returning a pointer to its end</a>
<li><a href="#stpncpy">6.15 <code>stpncpy</code>&mdash;counted copy string returning a pointer to its end</a>
<li><a href="#strcasecmp">6.16 <code>strcasecmp</code>&mdash;case-insensitive character string compare</a>
<li><a href="#strcasestr">6.17 <code>strcasestr</code>&mdash;case-insensitive character string search</a>
<li><a href="#strcat">6.18 <code>strcat</code>&mdash;concatenate strings</a>
<li><a href="#strchr">6.19 <code>strchr</code>&mdash;search for character in string</a>
<li><a href="#strcmp">6.20 <code>strcmp</code>&mdash;character string compare</a>
<li><a href="#strcoll">6.21 <code>strcoll</code>&mdash;locale-specific character string compare</a>
<li><a href="#strcpy">6.22 <code>strcpy</code>&mdash;copy string</a>
<li><a href="#strcspn">6.23 <code>strcspn</code>&mdash;count characters not in string</a>
<li><a href="#strerror">6.24 <code>strerror</code>&mdash;convert error number to string</a>
<li><a href="#strerror_005fr">6.25 <code>strerror_r</code>&mdash;convert error number to string and copy to buffer</a>
<li><a href="#strlen">6.26 <code>strlen</code>&mdash;character string length</a>
<li><a href="#strlwr">6.27 <code>strlwr</code>&mdash;force string to lowercase</a>
<li><a href="#strncasecmp">6.28 <code>strncasecmp</code>&mdash;case-insensitive character string compare</a>
<li><a href="#strncat">6.29 <code>strncat</code>&mdash;concatenate strings</a>
<li><a href="#strncmp">6.30 <code>strncmp</code>&mdash;character string compare</a>
<li><a href="#strncpy">6.31 <code>strncpy</code>&mdash;counted copy string</a>
<li><a href="#strnlen">6.32 <code>strnlen</code>&mdash;character string length</a>
<li><a href="#strpbrk">6.33 <code>strpbrk</code>&mdash;find characters in string</a>
<li><a href="#strrchr">6.34 <code>strrchr</code>&mdash;reverse search for character in string</a>
<li><a href="#strsignal">6.35 <code>strsignal</code>&mdash;convert signal number to string</a>
<li><a href="#strspn">6.36 <code>strspn</code>&mdash;find initial match</a>
<li><a href="#strstr">6.37 <code>strstr</code>&mdash;find string segment</a>
<li><a href="#strtok">6.38 <code>strtok</code>, <code>strtok_r</code>, <code>strsep</code>&mdash;get next token from a string</a>
<li><a href="#strupr">6.39 <code>strupr</code>&mdash;force string to uppercase</a>
<li><a href="#strxfrm">6.40 <code>strxfrm</code>&mdash;transform string</a>
<li><a href="#swab">6.41 <code>swab</code>&mdash;swap adjacent bytes</a>
<li><a href="#wcscasecmp">6.42 <code>wcscasecmp</code>&mdash;case-insensitive wide character string compare</a>
<li><a href="#wcsdup">6.43 <code>wcsdup</code>&mdash;wide character string duplicate</a>
<li><a href="#wcsncasecmp">6.44 <code>wcsncasecmp</code>&mdash;case-insensitive wide character string compare</a>
</li></ul>
<li><a name="toc_Wchar-strings" href="#Wchar-strings">7 Wide Character Strings (<samp><span class="file">wchar.h</span></samp>)</a>
<ul>
<li><a href="#wmemchr">7.1 <code>wmemchr</code>&mdash;find a wide character in memory</a>
<li><a href="#wmemcmp">7.2 <code>wmemcmp</code>&mdash;compare wide characters in memory</a>
<li><a href="#wmemcpy">7.3 <code>wmemcpy</code>&mdash;copy wide characters in memory</a>
<li><a href="#wmemmove">7.4 <code>wmemmove</code>&mdash;copy wide characters in memory with overlapping areas</a>
<li><a href="#wmemset">7.5 <code>wmemset</code>&mdash;set wide characters in memory</a>
<li><a href="#wcscat">7.6 <code>wcscat</code>&mdash;concatenate two wide-character strings</a>
<li><a href="#wcschr">7.7 <code>wcschr</code>&mdash;wide-character string scanning operation</a>
<li><a href="#wcscmp">7.8 <code>wcscmp</code>&mdash;compare two wide-character strings</a>
<li><a href="#wcscoll">7.9 <code>wcscoll</code>&mdash;locale-specific wide-character string compare</a>
<li><a href="#wcscpy">7.10 <code>wcscpy</code>&mdash;copy a wide-character string</a>
<li><a href="#wcpcpy">7.11 <code>wcpcpy</code>&mdash;copy a wide-character string returning a pointer to its end</a>
<li><a href="#wcscspn">7.12 <code>wcscspn</code>&mdash;get length of a complementary wide substring</a>
<li><a href="#wcsftime">7.13 <code>wcsftime</code>&ndash;convert date and time to a formatted wide-character string</a>
<li><a href="#wcslcat">7.14 <code>wcslcat</code>&mdash;concatenate wide-character strings to specified length</a>
<li><a href="#wcslcpy">7.15 <code>wcslcpy</code>&mdash;copy a wide-character string to specified length</a>
<li><a href="#wcslen">7.16 <code>wcslen</code>&mdash;get wide-character string length</a>
<li><a href="#wcsncat">7.17 <code>wcsncat</code>&mdash;concatenate part of two wide-character strings</a>
<li><a href="#wcsncmp">7.18 <code>wcsncmp</code>&mdash;compare part of two wide-character strings</a>
<li><a href="#wcsncpy">7.19 <code>wcsncpy</code>&mdash;copy part of a wide-character string</a>
<li><a href="#wcpncpy">7.20 <code>wcpncpy</code>&mdash;copy part of a wide-character string returning a pointer to its end</a>
<li><a href="#wcsnlen">7.21 <code>wcsnlen</code>&mdash;get fixed-size wide-character string length</a>
<li><a href="#wcspbrk">7.22 <code>wcspbrk</code>&mdash;&ndash;scan wide-character string for a wide-character code</a>
<li><a href="#wcsrchr">7.23 <code>wcsrchr</code>&mdash;wide-character string scanning operation</a>
<li><a href="#wcsspn">7.24 <code>wcsspn</code>&mdash;get length of a wide substring</a>
<li><a href="#wcsstr">7.25 <code>wcsstr</code>&mdash;find a wide-character substring</a>
<li><a href="#wcstok">7.26 <code>wcstok</code>&mdash;get next token from a string</a>
<li><a href="#wcswidth">7.27 <code>wcswidth</code>&mdash;number of column positions of a wide-character string</a>
<li><a href="#wcsxfrm">7.28 <code>wcsxfrm</code>&mdash;locale-specific wide-character string transformation</a>
<li><a href="#wcwidth">7.29 <code>wcwidth</code>&mdash;number of column positions of a wide-character code</a>
</li></ul>
<li><a name="toc_Signals" href="#Signals">8 Signal Handling (<samp><span class="file">signal.h</span></samp>)</a>
<ul>
<li><a href="#raise">8.1 <code>raise</code>&mdash;send a signal</a>
<li><a href="#signal">8.2 <code>signal</code>&mdash;specify handler subroutine for a signal</a>
</li></ul>
<li><a name="toc_Timefns" href="#Timefns">9 Time Functions (<samp><span class="file">time.h</span></samp>)</a>
<ul>
<li><a href="#asctime">9.1 <code>asctime</code>&mdash;format time as string</a>
<li><a href="#clock">9.2 <code>clock</code>&mdash;cumulative processor time</a>
<li><a href="#ctime">9.3 <code>ctime</code>&mdash;convert time to local and format as string</a>
<li><a href="#difftime">9.4 <code>difftime</code>&mdash;subtract two times</a>
<li><a href="#gmtime">9.5 <code>gmtime</code>&mdash;convert time to UTC traditional form</a>
<li><a href="#localtime">9.6 <code>localtime</code>&mdash;convert time to local representation</a>
<li><a href="#mktime">9.7 <code>mktime</code>&mdash;convert time to arithmetic representation</a>
<li><a href="#strftime">9.8 <code>strftime</code>&mdash;convert date and time to a formatted string</a>
<li><a href="#time">9.9 <code>time</code>&mdash;get current calendar time (as single number)</a>
<li><a href="#_005f_005ftz_005flock">9.10 <code>__tz_lock</code>, <code>__tz_unlock</code>&mdash;lock time zone global variables</a>
<li><a href="#tzset">9.11 <code>tzset</code>&mdash;set timezone characteristics from TZ environment variable</a>
</li></ul>
<li><a name="toc_Locale" href="#Locale">10 Locale (<samp><span class="file">locale.h</span></samp>)</a>
<ul>
<li><a href="#setlocale">10.1 <code>setlocale</code>, <code>localeconv</code>&mdash;select or query locale</a>
</li></ul>
<li><a name="toc_Reentrancy" href="#Reentrancy">11 Reentrancy</a>
<li><a name="toc_Misc" href="#Misc">12 Miscellaneous Macros and Functions</a>
<ul>
<li><a href="#ffs">12.1 <code>ffs</code>&mdash;find first bit set in a word</a>
<li><a href="#unctrl">12.2 <code>unctrl</code>&mdash;get printable representation of a character</a>
</li></ul>
<li><a name="toc_Posix" href="#Posix">13 Posix Functions</a>
<ul>
<li><a href="#popen">13.1 <code>popen</code>, <code>pclose</code>&mdash;tie a stream to a command string</a>
</li></ul>
<li><a name="toc_Syscalls" href="#Syscalls">14 System Calls</a>
<ul>
<li><a href="#Stubs">14.1 Definitions for OS interface</a>
<li><a href="#Reentrant-Syscalls">14.2 Reentrant covers for OS subroutines</a>
</li></ul>
<li><a name="toc_Arglists" href="#Arglists">15 Variable Argument Lists</a>
<ul>
<li><a href="#Stdarg">15.1 ANSI-standard macros, <samp><span class="file">stdarg.h</span></samp></a>
<ul>
<li><a href="#va_005fstart">15.1.1 Initialize variable argument list</a>
<li><a href="#va_005farg">15.1.2 Extract a value from argument list</a>
<li><a href="#va_005fend">15.1.3 Abandon a variable argument list</a>
</li></ul>
<li><a href="#Varargs">15.2 Traditional macros, <samp><span class="file">varargs.h</span></samp></a>
<ul>
<li><a href="#va_005falist">15.2.1 Declare variable arguments</a>
<li><a href="#va_005fstart_002dtrad">15.2.2 Initialize variable argument list</a>
<li><a href="#va_005farg_002dtrad">15.2.3 Extract a value from argument list</a>
<li><a href="#va_005fend_002dtrad">15.2.4 Abandon a variable argument list</a>
</li></ul>
</li></ul>
<li><a name="toc_Library-Index" href="#Library-Index">Index</a>
</li></ul>
</div>

</body></html>

